<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="./assets/images/graphics/favicon.png">
    <meta name="description" content="An online book about collision detection using p5js, онлайн-книга про виявлення зіткнень за допомогою p5js">
    <meta name="keywords" content="Object-oriented collision, interactive collision">
    <title>Виявлення зіткнень: об’єктно-орієнтоване зіткнення</title>

    <!-- FONTS AND CSS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400..700&family=Raleway:ital,wght@0,100..900;1,100..900&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <link href="./assets/css/stylesheet.css" rel="stylesheet" type="text/css">

    <!-- CODE PRETTIFY -->
    <link href="./assets/css/obsidian.min.css" rel="stylesheet" type="text/css">
    <script src="./assets/js/highlight.min.js"></script>

    <!-- additional behaviour -->
    <script src="./assets/js/main.js"></script>
</head>

<body>
<div id="wrapper">
    <header class="navigation">
        <span id="prev"><a href="./section-5-challenges.html">←</a></span>
        <span id="title">
            <a id="navigation-title"
               class="navigation-title inline-link bg-blue"
               data-prev-title="Завдання 5"
               data-curr-title="Виявлення зіткнень"
               data-next-title="Dealing With Matrix Transformations"
               href="table-of-contents.html"
            >Виявлення зіткнень</a>
        </span>
        <span id="next"><a href="./matrix-transformations.html">→</a></span>
    </header>

    <iframe class="w-full canvas" style="aspect-ratio:2/1" loading="lazy" src="./assets/code-examples/object-oriented-collision/"></iframe>

    <p class="caption">
        Оновіть сторінку для нового положення випадкових квадратів!
    </p>

    <h1 class="uppercase">Перехід до об’єктно-орієнтованого зіткнення</h1>

    <p>
        Вітаю! Ви пройшли через значну кількість коду з виявлення колізій. Але ці приклади призначені лише для простої
        демонстрації того, як працюють алгоритми. Об’єднання їх у більші проекти, ймовірно, означає переведення вашого
        коду на об’єктно-орієнтований підхід. (Чудовий вступ до об’єктно-орієнтованого програмування можна подивитись
        у книзі Деніела Шиффмана <a class="inline-link" href="https://manoylovac.github.io/noc2/random.html" target="_blank"><em>Природа коду</em></a>).
    </p>

    <p>
        Навіщо? Скажімо, у нас є круг та купа прямокутників (як вище). Ми могли б зберігати окремі позиції, розміри
        та стан зіткнення для кожного з них, але це швидко призведе до безладдя.
        Натомість класи <span class="code">Circle</span> і <span class="code">Rectangle</span> нададуть нашому коду
        набагато більше потужності та гнучкості.
    </p>

    <p>Почнімо зі створення нашого класу <span class="code">Circle</span>:</p>

    <pre><code class="language-js code-block sm-txt">class Circle {
  constructor(x, y, r) {
    this.x = x; // x-координата
    this.y = y; // y-координата
    this.r = r; // радіус
  }

  update(x, y) {
    this.x = x;
    this.y = y;
  }

  // малювання круга
  display() {
    fill(0, 150);
    noStroke();
    ellipse(this.x, this.y, this.r * 2, this.r * 2);
  }
}
</code></pre>

    <p>
        Це було досить просто. Ми також можемо створити й базовий клас <span class="code">Rectangle</span>:
    </p>

    <pre><code class="language-js code-block sm-txt">class Rectangle {
  constructor(x, y, w, h) {
    // xy-координати лівого кута
    this.x = x;
    this.y = y;
    this.w = w; // ширина,
    this.h = h; // висота,
    this.isHit = false; // чи є зіткнення
  }

  // перевірка на зіткнення з кругом
  // використовуючи функцію isCircleWithRectCollides, яку ми зробили на початку
  checkCollisionWithCircle(c) {
    this.isHit = isCircleWithRectCollides(c.x, c.y, c.r, this.x, this.y, this.w, this.h);
  }

  // малювання прямокутника
  display() {
    // при зіткненні змінюємо колір
    if (this.isHit) {
      fill(255, 150, 0);
    } else {
      fill(0, 150, 255);
    }
    noStroke();
    rect(this.x, this.y, this.w, this.h);
  }
}
</code></pre>

    <p>
        Зауважте, що у класі <span class="code">Rectangle</span> у нас є змінна під назвою <span class="code">isHit</span>.
        У ній ми будемо зберігати поточний стан обʼєкта стосовно того, чи він має колізію з кругом, і відповідно змінювати
        колір його заливки. За замовчуванням значення встановлено на <span class="code">false</span>.
    </p>

    <p>
        У нас буде лише один обʼєкт типу <span class="code">Circle</span>, але ми створимо масив об’єктів
        <span class="code">Rectangle</span>. Ось так виглядатиме функція <span class="code">draw()</span>, яка
        малюватиме наші фігури і оновлюватиме положення круга:
    </p>

    <pre><code class="language-js code-block">function draw() {
  background(255);

  // перебір усіх прямокутників
  for (const rectangle of rects) {
    rectangle.checkCollisionWithCircle(circle);  // перевірка на колізію
    rectangle.display();                         // малювання прямокутника
  }

  // оновлення положення круга положенням курсора і його зображення
  circle.update(mouseX, mouseY);
  circle.display();
}
</code></pre>

    <p>
        So how do we test if the circle has hit something? Let's create a <em>method</em> (an internal function) of the
        <span class="code">Rectangle</span> class called <span class="code">checkCollision()</span>. We'll pass the <span class="code">Circle</span> object as
        an argument, then do a basic <a href="./circle-rect.html">Круг і Прямокутник</a> collision test.
    </p>

    Отже, як ми перевіримо, чи коло щось вдарило? Давайте створимо метод (внутрішню функцію) класу Rectangleпід назвою checkCollision(). Ми передамо Circleоб’єкт як аргумент, а потім виконаємо базовий тест на зіткнення кола/прямокутника .

    <pre><code class="language-js code-block">void checkCollision(Circle c) {
  isHit = isCircleWithRectCollides(c.x,c.y,c.r, x,y,w,h);
}
</code></pre>

    <p>
        The result of <span class="code">isCircleWithRectCollides()</span> sets <span class="code">isHit</span> to be <span class="code">true</span> or <span class="code">false</span>,
        which in turn changes the fill color. Now we just add the test to the <span class="code">draw()</span> loop:
    </p>

    Результат circleRect()встановлює hitзначення trueабо false, що, у свою чергу, змінює колір заливки. Тепер ми просто додаємо тест до draw()циклу:

    <pre><code class="language-js code-block">for (Rectangle r : rects) {
  r.checkCollision(circle);  // check for collision
  r.display();               // and draw
}
</code></pre>

    <p>
        Pretty cool! Here's the full code:
    </p>

    Дуже круто! Ось повний код:

    <pre><code class="language-js code-block sm-txt">// a single Circle object, controlled by the mouse
Circle circle;

// a list of rectangles
Rectangle[] rects = new Rectangle[8];


void setup() {
  size(600,400);

  // create a new Circle with 30px radius
  circle = new Circle(0,0, 30);

  // generate rectangles in random locations
  // but snap to grid!
  for (int i=0; i&lt;rects.length; i++) {
    float x = int(random(50,width-50)/50) * 50;
    float y = int(random(50,height-50)/50) * 50;
    rects[i] = new Rectangle(x,y, 50,50);
  }
}


void draw() {
  background(255);

  // go through all rectangles...
  for (Rectangle r : rects) {
    r.checkCollision(circle);  // check for collision
    r.display();               // and draw
  }

  // update circle's position and draw
  circle.update();
  circle.display();
}


class Circle {
  float x, y;    // position
  float r;       // radius

  Circle (float _x, float _y, float _r) {
    x = _x;
    y = _y;
    r = _r;
  }

  // move into mouse position
  void update() {
    x = mouseX;
    y = mouseY;
  }

  // draw
  void display() {
    fill(0, 150);
    noStroke();
    ellipse(x,y, r*2, r*2);
  }
}


class Rectangle {
  float x, y;            // position
  float w, h;            // size
  boolean isHit = false;   // is it hit?

  Rectangle (float _x, float _y, float _w, float _h) {
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  }

  // check for collision with the circle using the
  // Circle/Rect function we made in the beginning
  void checkCollision(Circle c) {
    hit = isCircleWithRectCollides(c.x,c.y,c.r, x,y,w,h);
  }

  // малювання прямокутника
  // if hit, change the fill color
  void display() {
    if (hit) fill(255,150,0);
    else fill(0,150,255);
    noStroke();
    rect(x,y, w,h);
  }
}


// Круг і Прямокутник
boolean isCircleWithRectCollides(float cx, float cy, float radius, float rx, float ry, float rw, float rh) {

  // temporary variables to set edges for testing
  float testX = cx;
  float testY = cy;

  // which edge is closest?
  if (cx &lt; rx)         testX = rx;      // compare left edge
  else if (cx &gt; rx+rw) testX = rx+rw;   // right edge
  if (cy &lt; ry)         testY = ry;      // top edge
  else if (cy &gt; ry+rh) testY = ry+rh;   // bottom edge

  // get distance from closest edges
  float distX = cx-testX;
  float distY = cy-testY;
  float distance = sqrt( (distX*distX) + (distY*distY) );

  // if the distance is less than the radius, collision!
  if (distance &lt;= radius) {
    return true;
  }
  return false;
}
</code></pre>

    <p>
        Note that our code is a bit long with all the classes, so the actual Processing file is broken up into separate
        tabs. This would be a good idea for projects that require several collision functions. You could name the tab
        <em>CollisionFunctions</em> and keep all the code there.
    </p>

    Зверніть увагу, що наш код трохи довгий з усіма класами, тому фактичний файл обробки розбитий на окремі вкладки. Це було б хорошою ідеєю для проектів, які потребують кількох функцій зіткнення. Ви можете назвати вкладку CollisionFunctions і зберегти весь код там.

    <p>
        You can see another, more complex example of object-oriented collision in the <a class="inline-link" href="./index.html">Introduction</a>. It uses a class for circles, rectangles, and lines.
    </p>

    Ви можете побачити інший, більш складний приклад об’єктно-орієнтованої колізії у Вступі . Він використовує клас для кіл, прямокутників і ліній.

    <a href="./section-5-challenges.html"><p class="nextPage">Далі: Завдання 5</p></a>

    <footer>
        <p>
            [
            <a class="inline-link" href="./index.html">вступ</a>,
            <a href="https://github.com/jeffThompson/CollisionDetection" target="_blank">оригінальне джерело</a>
            ]
        </p>

        <p class="license">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">
                <img id="license" class="license" alt="Creative Commons License" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png">
            </a>
        </p>
    </footer>

    <script>hljs.highlightAll();</script>
</div>
</body>
</html>