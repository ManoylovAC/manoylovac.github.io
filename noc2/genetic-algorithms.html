<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta data-react-helmet="true" name="description" content="Подумайте хвилинку про простіші часи, коли ви писали свої перші програми на p5.js і життя було вільним та легким. Яку фундаментальну концепцію програм"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:url" content="https://natureofcode.com"/><meta data-react-helmet="true" property="og:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/><meta data-react-helmet="true" property="og:title" content="9. Еволюційне моделювання"/><meta data-react-helmet="true" property="og:description" content="Подумайте хвилинку про простіші часи, коли ви писали свої перші програми на p5.js і життя було вільним та легким. Яку фундаментальну концепцію програм"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="9. Еволюційне моделювання"/><meta data-react-helmet="true" name="twitter:description" content="Подумайте хвилинку про простіші часи, коли ви писали свої перші програми на p5.js і життя було вільним та легким. Яку фундаментальну концепцію програм"/><meta data-react-helmet="true" name="twitter:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/>

    <link rel="stylesheet" href="./assets/styles/global.css">

    <noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="./favicon-32x32.png" type="image/png"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title data-react-helmet="true">9. Еволюційне моделювання / Nature of Code</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="fixed left-0 right-0 top-0 z-40 bg-white px-6 lg:px-8"><div class="mx-auto flex h-[5em] max-w-6xl items-center justify-between"><div class="flex flex-col gap-x-6 lg:flex-row lg:items-center"><a href="./"><span class="text-lg font-black tracking-widest text-noc-400"><span class="font-black">ПРИРОДА</span> КОДУ</span></a><span class="hidden text-sm tracking-widest text-noc-400 xl:block">ДАНІЕЛЬ ШИФФМАН</span></div><button class="flex h-9 w-11 cursor-pointer flex-col items-center justify-between p-2 lg:hidden" aria-label="Toggle menu" title="Toggle menu"><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-opacity" style="opacity:1"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span></button><div class="hidden items-center gap-6 lg:flex"><ul class="flex items-center gap-6"><li><a href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M458.4 64.3C400.6 15.7 311.3 23 256 79.3 200.7 23 111.4 15.6 53.6 64.3-21.6 127.6-10.6 230.8 43 285.5l175.4 178.7c10 10.2 23.4 15.9 37.6 15.9 14.3 0 27.6-5.6 37.6-15.8L469 285.6c53.5-54.7 64.7-157.9-10.6-221.3zm-23.6 187.5L259.4 430.5c-2.4 2.4-4.4 2.4-6.8 0L77.2 251.8c-36.5-37.2-43.9-107.6 7.3-150.7 38.9-32.7 98.9-27.8 136.5 10.5l35 35.7 35-35.7c37.8-38.5 97.8-43.2 136.5-10.6 51.1 43.1 43.5 113.9 7.3 150.8z"></path></svg>SUPPORT</a></li><li><a href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>GITHUB</a></li><li><a href="https://thecodingtrain.com/" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./static/codingtrain_logo-53b0a841be45c7eac7a12f88b7bea596.png" alt="Coding Train&#x27;s logo" class="-ml-2 w-8"/>CODING TRAIN</a></li></ul><div class="not-prose flex items-center gap-4 undefined"><div class="relative"><a href="https://natureofcode.com/" target="_blank" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./favicon-32x32.png" alt="The Nature Of Code logo" class="noc2-logo"/>THE NATURE OF CODE</a></div></div></div></div></header>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YD31R75NSS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YD31R75NSS');
    </script>
    <nav class="fixed bottom-0 left-0 right-0 top-[5em] z-20 overflow-y-auto bg-white px-6 lg:hidden mb-menu hidden">
        <ul class="my-7 space-y-2">
            <li><a class="text-lg text-gray-800" href="./dedication.html">Присвята</a></li>
            <li><a class="text-lg text-gray-800" href="./acknowledgements.html">Подяки</a></li>
            <li><a class="text-lg text-gray-800" href="./introduction.html">Вступ</a></li>
            <li>
                <button class="sub-menu-btn flex items-center gap-2 text-lg text-gray-800">
                    <span>Розділи</span>
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 transition-transform" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="transform: scaleY(1);"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <ul class="space-y-2 py-2 pl-4 sub-menu hidden">
                    <li><a class="flex items-center text-gray-600" href="./random.html"><span class="w-8">0</span><span>Випадковість</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./vectors.html"><span class="w-8">1</span><span>Вектори</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./forces.html"><span class="w-8">2</span><span>Сили</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./oscillation.html"><span class="w-8">3</span><span>Коливання</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./particles.html"><span class="w-8">4</span><span>Система частинок</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./autonomous-agents.html"><span class="w-8">5</span><span>Автономні агенти</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./physics-libraries.html"><span class="w-8">6</span><span>Фізичні бібліотеки</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./cellular-automata.html"><span class="w-8">7</span><span>Клітинні автомати</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./fractals.html"><span class="w-8">8</span><span>Фрактали</span></a></li>
                    <li><a aria-current="page" class="flex items-center text-gray-600 font-bold" href="./genetic-algorithms.html"><span class="w-8">9</span><span>Еволюційне моделювання</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./neural-networks.html"><span class="w-8">10</span><span>Нейронні мережі</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./neuroevolution.html"><span class="w-8">11</span><span>Нейроеволюція</span></a></li>
                </ul>
            </li>
            <li><a class="text-lg text-gray-800" href="./appendix-creature.html">Додаток: Дизайн створінь</a></li>
            <li><a class="text-lg text-gray-800" href="./resources.html">Додаткові ресурси</a></li>
            <li><a class="text-lg text-gray-800" href="./credits.html">Credits</a></li>
            <li><a class="text-lg text-gray-800" href="./translation.html">Про переклад</a></li>
            <li><a class="text-lg text-gray-800" href="./examples.html">Приклади</a></li>
        </ul>
        <ul class="my-7 space-y-2">
            <li><a target="_blank" href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1 text-lg text-gray-800">Support<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
            <li><a target="_blank" href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1 text-lg text-gray-800">GitHub<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
            <li><a target="_blank" href="https://thecodingtrain.com/" class="flex items-center gap-1 text-lg text-gray-800">Coding Train<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>

            <li><a target="_blank" href="https://natureofcode.com/" class="flex items-center gap-1 text-lg text-gray-800">The Nature Of Code<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
        </ul>
    </nav>
    <div class="mt-[6em] px-6 lg:px-8"><div class="mx-auto max-w-6xl lg:flex lg:justify-between lg:gap-10 xl:gap-14"><aside class="sticky top-[6em] z-10 hidden max-h-[calc(100vh-6em)] min-w-[14em] overflow-y-auto pb-8 lg:block lg:flex-grow"><nav class="border-noc-200 rounded-3xl border"><ul class="divide-noc-200 divide-y"><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./dedication.html">Присвята</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./acknowledgements.html">Подяки</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./introduction.html">Вступ</a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./random.html"><span class="w-8">0</span><span class="group-hover:underline">Випадковість</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./vectors.html"><span class="w-8">1</span><span class="group-hover:underline">Вектори</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./forces.html"><span class="w-8">2</span><span class="group-hover:underline">Сили</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./oscillation.html"><span class="w-8">3</span><span class="group-hover:underline">Коливання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./particles.html"><span class="w-8">4</span><span class="group-hover:underline">Системи частинок</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./autonomous-agents.html"><span class="w-8">5</span><span class="group-hover:underline">Автономні агенти</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./physics-libraries.html"><span class="w-8">6</span><span class="group-hover:underline">Фізичні бібліотеки</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./cellular-automata.html"><span class="w-8">7</span><span class="group-hover:underline">Клітинні автомати</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./fractals.html"><span class="w-8">8</span><span class="group-hover:underline">Фрактали</span></a></li><li><a aria-current="page" class="group relative flex items-center px-3 py-2 text-sm font-bold" href="./genetic-algorithms.html"><span class="w-8">9</span><span class="group-hover:underline">Еволюційне моделювання</span></a><ul class="space-y-1 pb-2"><li><a href="#genetic-algorithms-inspired-by-actual-events" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Генетичні алгоритми: натхненні реальними подіями</a></li><li><a href="#why-use-genetic-algorithms" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Навіщо використовувати генетичні алгоритми?</a></li><li><a href="#how-genetic-algorithms-work" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Як працюють генетичні алгоритми</a></li><li><a href="#coding-the-genetic-algorithm" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Кодування генетичного алгоритму</a></li><li><a href="#customizing-genetic-algorithms" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Налаштування генетичних алгоритмів</a></li><li><a href="#evolving-forces-smart-rockets" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Еволюція сил: Розумні ракети</a></li><li><a href="#interactive-selection" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Інтерактивний відбір</a></li><li><a href="#ecosystem-simulation" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Моделювання екосистеми</a></li></ul></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neural-networks.html"><span class="w-8">10</span><span class="group-hover:underline">Нейронні мережі</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neuroevolution.html"><span class="w-8">11</span><span class="group-hover:underline">Нейроеволюція</span></a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./appendix-creature.html">Додаток: Дизайн створінь </a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./resources.html">Додаткові ресурси</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./credits.html">Credits</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./translation.html">Про переклад</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./examples.html">Приклади</a></li></ul></nav></aside><main class="prose mx-auto max-w-[50em] pb-8"><section data-type="chapter" id="section-genetic-algorithms">
<h1 id="chapter-9-evolutionary-computing">Розділ 9. Еволюційне моделювання</h1>
<div class="chapter-opening-quote">
  <blockquote data-type="epigraph">
    <p>Time flies like an arrow; fruit flies like a banana.</p>
    <p>(вислів є жарт івливою грою слів)</p>
    <div class="chapter-opening-quote-source">
      <p>— Автор невідомий</p>
    </div>
  </blockquote>
</div>
<div class="chapter-opening-figure">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1920px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1080&#x27; width=&#x27;1920&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#b8b8b8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4c2cc48dc55342a28305268644ff7acf/3a3a2/09_ga_1.webp 480w,./static/4c2cc48dc55342a28305268644ff7acf/bde8a/09_ga_1.webp 960w,./static/4c2cc48dc55342a28305268644ff7acf/c512e/09_ga_1.webp 1920w" sizes="(min-width: 1920px) 1920px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1920px) 1920px, 100vw" decoding="async" loading="lazy" data-src="./static/4c2cc48dc55342a28305268644ff7acf/a764f/09_ga_1.jpg" data-srcset="./static/4c2cc48dc55342a28305268644ff7acf/fb67e/09_ga_1.jpg 480w,./static/4c2cc48dc55342a28305268644ff7acf/3059d/09_ga_1.jpg 960w,./static/4c2cc48dc55342a28305268644ff7acf/a764f/09_ga_1.jpg 1920w" alt="Кераміка Пуебло (фото надано службою національних парків США)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4c2cc48dc55342a28305268644ff7acf/3a3a2/09_ga_1.webp 480w,./static/4c2cc48dc55342a28305268644ff7acf/bde8a/09_ga_1.webp 960w,./static/4c2cc48dc55342a28305268644ff7acf/c512e/09_ga_1.webp 1920w" sizes="(min-width: 1920px) 1920px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1920px) 1920px, 100vw" decoding="async" loading="lazy" src="./static/4c2cc48dc55342a28305268644ff7acf/a764f/09_ga_1.jpg" srcSet="./static/4c2cc48dc55342a28305268644ff7acf/fb67e/09_ga_1.jpg 480w,./static/4c2cc48dc55342a28305268644ff7acf/3059d/09_ga_1.jpg 960w,./static/4c2cc48dc55342a28305268644ff7acf/a764f/09_ga_1.jpg 1920w" alt="Кераміка Пуебло (фото надано службою національних парків США)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
  <span id="pueblo-pottery-photo-courtesy-of-the-national-park-service"><a class="heading-link" href="#pueblo-pottery-photo-courtesy-of-the-national-park-service">Кераміка Пуебло (фото надано службою національних парків США)</a></span>
  <p>Протягом століть кераміка, створена представниками предків культур Пуебло і Моголлон на південному заході Сполучених Штатів і Північної Мексики, мала велике значення як у церемоніальному, так і в повсякденному контексті. Техніки та елементи дизайну, подібні до тих, що використовувалися для створення цієї чаші Chaco Ancestral Pueblo, переда ються з покоління в покоління і кожен гончар вивчає, зберігає та тонко адаптує ці дизайни. Цей безперервний процес породжує гобелен родинного та культурного самовираження, що постійно розвивається.</p>
<hr/></div>
<p>Подумайте хвилинку про простіші часи, коли ви писали свої перші програми на p5.js і життя було вільним та легким. Яку фундаментальну концепцію програмування ви, ймовірно, використовували в тих перших програмах і продовжуєте використовувати знову і знову до цього дня? <em>Змінні</em>. Змінні дозволяють зберігати дані та повторно використовувати їх під час виконання програми.</p>
<p>Звичайно, в цьому немає нічого нового. У цій книзі ви вийшли далеко за межі програм лише з однією чи двома простими змінними, працюючи над програмами, організованими навколо складніших структур даних: власних об’єктів, які включають як дані, так і функції. Ви використовували ці складні структури даних — класи — для створення власних маленьких світів рухомих частинок, рухомих об’єктів, клітин і дерев. Але тут є заковика: у кожному прикладі в цій книзі вам доводилося турбуватися про ініціалізацію властивостей цих об’єктів. Можливо, ви створили цілий набір частинок із випадковими кольорами й розмірами або масив рухомих об’єктів, які починаються з однієї спільної позиції (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>, <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>).</p>
<p>Що, якби замість того, щоб діяти як розумний розробник, призначаючи властивості об’єктів шляхом випадкового чи вдумливого міркування, ви могли б дозволити природному процесу <strong>еволюції</strong> визначити значення замість вас? Чи можна представити змінні JavaScript об’єкта як ДНК об’єкта? Чи можуть об’єкти народжувати інші об’єкти та передавати свою ДНК новому поколінню? Чи може програма p5.js еволюціонувати?</p>
<p>Відповідь на всі ці запитання однозначно ствердна і пошук цієї відповіді є темою цього розділу. Зрештою, ця книга навряд чи була б повною без моделювання одного з найпотужніших алгоритмічних процесів у самій природі — біологічної еволюції. Цей розділ присвячено вивченню принципів еволюційних процесів і пошуку способів застосування цих принципів у коді.</p>
<h2 id="genetic-algorithms-inspired-by-actual-events"><a class="heading-link" href="#genetic-algorithms-inspired-by-actual-events">Генетичні алгоритми: натхненні реальними подіями</a></h2>
<p>Основним підходом розробки програм, що розвиваються, є <strong>генетичні алгоритми</strong> (скорочено <strong>ГА-ми</strong>), які базуються на основних принципах еволюційної теорії Дарвіна. У цих алгоритмах популяції потенційних вирішень проблеми розвиваються протягом поколінь через процеси, які імітують природний відбір у біологічній еволюції. Хоча комп’ютерне моделювання еволюційних процесів датується 1950-ми роками, більша частина нашого сучасного розуміння ГА-мів походить від роботи Джона Холланда, професора Мічиганського університету, чия книга 1975 року “<em>Адаптація в природних і штучних системах</em>” (MIT Press) поклала початок дослідженню ГА-мів. Сьогодні ГА-ми є частиною ширшої галузі, яку часто називають <strong>еволюційним моделюванням</strong>.</p>
<p>Щоб було зрозуміло, ГА-ми <em>натхненні</em> лише генетикою та еволюційною теорією і не призначені для точного впровадження науки, що стоїть за цими сферами. Досліджуючи ГА-ми у цьому розділі, я не буду будувати квадрати Паннетта (вибачте за розчарування) і не буду обговорювати нуклеотиди, синтез білка, РНК чи інші теми, пов’язані з біологічними процесами еволюції. Я не так дбаю про створення науково точного моделювання еволюції, як це відбувається у фізичному світі, радше мене цікавлять методи застосування еволюційних стратегій у програмному забезпеченні.</p>
<p>Це не означає, що проєкт з більшою науковою глибиною не матиме цінності. Насправді ціла галузь із досліджень обчислювальної біології бере на себе завдання більш точного моделювання біологічних еволюційних процесів! Я закликаю читачів, які особливо цікавляться цією темою, досліджувати можливості розширення наданих прикладів додатковими еволюційними функціональностями. Проте, щоб проєкти залишалися керованими, я буду дотримуватися основ. І як це сталося, основи будуть доси ть складними та захопливими.</p>
<p>Я також маю зауважити, що, строго кажучи, термін <em>генетичний алгоритм</em> стосується конкретного алгоритму, реалізованого певним чином для розв’язання конкретних питань і не всі ці особливості важливі для цієї книги. Хоча формально ГА слугуватиме основою для прикладів у цій главі, я не буду галасувати щодо реалізації алгоритму з ідеальною точністю, враховуючи, що я шукаю саме творчих застосувань еволюційної теорії в коді. Таким чином, цей розділ буде розбито на наступні три частини:</p>
<ul>
  <li><strong>Традиційний генетичний алгоритм:</strong> я почну з традиційного, хрестоматійного ГА. Цей алгоритм було розроблено для розв’язання проблем з інформатики, для яких простір вирішення настільки великий, що алгоритм <em>грубої сили (brute-force)</em> займе надто багато часу. Ось приклад: я загадав число від одного до одного мільярда. Скільки часу знадобиться, щоб вгадати? З підходом грубої сили вам доведеться перевіряти кожне можливе рішення. Це один? Це два? Це три? Чи чотири?... Удача тут відіграє важливу роль (можливо, я випадково вибрав п’ять!), але в середньому ви б витратили роки, відраховуючи  від одиниці, перш ніж вибрати правильну відповідь. Але що, якби я міг сказати вам, чи була ваша здогадка хорошою, чи поганою? Тепло чи холодно? Дуже тепло? Гаряче? Крижаний холод? Якби ви могли оцінити, наскільки близькі (або <em>відповідні</em>) ваші припущення, то могли б почати обирати числа відповідним чином і швидше прийти до відповіді. Ваша відповідь буде <em>еволюціонувати</em>.</li>
  <li><strong>Інтерактивний вибір:</strong> після ознайомлення з традиційною версією я розгляну інші застосування ГА у візуальному мистецтві. <em>Інтерактивний вибір</em> належить до процесу розвитку чого-небудь (часто до створеного комп’ютером зображення) за допомогою взаємодії користувача. Припустимо, ви заходите в музейну галерею і бачите 10 картин. За допомогою інтерактивного вибору ви можете вибрати свої улюблені та дозволити алгоритмічному процесу створити (або <em>розвинути</em>) нові картини на основі ваших уподобань.</li>
  <li><strong>Моделювання екосистеми:</strong> традиційна комп’ютерна наука ГА-мів та інтерактивна техніка вибору — це те, що ви, швидше за все, знайдете, якщо шукатимете в інтернеті чи читатимете підручник про штучний інтелект.  Але, як ви скоро побачите, вони насправді не імітують процес еволюції, як це відбувається у фізичному світі. У цьому розділі я також досліджуватиму методи моделювання еволюції в екосистемі штучних створінь. Як об’єкти, що рухаються по полотну, можуть зустрітися один з одним, спаровуватися та передавати свої гени новому поколінню? Це може стосуватися безпосередньо проєкту екосистеми, описаного в кінці кожного розділу. Це також буде особливо актуально, коли я досліджуватиму нейроеволюцію у <a href="/neuroevolution#section-neuroevolution">Розділі 11</a>.</li>
</ul>
<h2 id="why-use-genetic-algorithms"><a class="heading-link" href="#why-use-genetic-algorithms">Навіщо використовувати генетичні алгоритми?</a></h2>
<p>Щоб допомогти проілюструвати корисність традиційного ГА, я збираюся почати з котів. Але не просто з повсякденних котів. Я збираюся розпочати з кількох котів-муркотунів, які володіють талантом друкування, з метою створити повне зібрання творів Шекспіра (малюнок 9.1).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1515&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/e57d91380b9c220b32ec8b8bdc0aca6d/70364/09_ga_2.webp 576w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/ceaa7/09_ga_2.webp 1152w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/57bd6/09_ga_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/e57d91380b9c220b32ec8b8bdc0aca6d/8de0e/09_ga_2.png" data-srcset="./static/e57d91380b9c220b32ec8b8bdc0aca6d/f1adc/09_ga_2.png 576w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/dcd2a/09_ga_2.png 1152w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/8de0e/09_ga_2.png 2304w" alt="Малюнок 9.1: Нескінченні коти, які друкують на нескінченних клавіатурах"/></picture><noscript><picture><source type="image/webp" srcSet="./static/e57d91380b9c220b32ec8b8bdc0aca6d/70364/09_ga_2.webp 576w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/ceaa7/09_ga_2.webp 1152w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/57bd6/09_ga_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/e57d91380b9c220b32ec8b8bdc0aca6d/8de0e/09_ga_2.png" srcSet="./static/e57d91380b9c220b32ec8b8bdc0aca6d/f1adc/09_ga_2.png 576w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/dcd2a/09_ga_2.png 1152w,./static/e57d91380b9c220b32ec8b8bdc0aca6d/8de0e/09_ga_2.png 2304w" alt="Малюнок 9.1: Нескінченні коти, які друкують на нескінченних клавіатурах"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.1: Нескінченні коти, які друкують на нескінченних клавіатурах</figcaption>
</figure>
<p>Це мій нявкяючий твіст до <strong>теореми про нескінченну мавпу</strong>, яка сформульована наступним чином: мавпа, яка має нескінченну кількість часу і буде випадково натискати клавіші на друкарській машинці, зрештою надрукує повний текст творів Шекспіра. Це лише теорія, оскільки на практиці кількість можливих комбінацій літер і слів робить ймовірність того, що мавпа <em>справді</em> надрукує Шекспіра, мізерною. Якщо говорити про це в перспективі, то навіть якби мавпа почала друкувати на початку Всесвіту, ймовірність того, що до цього часу вона створила, хоча б <em>Гамлета</em>, не кажучи вже про <em>цілі твори</em> Шекспіра, все одно є абсурдно малоймовірною.</p>
<p>Розглянемо кота, на ім’я Клавдіус. Клавдіус друкує на зменшеній друкар ській машинці, яка містить лише 27 символів: 26 англійських літер плюс пробіл. Імовірність того, що Клавдіус натисне будь-яку клавішу, становить 1 до 27.</p>
<p>Далі розглянемо класичну фразу “to be or not to be that is the question” (для простоти я ігнорую великі літери й пунктуацію). Фраза містить 39 символів, включаючи пробіли. Якщо Клавдіус почне друкувати, шанс, що він правильно введе перший символ, становить 1 до 27. Оскільки ймовірність того, що він правильно введе другий символ, також дорівнює одній двадцять сьомій, то його шанс надрукувати перші дві літери поспіль у правильному порядку складає 1 до 729 (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>27</mn><mo>×</mo><mn>27</mn></mrow><annotation encoding="application/x-tex">27 \times 27</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">27</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">27</span></span></span></span></span>). (Це безпосередньо випливає з нашого обговорення ймовірності у <a href="/random#section-random">Розділі 0</a>.) Тому ймовірність того, що Клавдіус набере повну фразу, дорівнює <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>27</mn></mrow><annotation encoding="application/x-tex">1 / 27</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1/27</span></span></span></span></span> помноженій на саму себе 39 разів, або <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>27</mn><msup><mo stretchy="false">)</mo><mn>39</mn></msup></mrow><annotation encoding="application/x-tex">(1/27)^{39}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1/27</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">39</span></span></span></span></span></span></span></span></span></span></span></span></span>. Це дорівнює ймовірності...</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mtext> до 66 555 937 033 867 822 607 895 549 241 096 482 953 017 615 834 735 226 163</mtext></mrow><annotation encoding="application/x-tex">1 \text{ до } \text{66 555 937 033 867 822 607 895 549 241 096 482 953 017 615 834 735 226 163}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em"></span><span class="mord">1</span><span class="mord text"><span class="mord"> </span><span class="mord cyrillic_fallback">до</span><span class="mord"> </span></span><span class="mord text"><span class="mord">66 555 937 033 867 822 607 895 549 241 096 482 953 017 615 834 735 226 163</span></span></span></span></span></span></div>
<p>Зайве говорити, що навіть влучити лише в одну фразу, не кажучи вже про цілу п’єсу, не кажучи вже про всі 38 п’єс Шекспіра малоймовірно. Навіть якби Клавдіус був комп’ютерною симуляцією і міг вводити мільйон випадкових фраз за секунду, щоб Клавдіус мав 99-відсоткову ймовірність врешті-решт правильно вказати лише одну фразу, йому довелося б друкувати 9 719 096 182 010 563 073 125 591 133 903 305 625 605 017 років. Для порівняння, вік Всесвіту становить лише 13 750 000 000 років.</p>
<p>Мета всіх цих незбагненно великих чисел полягає не в тому, щоб викликати у вас головний біль, а в тому, щоб продемонструвати, що алгоритм грубої сили (введення всіх можливих випадкових фраз) не є розумною стратегією для випадкового досягнення фрази “to be or not to be that is the question”. Вихід у генетичних алгоритмах, які починаються з випадкових фраз і швидко знаходять рішення через еволюційні симуляції, залишаючи Клавдіусу багато часу, щоб насолодитися затишним дріманням.</p>
<p>Чесно кажучи, ця конкретна проблема (прийти до фрази “to be or not to be that is the question”) є сміховинною. Оскільки ви вже знаєте відповідь, все що вам потрібно зробити, це ввести її. Ось програма p5.js, яка вирішує проблему:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;to be or not to be that is the question&quot;</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Проте, це приголомшлива проблема для початку, оскільки відома відповідь дозволить вам легко перевірити код і оцінити успішність ГА. Після того, як ви успішно розв’яжете проблему, ви можете почуватися більш впевнено, використовуючи ГА, щоб робити щось справді корисне: розв’язувати проблеми з <em>невідомими</em> відповідями. Цей перший приклад не має ніякої реальної мети, окрім демонстрації того, як працюють ГА-ми. Якщо ви порівнюєте результати ГА з відомою відповіддю та отримуєте “to be or not to be”, значить ви досягли успіху в написанні ГА.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-91"><a class="heading-link" href="#exercise-91">Вправа 9.1</a></h3>
  <p>Створіть програму, яка генерує випадкові рядки. Вам потрібно буде знати, як це зробити, щоб реалізувати приклад ГА, який незабаром послідує. Скільки часу потрібно, щоб p5.js випадково згенерував рядок <code>cat</code>? Як ви можете адаптувати це для генерації випадкових зображень за допомогою функцій малювання фігур у p5.js?</p>
</div>
<h2 id="how-genetic-algorithms-work"><a class="heading-link" href="#how-genetic-algorithms-work">Як працюють генетичні алгоритми</a></h2>
<p>Перш ніж перейти до будь-якого коду, я хотів би пройти через етапи класичного ГА в більш загальному вигляді. Я проілюструю, як популяція <em>створінь</em> (загальний термін для елементів симуляції) може розвиватися протягом ряду поколінь. Щоб зрозуміти, як це працює, важливо окреслити три основні принципи дарвінівської еволюції. Якщо природний відбір має відбуватися у коді, як це відбувається в природі, всі ці три елементи повинні бути присутніми:</p>
<ul>
  <li><strong>Спадковість:</strong> повинен існувати механізм, який дозволяє <em>батьківським</em> с творінням в одному поколінні передавати свої риси до <em>дочірніх</em> створінь (нащадків) у наступне покоління.</li>
  <li><strong>Мінливість:</strong> для того, щоб відбулася еволюція, у популяції істот має бути присутня різноманітність рис або спосіб для введення варіацій. Уявіть популяцію абсолютно однакових жуків, спільного кольору, розміру, розмаху крил і всього іншого. Без будь-якої різноманітності у популяції діти завжди були б ідентичними батькам і один одному. Нові комбінації ознак не змогли б ніколи виникнути й ніщо не еволюціонувало.</li>
  <li>
    <strong>Відбір:</strong> повинен існувати механізм, за допомогою якого деякі створіння мають можливість бути батьками та передавати свою генетичну інформацію, а інші ні. Це зазвичай називають <em>виживанням найпристосованіших</em>. Візьмемо, наприклад, популяцію газелей, яких переслідують леви. Швидші газелі мають більше шансів на втечу від левів, збільшуючи тим самим свої шанси на довше життя, можливість розмножуватися та передавати свою генетичну інформацію нащадкам.
    Однак термін <em>найпристосованіший</em> може ввести в оману. Часто вважають, що воно означає найбільший, найшвидший або найсильніший і хоча іноді це дійсно охоплює такі фізичні атрибути, як розмір, швидкість або сила, це не є обов’язковим. Суть природного відбору полягає в тих рисах, які найкраще відповідають навколишньому середовищу організму і збільшують його ймовірність виживання та, зрештою, розмноження. Замість того, щоб визначати переваги <em>найпристосованіших</em> простіше сприймати їх як “здатних до відтворення”. Візьмемо, наприклад, <em>Dolania americana</em> (також відому як американська поденкова муха), яка, як вважають, має найкоротший термін життя з усіх комах. Доросла самка живе всього п&#x27;ять хвилин, але якщо вона встигне відкласти яйця у воду, то передасть свою генетичну інформацію наступному поколінню. Для котів, які друкують, більш <em>пристосованим</em> котом, якого я вважатиму ймовірнішим для відтворення, буде той, який надрукує більше символів, присутніх у потрібній фразі Шекспіра.
  </li>
</ul>
<p>Я хочу підкреслити контекст у якому я застосовую ці дарвінівські концепції: змодельоване, штучне середовище, де конкретні цілі можна визначити кількісно і все це заради творчих цілей.</p>
<p>З’ясувавши ці концепції, я розпочну розповідь про ГА. Я зроблю це в контексті котів, що друкують. Алгоритм буде розділений на кілька кроків, які складаються з двох частин: набору умов для ініціалізації й кроків, які повторюються знову й знову, доки не буде знайдено правильну фразу.</p>
<h3 id="step-1-population-creation"><a class="heading-link" href="#step-1-population-creation">Крок 1: Створення популяції</a></h3>
<p>Для котів, що друкують, першим кроком ГА є створення популяції фраз. Я використовую термін <em>фраза</em> досить вільно для позначення будь-якого рядка символів. Ці фрази є створіннями цього прикладу, хоча, звичайно, вони не дуже схожі на істоти.</p>
<p>У створенні популяції фраз застосовується дарвінівський принцип <strong>мінливості (різноманітності)</strong>. Вважатимемо, для простоти, що я намагаюся розвинути фразу <em>“cat”</em> і маю популяцію з трьох фраз:</p>
<table><tbody><tr><td>rid</td></tr><tr><td>won</td></tr><tr><td>hug</td></tr></tbody></table>
<p>Звісно, ці фрази різноманітні, але спробуйте змішувати й поєднувати їх символи у будь-який спосіб, але ви ніколи не отримаєте фразу <em>“cat”</em>. Тут <em>недостатньо</em> різноманітності, щоб розвинути потрібний результат. Однак, якщо у мене буде популяція з тисячі фраз, згенерованих випадковим чином, існуватиме ймовірність, що принаймні одна фраза матиме першим символом літеру <em>“c”</em>, якась інша матиме другим символом літеру <em>“a”</em> і ще якась матиме літеру <em>“t”</em> третім символом. Велика популяція, швидше за все, забезпечить достатню різноманітність для створення бажаної фрази. (У 3-му кроці алгоритму я також продемонструю інший механізм для введення більшої кількості варіацій у випадку, якщо спочатку їх недостатньо.) Отже, крок 1 можна описати таким чином:</p>
<p><span class="callout highlight">Створіть популяцію випадково згенерованих елементів.</span></p>
<p><em>Елемент</em>, мабуть, кращий, більш загальний термін, ніж <em>створіння</em>. Але що таке елемент? Під час перегляду прикладів у цьому розділі ви побачите кілька сценаріїв: у вас може бути популяція зображень або популяція рухомих об’єктів, як у <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a>. Новим у цьому розділі є те, що кожен елемент, кожен член популяції має <em>віртуальну ДНК</em>, набір властивостей (ви також можете назвати їх <em>генами</em>), які описують, як виглядає або поводиться певний елемент. Для котів, які друкують, наприклад, ДНК може бути рядком символів. Маючи це на увазі, я можу бути ще більш конкретним і описати перший крок ГА таким чином:</p>
<p><span class="callout highlight">Створіть популяцію з <em>N</em> елементів, кожен із випадково згенерованою ДНК.</span></p>
<p>Галузь генетики робить важливу різницю між поняттями генотипу та фенотипу. Справжній генетичний код — конкретна послідовність молекул у ДНК — це <strong>генотип</strong> організму. Це те, що передається з покоління у покоління. <strong>Фенотип</strong>, навпаки, є <em>вираженням</em> цих даних: цей кіт буде великим, той кіт буде маленьким, а отой інший кіт буде особливо швидким та ефективним друкарем.</p>
<p>Розрізнення генотипу і фенотипу є ключовим для творчого використання ГА. Які предмети є у вашому світі? Як ви розробите генотип для цих об’єктів — структуру даних для зберігання властивостей кожного об’єкта та значення, які набувають ці властивості? І як ви будете використовувати цю інформацію для розробки фенотипу? Тобто, що <em>ви</em> хочете, щоб ці змінні насправді виражали?</p>
<p>Ми постійно робимо це в графічному програмуванні, приймаючи значення (генотип) та інтерпретуючи їх у візуальний спосіб (фенотип). Найпростіший приклад, мабуть, колір:</p>
<table><thead><tr><th style="width:100px">Генотип</th><th>Фенотип</th></tr></thead><tbody><tr><td>0</td><td>
        <div style="display:inline-block;vertical-align:sub;height:18px;width:18px;background-color:#000000;border:1px solid black"></div>
      </td></tr><tr><td>127</td><td>
        <div style="display:inline-block;vertical-align:sub;height:18px;width:18px;background-color:#7F7F7F;border:1px solid black"></div>
      </td></tr><tr><td>255</td><td>
        <div style="display:inline-block;vertical-align:sub;height:18px;width:18px;background-color:#FFFFFF;border:1px solid black"></div>
      </td></tr></tbody></table>
<p>Подумайте про генотип як про цифрову інформацію, дані, які представляють колір — у випадку значень у градаціях сірого це ціле число від 0 до 255. Спосіб вираження даних є довільним: червоне значення, зелене значення і синє значення. Зовсім не обов’язково бути кольором — за іншого підходу ви можете використовувати ті самі значення для опису довжини лінії, ваги сили тощо:</p>
<table><thead><tr><th style="width:100px">Той самий генотип</th><th>Різний фенотип (довжина лінії)</th></tr></thead><tbody><tr><td>0</td><td></td></tr><tr><td>127</td><td>
        <div style="display:inline-block;vertical-align:sub;width:127px;height:1px;background-color:#000000"></div>
      </td></tr><tr><td>255</td><td>
        <div style="display:inline-block;vertical-align:sub;width:255px;height:1px;background-color:#000000"></div>
      </td></tr></tbody></table>
<p>Хороший аспект прикладу з котячим друкуванням полягає в тому, що немає різниці між гено типом і фенотипом. Дані ДНК — це рядок символів і вираження цих даних — це той самий рядок.</p>
<h3 id="step-2-selection"><a class="heading-link" href="#step-2-selection">Крок 2: Відбір</a></h3>
<p>Другим кроком ГА є застосування дарвінівського принципу <strong>відбору</strong>. Він включає у себе оцінку популяції та визначення членів, придатних для вибору в якості батьків для наступного покоління. Процес відбору можна розділити на два етапи:</p>
<ol>
  <li><strong>Оцінка пристосованості</strong></li>
  <li><strong>Створення шлюбного пулу</strong></li>
</ol>
<p>Для першого з цих кроків мені потрібно буде розробити <strong>функцію пристосованості (придатності)</strong> — функцію, яка розраховуватиме числову оцінку для опису придатності певного елемента популяції. Звісно, це зовсім не так, як працює реальний світ. Істоти не оцінюються, скоріше, вони просто дають потомство або не дають. Однак традиційний ГА спрямований на розробку оптимального розв&#x27;язання проблеми, тому потрібен механізм чисельної оцінки будь-якого отриманого можливого рішення.</p>
<p>Розглянемо поточний сценарій з котами-друкарями. Знову ж таки, для простоти, я скажу, що цільова фраза це <em>“cat”</em>. Припустімо, що популяція складається з трьох елементів: <em>“hut”</em>, <em>“car”</em> і <em>“box”</em>. Слово <em>“car”</em>, очевидно, найпідхожіше, враховуючи, що воно має два правильні символи у правильних позиціях, слово <em>“hut”</em> — лише один, а <em>“box”</em> — нуль. І ось вона, оцінювальна функція:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>пристосованість</mtext><mo>=</mo><mtext>кількість правильних символів</mtext></mrow><annotation encoding="application/x-tex">\text{пристосованість} = \text{кількість правильних символів}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">пристосованість</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">кількість</span><span class="mord"> </span><span class="mord cyrillic_fallback">правильних</span><span class="mord"> </span><span class="mord cyrillic_fallback">символів</span></span></span></span></span></span></div>
<table><thead><tr><th style="width:100px">ДНК</th><th>Пристосованість</th></tr></thead><tbody><tr><td>car</td><td>2</td></tr><tr><td>hut</td><td>1</td></tr><tr><td>box</td><td>0</td></tr></tbody></table>
<p>Згодом я розгляну  приклади зі складнішими оцінковими функціями, але це хороший початок.</p>
<p>Після того, як оцінка пристосованості буде розрахована для всіх членів популяції, наступною частиною процесу відбору є вибір членів, які підходять для батьківства, і поміщення їх у шлюбний пул. Цей крок має кілька варіантів. Наприклад, я міг би використати <strong>елітарний</strong> підхід і сказати: “Які два члени популяції отримали найвищий бал? От вони двоє і створять всіх дітей для наступного покоління”. Ймовірно, це один із найпростіших способів для програмування, але він суперечить принципу варіації. Якщо два члени популяції (із, можливо, кількатисячної) є єдиними, хто може розмножуватися, наступне покоління матиме малу варіативність і це може загальмувати еволюційний процес.</p>
<p>Натомість я міг би створити шлюбну групу з більшої кількості елементів, наприклад, 50 відсотків кращої частини популяції. Це ще один простий спосіб для кодування, але він також не дасть оптимальних результатів. У цьому випадку елементи з найвищою оцінкою матимуть такий самий шанс бути вибраними, як і ті, що розташовані ближче до середини. Чому фраза у популяції з 1000 фраз, яка займає 500 місце, повинна мати такий самий шанс для відтворення, як і фраза, яка займає 1 місце? Якщо на те пішло, чому фраза під номером 500 повинна мати гарантовану можливість відтворення, тоді як фраза 501 не матиме жодної?</p>
<p>Кращим рішенням для парного пулу є використання <strong>ймовірнісного</strong> методу, який я назву <em>колесом фортуни</em> (також його називають <em>колесом рулетки</em>). Щоб проілюструвати цей метод, припустімо, що популяція складається з п’яти елементів, кожен з яких має певний показник пристосованості:</p>
<table><thead><tr><th style="width:100px">Елемент</th><th>Пристосованість</th></tr></thead><tbody><tr><td>A</td><td>3</td></tr><tr><td>B</td><td>4</td></tr><tr><td>C</td><td>0.5</td></tr><tr><td>D</td><td>1</td></tr><tr><td>E</td><td>1.5</td></tr></tbody></table>
<p>Перший крок — <strong>нормалізація</strong> всіх оцінок. Пам’ятаєте нормалізацію вектора? Це була стандартизація його довжини, після чого вона дорівнювала 1. Нормалізація набору показників пристосованості стандартизує їх діапазон від 0 до 1, як відсоток від загальної пристосованості. Для цього спершу складіть усі оцінки пристосованості:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>загальна пристосованість</mtext><mo>=</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>0.5</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1.5</mn><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\text{загальна пристосованість} = 3 + 4 + 0.5 + 1 + 1.5 = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">загальна</span><span class="mord"> </span><span class="mord cyrillic_fallback">пристосованість</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1.5</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">10</span></span></span></span></span></div>
<p>Далі розділіть кожну оцінку на загальну пристосованість і у результаті отримаєте значення нормалізованої пристосованості:</p>
<table><thead><tr><th style="width:100px">Елемент</th><th>Пристосованість</th><th>Нормалізована пристосованість</th><th>Вираження у відсотках</th></tr></thead><tbody><tr><td>A</td><td>3</td><td>0.3</td><td>30%</td></tr><tr><td>B</td><td>4</td><td>0.4</td><td>40%</td></tr><tr><td>C</td><td>0.5</td><td>0.05</td><td>5%</td></tr><tr><td>D</td><td>1</td><td>0.1</td><td>10%</td></tr><tr><td>E</td><td>1.5</td><td>0.1</td><td>15%</td></tr></tbody></table>
<p>Тепер настав час для колеса фортуни, зображеного на малюнку 9.2.</p>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;931.9999999999999&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/63ff623f94728dbcad66e67df95c5e4c/0fe3a/09_ga_3.webp 288w,./static/63ff623f94728dbcad66e67df95c5e4c/15c07/09_ga_3.webp 576w,./static/63ff623f94728dbcad66e67df95c5e4c/d784c/09_ga_3.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/63ff623f94728dbcad66e67df95c5e4c/d0693/09_ga_3.png" data-srcset="./static/63ff623f94728dbcad66e67df95c5e4c/85e3f/09_ga_3.png 288w,./static/63ff623f94728dbcad66e67df95c5e4c/1274e/09_ga_3.png 576w,./static/63ff623f94728dbcad66e67df95c5e4c/d0693/09_ga_3.png 1152w" alt="Малюнок 9.2: У цьому колесі фортуни кожен сегмент має розмір відповідно до оцінки пристосованості"/></picture><noscript><picture><source type="image/webp" srcSet="./static/63ff623f94728dbcad66e67df95c5e4c/0fe3a/09_ga_3.webp 288w,./static/63ff623f94728dbcad66e67df95c5e4c/15c07/09_ga_3.webp 576w,./static/63ff623f94728dbcad66e67df95c5e4c/d784c/09_ga_3.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/63ff623f94728dbcad66e67df95c5e4c/d0693/09_ga_3.png" srcSet="./static/63ff623f94728dbcad66e67df95c5e4c/85e3f/09_ga_3.png 288w,./static/63ff623f94728dbcad66e67df95c5e4c/1274e/09_ga_3.png 576w,./static/63ff623f94728dbcad66e67df95c5e4c/d0693/09_ga_3.png 1152w" alt="Малюнок 9.2: У цьому колесі фортуни кожен сегмент має розмір відповідно до оцінки пристосованості"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 9.2: У цьому колесі фортуни кожен сегмент має розмір відповідно до оцінки пристосованості</figcaption>
  </figure>
</div>
<p>Покрутіть колесо і ви помітите, що найвищий шанс бути обраним має елемент <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span>, за ним йде <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span>, потім <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span></span></span></span></span>, потім <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span></span> і нарешті <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span>. Цей вибір на основі ймовірності відповідно до пристосованості є чудовим підходом. Це гарантує, що елементи з найвищими оцінками матимуть найімовірнішу можливість відтворення, а також це не усуває повністю будь-які інші варіації популяції. На відміну від елітарного підходу, навіть елемент з найнижчими балами (у цьому випадку <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span>) має принаймні якийсь шанс передати с вою інформацію наступному поколінню. Це важливо, тому що цілком можливо (і часто так буває), що деякі елементи з низькими балами мають крихітні частинки генетичного коду, які є справді корисними і їх не слід вилучати з популяції. Наприклад, у випадку розвитку фрази “to be or not to be”, ми можемо мати наступні елементи:</p>
<table><thead><tr><th style="width:100px">Елемент</th><th>ДНК</th></tr></thead><tbody><tr><td>A</td><td>to be or not to go</td></tr><tr><td>B</td><td>to be or not to pi</td></tr><tr><td>C</td><td>purrrrrrrrrrrrr be</td></tr></tbody></table>
<p>Як бачите, елементи <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span> явно найкраще підходять й матимуть найвищу оцінку. Але жодна з них не містить правильних символів для закінчення фрази. Елемент <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span>, навіть якщо він отримав би дуже низький бал, випадково має генетичні дані для кінця фрази. Хоча я міг би хотіти, щоб <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span> були обрані для створення більшості наступного покоління, я також хочу, щоб <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span></span> теж мав невеликий шанс для участі у процесі відтворення.</p>
<h3 id="step-3-reproduction"><a class="heading-link" href="#step-3-reproduction">Крок 3: Відтворення</a></h3>
<p>Тепер, коли я продемонстрував стратегію відбору батьківських елементів, останнім кроком є застосування <strong>відтворення</strong> для створення наступного покоління популяції, з урахуванням дарвінівського принципу спадковості, де діти успадковують властивості своїх батьків. Знову ж таки, тут можна застосувати численні підходи. Наприклад, однією розумною (і легкою для програмування) стратегією є <strong>клонування</strong>, коли береться лише один батьківський елемент і створюється точна його копія для формування дочірнього елементу. Однак, як і у випадку з елітарним підходом до відбору, це суперечить меті варіації. Натомість стандартний підхід до ГА полягає у виборі двох батьків і створенні дочірнього елемента відповідно до двох кроків таких як:</p>
<ol>
  <li><strong>Схрещування</strong></li>
  <li><strong>Мутація</strong></li>
</ol>
<p>Перший крок <strong>схрещування</strong> створює дитину з генетичного коду двох батьків. Для прикладу з котами-друкарями, після кроку відбору, я вибрав наступні дві батьківські фрази з пулу для спаровування (тут я використовую інші й трохи коротші рядки довжиною у 6 символів, замість необхідних рядків для фрази “to be or not to be”):</p>
<table><tbody><tr><td>Батьківський елемент A</td><td>coding</td></tr><tr><td>Батьківський елемент B</td><td>nature</td></tr></tbody></table>
<p>Зараз постає завдання створити дочірню фразу з двох обраних. Можливо, найочевиднішим способом (назвемо його <em>методом 50/50</em>) було б взяти перші три символи з елементу <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span>, а інші три з елементу <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span>, як показано на малюнку 9.3.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;841&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/dd5411d51d5103e54549e096ca551779/569d4/09_ga_4.webp 576w,./static/dd5411d51d5103e54549e096ca551779/ca126/09_ga_4.webp 1152w,./static/dd5411d51d5103e54549e096ca551779/517d5/09_ga_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/dd5411d51d5103e54549e096ca551779/9b24a/09_ga_4.png" data-srcset="./static/dd5411d51d5103e54549e096ca551779/2dc45/09_ga_4.png 576w,./static/dd5411d51d5103e54549e096ca551779/ef8a2/09_ga_4.png 1152w,./static/dd5411d51d5103e54549e096ca551779/9b24a/09_ga_4.png 2304w" alt="Figure 9.3: A 50/50 crossover"/></picture><noscript><picture><source type="image/webp" srcSet="./static/dd5411d51d5103e54549e096ca551779/569d4/09_ga_4.webp 576w,./static/dd5411d51d5103e54549e096ca551779/ca126/09_ga_4.webp 1152w,./static/dd5411d51d5103e54549e096ca551779/517d5/09_ga_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/dd5411d51d5103e54549e096ca551779/9b24a/09_ga_4.png" srcSet="./static/dd5411d51d5103e54549e096ca551779/2dc45/09_ga_4.png 576w,./static/dd5411d51d5103e54549e096ca551779/ef8a2/09_ga_4.png 1152w,./static/dd5411d51d5103e54549e096ca551779/9b24a/09_ga_4.png 2304w" alt="Figure 9.3: A 50/50 crossover"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.3: Схрещування 50/50</figcaption>
</figure>
<p>Різновидом цього підходу є вибір випадкової середньої точки. Іншими словами, мені не завжди потрібно вибирати рівно половину символів від кожного із батьків. Я міг би використати комбінацію 1 і 5 або 2 і 4. Це краще, ніж підхід 50/50, оскільки він збільшує різноманітність можливостей для наступного покоління (див. малюнок 9.4).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;604&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/669aca10d51029514b9f40b5b6a6fcce/0e1b6/09_ga_5.webp 576w,./static/669aca10d51029514b9f40b5b6a6fcce/b60e9/09_ga_5.webp 1152w,./static/669aca10d51029514b9f40b5b6a6fcce/38be6/09_ga_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/669aca10d51029514b9f40b5b6a6fcce/97167/09_ga_5.png" data-srcset="./static/669aca10d51029514b9f40b5b6a6fcce/048cb/09_ga_5.png 576w,./static/669aca10d51029514b9f40b5b6a6fcce/18f59/09_ga_5.png 1152w,./static/669aca10d51029514b9f40b5b6a6fcce/97167/09_ga_5.png 2304w" alt="Малюнок 9.4: Два приклади схрещування з випадковою середньою точкою"/></picture><noscript><picture><source type="image/webp" srcSet="./static/669aca10d51029514b9f40b5b6a6fcce/0e1b6/09_ga_5.webp 576w,./static/669aca10d51029514b9f40b5b6a6fcce/b60e9/09_ga_5.webp 1152w,./static/669aca10d51029514b9f40b5b6a6fcce/38be6/09_ga_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/669aca10d51029514b9f40b5b6a6fcce/97167/09_ga_5.png" srcSet="./static/669aca10d51029514b9f40b5b6a6fcce/048cb/09_ga_5.png 576w,./static/669aca10d51029514b9f40b5b6a6fcce/18f59/09_ga_5.png 1152w,./static/669aca10d51029514b9f40b5b6a6fcce/97167/09_ga_5.png 2304w" alt="Малюнок 9.4: Два приклади схрещування з випадковою середньою точкою"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.4: Два приклади схрещування з випадковою середньою точкою</figcaption>
</figure>
<p>Інша можливість полягає у випадковому виборі батьківського символу для кожного символу в дочірньому рядку, як показано на малюнку 9.5. Ви можете подумати про це як про підкидання монети шість разів: коли випадає решка ми беремо літеру з батьківського елементу <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span>, орел — беремо літеру з елементу <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span>. Це дає ще більше можливих результатів: <em>“codurg”</em>, <em>“natine”</em>, <em>“notune”</em>, <em>“cadune”</em> і так далі.</p>
<p>Ця стратегія суттєво не змінить результат методу випадкової середньої точки, однак, якщо порядок генетичної інформації відіграє роль у функції оцінювання, ви можете віддати перевагу одному рішенню над іншим. Деякі проблеми можуть отримати більшу користь від випадковості із підходом підкидання монети.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;843&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/0fbcd49814e58ca72853b096bf77cda9/5515e/09_ga_6.webp 576w,./static/0fbcd49814e58ca72853b096bf77cda9/50078/09_ga_6.webp 1152w,./static/0fbcd49814e58ca72853b096bf77cda9/0aa2d/09_ga_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/0fbcd49814e58ca72853b096bf77cda9/5de2f/09_ga_6.png" data-srcset="./static/0fbcd49814e58ca72853b096bf77cda9/4f3bc/09_ga_6.png 576w,./static/0fbcd49814e58ca72853b096bf77cda9/cd17c/09_ga_6.png 1152w,./static/0fbcd49814e58ca72853b096bf77cda9/5de2f/09_ga_6.png 2304w" alt="Малюнок 9.5: Схрещування із підходом підкидання монети"/></picture><noscript><picture><source type="image/webp" srcSet="./static/0fbcd49814e58ca72853b096bf77cda9/5515e/09_ga_6.webp 576w,./static/0fbcd49814e58ca72853b096bf77cda9/50078/09_ga_6.webp 1152w,./static/0fbcd49814e58ca72853b096bf77cda9/0aa2d/09_ga_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/0fbcd49814e58ca72853b096bf77cda9/5de2f/09_ga_6.png" srcSet="./static/0fbcd49814e58ca72853b096bf77cda9/4f3bc/09_ga_6.png 576w,./static/0fbcd49814e58ca72853b096bf77cda9/cd17c/09_ga_6.png 1152w,./static/0fbcd49814e58ca72853b096bf77cda9/5de2f/09_ga_6.png 2304w" alt="Малюнок 9.5: Схрещування із підходом підкидання монети"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.5: Схрещування із підходом підкидання монети</figcaption>
</figure>
<p>Після того, як дочірню ДНК було створено шляхом схрещування, перед додаванням дитини до наступного покоління можна застосувати додатковий необов’язковий процес: <strong>мутацію</strong>. Цей другий етап відтворення в деяких випадках непотрібний, але він існує для подальшого підтримання дарвінівського принципу мінливості. Початкова популяція була створена випадковим чином, забезпечуючи різноманітність елементів на початку. Однак ця варіація обмежена розміром популяції й з часом вона звужується завдяки відбору. Мутація вносить додаткову різноманітність протягом еволюційного процесу.</p>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1502px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;569&#x27; width=&#x27;1502&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d157a368f9ba05a745d960a36052c2ee/187ca/09_ga_7.webp 376w,./static/d157a368f9ba05a745d960a36052c2ee/92b05/09_ga_7.webp 751w,./static/d157a368f9ba05a745d960a36052c2ee/e8393/09_ga_7.webp 1502w" sizes="(min-width: 1502px) 1502px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1502px) 1502px, 100vw" decoding="async" loading="lazy" data-src="./static/d157a368f9ba05a745d960a36052c2ee/65624/09_ga_7.png" data-srcset="./static/d157a368f9ba05a745d960a36052c2ee/5f4bc/09_ga_7.png 376w,./static/d157a368f9ba05a745d960a36052c2ee/a842f/09_ga_7.png 751w,./static/d157a368f9ba05a745d960a36052c2ee/65624/09_ga_7.png 1502w" alt="Малюнок 9.6: Мутація дочірньої фрази"/></picture><noscript><picture><source type="image/webp" srcSet="./static/d157a368f9ba05a745d960a36052c2ee/187ca/09_ga_7.webp 376w,./static/d157a368f9ba05a745d960a36052c2ee/92b05/09_ga_7.webp 751w,./static/d157a368f9ba05a745d960a36052c2ee/e8393/09_ga_7.webp 1502w" sizes="(min-width: 1502px) 1502px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1502px) 1502px, 100vw" decoding="async" loading="lazy" src="./static/d157a368f9ba05a745d960a36052c2ee/65624/09_ga_7.png" srcSet="./static/d157a368f9ba05a745d960a36052c2ee/5f4bc/09_ga_7.png 376w,./static/d157a368f9ba05a745d960a36052c2ee/a842f/09_ga_7.png 751w,./static/d157a368f9ba05a745d960a36052c2ee/65624/09_ga_7.png 1502w" alt="Малюнок 9.6: Мутація дочірньої фрази"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 9.6: Мутація дочірньої фрази</figcaption>
  </figure>
</div>
<p>Мутація описується в термінах <em>частоти</em>. Даний ГА може мати частоту мутації, наприклад, 5 відсотків, або 1 відсоток, або 0.1 відсотка. Скажімо, через схрещування я дійшов до дочірньої фрази <em>“catire”</em>. Якщо рівень мутації становить 1 відсоток, це означає, що кожен символ у фразі має шанс на мутацію у 1 відсоток, перш ніж він “народиться” у наступному пок олінні. Що означає мутація символу? У цьому випадку мутацію можна визначити як вибір нового випадкового символу. Імовірність у 1 відсоток є досить низькою, тому здебільшого мутація взагалі не відбуватиметься в рядку з шести символів (насправді приблизно в 94 відсотках випадків). Однак, коли це відбувається, мутований символ замінюється на випадково згенерований (див. малюнок 9.6).</p>
<p>Як ви побачите в наступних прикладах, частота мутації може сильно вплинути на поведінку системи. Дуже високий рівень мутацій (наприклад, 80 відсотків) зведе нанівець весь еволюційний процес і залишить вас із чимось більш схожим на алгоритм грубої сили. Якщо більшість генів дитини генеруються випадковим чином, ви не можете гарантувати, що з кожним наступним поколінням більш придатні гени з’являютимуться частіше.</p>
<p>Загалом процес відбору (вибір двох батьків) і розмноження (схрещування та мутація) повторюється <em>N</em> разів, доки ви не отримаєте нову популяцію з <em>N</em> елементів.</p>
<h3 id="step-4-repetition"><a class="heading-link" href="#step-4-repetition">Крок 4: Повторення!</a></h3>
<p>У цей момент нова популяція дочірніх елементів стає поточною популяцією. Потім процес повертається до кроку 2 і починає все спочатку, оцінюючи пристосованість кожного елемента, вибираючи батьків та створюючи інше покоління дітей. У міру того, як алгоритм проходить все більше і більше поколінь, залишається сподіватись, що система розвиватиметься у напрямку все ближче й ближче до бажаного рішення.</p>
<h2 id="coding-the-genetic-algorithm"><a class="heading-link" href="#coding-the-genetic-algorithm">Кодування генетичного алгоритму</a></h2>
<p>Тепер, коли я описав усі кроки ГА, настав час перевести їх у код. Перш ніж заглибитися у деталі реалізації, подумаємо, як ці кроки вписуються у загальну стандартну структуру програми p5.js. Що входитиме у функцію <code>setup()</code>, а що у функцію <code>draw()</code>?</p>
<p><code><strong>setup()</strong></code></p>
<p>Крок 1, <strong>Ініціалізація</strong>: створення початкової популяції з <em>N</em> елементів, кожен із випадково згенерованою ДНК.</p>
<p><code><strong>draw()</strong></code></p>
<p>Крок 2, <strong>Відбір</strong>: оцінка пристосованості кожного елемента популяції й формування шлюбного пулу.</p>
<p>Крок 3, <strong>Відтворення</strong>: повторення попередніх кроків <em>N</em> разів:</p>
<ul>
  <li>Вибір двох батьківських елементів з імовірністю відповідно до відносної пристосованості.</li>
  <li><strong>Схрещування:</strong> створення дочірнього елемента, поєднуючи ДНК батьківських елементів.</li>
  <li><strong>Мутація:</strong> зміна ДНК дочірнього елемента на основі заданої ймовірності.</li>
  <li>Додавання новоствореного елемента до нової популяції.</li>
</ul>
<p>Крок 4: Заміна старої популяції новою і повернення до кроку 2.</p>
<p>Маючи цей план, я можу почати писати код.</p>
<h3 id="step-1-initialization"><a class="heading-link" href="#step-1-initialization">Крок 1: Ініціалізація</a></h3>
<p>Якщо я збираюся створити популяцію, мені потрібна структура даних для зберігання списку її елементів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> population = [];
</code></pre><div class="comment"><p>Масив для заповнення елементів.</p></div></div></div>
<p>Вибір масиву для представлення списку простий, але залишається питання: масив чого? Об’єкт є чудовим вибором для зберігання генетичної інформації, оскільки він може містити кілька властивостей і методів. Ці генетичні об’єкти будуть структуровані відповідно до класу, який я назву <code>DNA</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Що має бути у класі <code>DNA</code>? Для кота, який друкує, ДНК буде випадковою фразою, яку він друкує, тобто рядком символів. Однак використання масиву символів (а не об’єкта рядка) забезпечує більш загальний шаблон, який можна легко поширити на інші типи даних. Наприклад, ДНК істоти у фізичній системі може бути масивом векторів або масивом чисел для зображення (піксельні значення RGB). У масиві можна перерахувати будь-який набір властивостей і навіть якщо рядок зручний для конкретного цього сценарію, масив буде кращою основою для майбутніх еволюційних прикладів.</p>
<p>ГА вказує, що я створюю популяцію з <em>N</em> елементів, кожен із <em>випадково згенерованими генами</em>. Таким чином, конструктор ДНК містить цикл для заповнення кожного елемента масиву <code>genes</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
</code></pre><div class="comment"><p>Окремі гени зберігаються в масиві.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p>Гени мають певну довжину.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">randomCharacter</span>();
</code></pre><div class="comment"><p>Кожен ген є випадковим символом.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Щоб випадково згенерувати символ, я напишу допоміжну функцію під назвою <code>randomCharacter()</code>, що викликатиметься для кожного окремого гена:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomCharacter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> c = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">32</span>, <span class="hljs-number">127</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(c);
}
</code></pre><div class="comment"><p>Функція повертає випадковий символ (букву, цифру, символ, пробіл тощо).</p></div></div></div>
<p>Вибрані випадкові числа відповідають певному символу відповідно до стандарту, відомого як <strong>ASCII</strong> (американський стандартний код для обміну інформацією), а <code>String.fromCharCode()</code> є рідним методом JavaScript, який перетворює число у відповідний символ на основі цього стандарту. Вказаний мною діапазон охоплює великі та малі літери, цифри, знаки пунктуації та спеціальні символи. Альтернативний підхід може використовувати стандарт Unicode, який включає емодзі та символи з різних мов світу, забезпечуючи більший діапазон символів для іншого цільового рядка.</p>
<p>Тепер, коли у мене є конструктор, я можу повернутися до функції <code>setup()</code> та ініціалізувати кожен об’єкт <code>DNA</code> для масиву <code>population</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> population = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; population.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    population[i] = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>(<span class="hljs-number">18</span>);
</code></pre><div class="comment"><p>Ініціалізація кожного елемента популяції. Параметр для довжини масиву генів наразі жорстко закодовано значенням 18.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Клас <code>DNA</code> ще не завершено. Мені потрібно надати йому методи, які виконуватимуть усі інші завдання ГА. Я зроблю це під час імплементації кроків 2 і 3.</p>
<h3 id="step-2-selection-1"><a class="heading-link" href="#step-2-selection-1">Крок 2: Відбір</a></h3>
<p>Крок 2 говорить: “Оцініть пристосованість кожного елемента популяції та побудуйте шлюбний пул”. Я почну з першої ч астини, оцінюючи пристосованість кожного елемента. Раніше я зазначав, що одним із варіантів оцінювання пристосованості для введених фраз є загальна кількість правильних символів. Тепер я трохи перегляну цю оцінювальну функцію і визначу її як <em>відсоток</em> правильних символів, тобто кількість правильних символів поділених на загальну кількість символів:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>пристосованість</mtext><mo>=</mo><mfrac><mtext>кількість правильних символів</mtext><mtext>загальна кількість символів</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{пристосованість} = \frac{\text{кількість правильних символів}}{\text{загальна кількість символів}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">пристосованість</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord cyrillic_fallback">загальна</span><span class="mord"> </span><span class="mord cyrillic_fallback">кількість</span><span class="mord"> </span><span class="mord cyrillic_fallback">символів</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord cyrillic_fallback">кількість</span><span class="mord"> </span><span class="mord cyrillic_fallback">правильних</span><span class="mord"> </span><span class="mord cyrillic_fallback">символів</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div>
<p>Де потрібно розраховувати пристосованість? Оскільки клас <code>DNA</code> містить генетичну інформацію (фразу, яку я буду перевіряти на цільову фразу), я можу написати метод усередині класу <code>DNA</code>, щоб він сам оцінював свою власну пристосованість. Підготуємо цільову фразу:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> target = <span class="hljs-string">&quot;to be or not to be&quot;</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер я можу порівнювати кожен ген із відповідним символом у цільовій фразі,  збільшуючи лічильник щоразу, коли знаходжу правильний символ у правильній позиції. Наприклад, символ <code>t</code> зустрічається у кількох місцях фрази <code>target</code>, але це підвищує пристосованість, лише якщо він знаходиться у масиві <code>genes</code> у правильній позиції відповідного індексу:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Змінна для значення пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">randomCharacter</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params">target</span>) {
    <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] === target.<span class="hljs-title function_">charAt</span>(i)) {
        score++;
      }
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = score / target.<span class="hljs-property">length</span>;
  }
</code></pre><div class="comment"><p>Обчислення пристосованості згідно відсотку правильних символів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Оскільки пристосованість обчислюється для кожного наступного покоління, найпершим кроком, який я зроблю всередині циклу у функції <code>draw()</code>, буде виклик функції оцінки пристосованості для кожного елементу популяції:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> phrase <span class="hljs-keyword">of</span> population) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    phrase.<span class="hljs-title function_">calculateFitness</span>(target);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Після того, як оцінки пристосованості були обчислені, наступним кроком є створення <em>шлюбного пулу</em> для процесу відтворення. Шлюбний пул — це структура даних з якої будуть вибиратися батьківські пари. Згадуючи опис процесу відбору, мета полягає в тому, щоб вибрати батьків з імовірністю, розрахованою відповідно до оцінки пристосованості. Члени популяції з найвищими балами пристосованості повинні бути вибрані з більшою ймовірністю, а ті хто має найнижчі бали — з меншою.</p>
<p>У <a href="/random#section-random">Розділі 0</a> я розглянув основи ймовірності й генерування спеціального розподілу випадкових чисел. Я збираюся використати тут ті самі методи, щоб призначити ймовірність кожному члену популяції, вибираючи батьків шляхом обертання колеса фортуни. Переглянувши малюнок 9.2, ваш розум може негайно повернутися до <a href="/oscillation#section-oscillation">Розділу 3</a> і подумати про кодування симуляції справжнього обертового колеса. Як би це не було весело (і ви якось можете зробити таке колесо!), це зовсім непотрібно.</p>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1089&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/fa15a6ccc76a80e26124c65914872cbd/e38ee/09_ga_8.webp 288w,./static/fa15a6ccc76a80e26124c65914872cbd/7a748/09_ga_8.webp 576w,./static/fa15a6ccc76a80e26124c65914872cbd/5451b/09_ga_8.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/fa15a6ccc76a80e26124c65914872cbd/921fb/09_ga_8.png" data-srcset="./static/fa15a6ccc76a80e26124c65914872cbd/3c6ef/09_ga_8.png 288w,./static/fa15a6ccc76a80e26124c65914872cbd/e2623/09_ga_8.png 576w,./static/fa15a6ccc76a80e26124c65914872cbd/921fb/09_ga_8.png 1152w" alt="Малюнок 9.7: Відро, наповнене літерами A, B, C, D і E. Що вища пристосованість, то більше літер у відрі"/></picture><noscript><picture><source type="image/webp" srcSet="./static/fa15a6ccc76a80e26124c65914872cbd/e38ee/09_ga_8.webp 288w,./static/fa15a6ccc76a80e26124c65914872cbd/7a748/09_ga_8.webp 576w,./static/fa15a6ccc76a80e26124c65914872cbd/5451b/09_ga_8.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/fa15a6ccc76a80e26124c65914872cbd/921fb/09_ga_8.png" srcSet="./static/fa15a6ccc76a80e26124c65914872cbd/3c6ef/09_ga_8.png 288w,./static/fa15a6ccc76a80e26124c65914872cbd/e2623/09_ga_8.png 576w,./static/fa15a6ccc76a80e26124c65914872cbd/921fb/09_ga_8.png 1152w" alt="Малюнок 9.7: Відро, наповнене літерами A, B, C, D і E. Що вища пристосованість, то більше літер у відрі"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 9.7: Відро, наповнене літерами A, B, C, D і E. Що вища пристосованість, то більше літер у відрі</figcaption>
  </figure>
</div>
<p>Одне з рішень, яке може тут спрацювати, полягає в тому, щоб вибрати з п’яти варіантів, зображених на малюнку 9.2 (A, B, C, D, E) відповідно до їхніх імовірностей, заповнивши масив кількома екземплярами кожного батьківського елемента. Іншими словами, уявіть, що у вас є відро з дерев’яними літерами, як на малюнку 9.7. Виходячи з попередніх імовірностей, воно повинно містити 30 літер A, 40 літер B, 5 літер C, 10 літер D і 15 літер E. Якби ви вибрали випадкову букву з цього відра, то мали б 30-відсотковий шанс отримати букву A, 5-відсотковий шанс отримати літеру C і так далі.</p>
<p>Для коду ГА це відро може бути масивом, а кожна дерев’яна літера — потенційним батьківським об’єктом <code>DNA</code>. Таким чином, шблюбний пул створюється шляхом додавання до масиву кожного з батьківських елементів певну кількість разів, відповідно до оцінки їх пристосованості:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> matingPool = [];
</code></pre><div class="comment"><p>Почнемо з порожнього шлюбного пулу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> phrase <span class="hljs-keyword">of</span> population) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> n = <span class="hljs-title function_">floor</span>(phrase.<span class="hljs-property">fitness</span> * <span class="hljs-number">100</span>);
</code></pre><div class="comment"><p>n дорівнює значенню пристосованості помноженому на 100.
100 — це довільний спосіб масштабування відсотка пристосованості до більшого цілого значення.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      matingPool.<span class="hljs-title function_">push</span>(phrase);
</code></pre><div class="comment"><p>Додамо кожного члена популяції до шлюбного пулу n разів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Коли шлюбний пул готовий, настав час вибрати двох батьків! Вибір двох батьків для кожної дитини є дещо довільним рішенням. Це, безумовно, віддзеркалює людське відтворення і є стандартним способом у підручнику ГА-мів, але з точки зору творчих застосувань тут справді немає обмежень. Ви можете вибрати лише одного батька для клонування або розробити методологію відтворення для вибору трьох-чотирьох батьків для генерації дитячої ДНК. Для цієї демонстрації я виберу два батьківські елементи та назву їх <code>parentA</code> і <code>parentB</code>.</p>
<div class="avoid-break">
  <p>Я можу вибрати два випадкових екземпляри ДНК зі шлюбного пулу за допомогою функції <code>random()</code>. Коли масив передається як аргумент для функції <code>random()</code>, вона повертає один випадковий елемент із цього масиву:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> parentA = <span class="hljs-title function_">random</span>(matingPool);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> parentB = <span class="hljs-title function_">random</span>(matingPool);
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Цей метод створення шлюбного пулу та вибору з нього батьків працює, але це не єдиний спосіб відбору. Інші, більш ефективні методи не вимагають додаткового масиву з кількома посиланнями на кожен елемент. Наприклад, згадайте обговорення нерівномірного розподілу випадкових чисел у <a href="/random#section-random">Розділі 0</a>. Там я реал ізував метод прийняття-відхилення. Якщо його застосувати тут, підхід полягатиме у випадковому виборі елемента з вихідного масиву <code>population</code>, а потім у виборі другого випадкового числа-кваліфікатора для перевірки відповідності значення елемента. Якщо пристосованість менша за кваліфікаційне число, почніть заново і виберіть новий елемент. Продовжуйте доки двоє батьків не будуть визнані достатньо пристосованими для спільної пари.</p>
<p>Варто розглянути ще одну чудову альтернативу, яка подібним чином використовує принцип відбору — пропорційну пристосованість. Щоб зрозуміти, як це працює, уявіть собі естафету, в якій кожен член популяції пробігає задану дистанцію, прив’язану до його рівня пристосованості. Чим вище пристосованість, тим далі вони бігають. Давайте також припустимо, що оцінки пристосованості були нормалізовані, щоб усі суми дорівнювали 1 (так само як у випадку з колесом фортуни). Першим кроком є вибір <em>стартової лінії</em> — випадкової відстані від фінішу. Ця відстань є випадковим числом від 0 до 1. (За мить ви побачите, що фінішна лінія вважається нульовою).</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> start = <span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Потім естафета починається на стартовій лінії з першим представником популяції:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Бігун проходить відстань, визначену його нормалізованим показником пристосованості, а потім передає естафету наступному бігуну:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">while</span> (start &gt; <span class="hljs-number">0</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  start = start - population[index].<span class="hljs-property">fitness</span>;
</code></pre><div class="comment"><p>Перехід на відстань відповідно до показника пристосованості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  index++;
</code></pre><div class="comment"><p>Передача естафети наступному елементу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ці кроки повторюються знову і знову у циклі <code>while</code>, доки естафета не закінчиться і значення змінної <code>start</code> стане менше або дорівнюватиме нулю, що відповідає фінішній лінії. Бігун, який перетинає фінішну лінію, вибирається у якості батьківського елементу.</p>
<p>Нижче усі кроки функції, яка повертає вибраний елемент, об’єднані разом:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">weightedSelection</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Починаємо з першого елемента.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> start = <span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Вибираємо початкову точку.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">while</span> (start &gt; <span class="hljs-number">0</span>) {
</code></pre><div class="comment"><p>Повторюємо доки не дістанемося фінішу.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    start = start - population[index].<span class="hljs-property">fitness</span>;
</code></pre><div class="comment"><p>Переходимо на відстань відповідно до рівня пристосованості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    index++;
</code></pre><div class="comment"><p>Передаємо естафету наступному елементу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  index--;
  <span class="hljs-keyword">return</span> population[index];
</code></pre><div class="comment"><p>Скасовуємо перехід до наступного елементу після досягнення фінішу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Це добре підходить для відбору, оскільки кожен учасник має можливість перетнути фінішну лінію (усі оцінки пристосованості складаються до 1), але ті, хто біжить на більші дистанції (тобто ті, хто має вищий бал оцінки), мають більше шансів. Однак, попри те, що цей метод є більш ефективним для пам’яті, він може бути більш <em>вимогливим до обчислень</em>, особливо для великих популяцій, оскільки вимагає ітерації по популяції для кожного відбору. Напротивагу, оригінальний метод з масивом <code>matingPool</code> потребує лише однієї дії з випадковим пошуком в масиві для кожного батьківського елементу.</p>
<p>Залежно від конкретних вимог і обмежень вашого проєкту ГА, один підхід може виявитися більш прийнятним, ніж інший. Я буду чергувати їх у прикладах, наведених у цьому розділі.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-92"><a class="heading-link" href="#exercise-92">Вправа 9.2</a></h3>
  <p>Перегляньте алгоритм прийняття-відхилення з <a href="/random#section-random">Розділу 0</a> і перепишіть функцію <code>weightedSelection()</code> з його використанням. Подібно до методу естафети, цей підхід також може призвести до інтенсивних обчислень, оскільки кілька потенційних батьків можуть бути відхилені як непридатні до того, як один із них буде остаточно обраний.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-93"><a class="heading-link" href="#exercise-93">Вправа 9.3</a></h3>
  <p>У деяких випадках алгоритм колеса удачі надаватиме надзвичайно високу перевагу одним елементам над іншими. Візьмемо наступні ймовірності:</p>
  <table><thead><tr><th style="width:200px">Елемент</th><th>Ймовірність</th></tr></thead><tbody><tr><td>A</td><td>98%</td></tr><tr><td>B</td><td>1%</td></tr><tr><td>C</td><td>1%</td></tr></tbody></table>
  <p>Іноді це небажано, враховуючи, що це зменшить кількість різноманітності у цій системі. Розв&#x27;язання цієї проблеми полягає в тому, щоб замінити розраховані оцінкові бали порядковими номерами балів — надання своєрідного рангу чи ваги:</p>
  <table><thead><tr><th style="width:100px">Елемент</th><th style="width:100px">Ранг</th><th>Ймовірність</th></tr></thead><tbody><tr><td>A</td><td>1</td><td>50% (1/2)</td></tr><tr><td>B</td><td>2</td><td>33% (1/3)</td></tr><tr><td>C</td><td>3</td><td>17% (1/6)</td></tr></tbody></table>
  <p>Як можна реалізувати такий підхід? Підказка: вам не потрібно змінювати алгоритм вибору. Натомість ваше завдання полягає в тому, щоб обчислити ймовірності за рангом, а не за необробленою оцінкою пристосованості.</p>
</div>
<p>У будь-якому з цих алгоритмів той самий батьківський елемент може бути обраний двічі для даної дитини. Якби я хотів, то міг би вдосконалити алгоритм, щоб переконатися, що це неможливо. Ймовірно, це мало б невеликий вплив на кінцевий результат, але можливо це варто дослідити в рамках окремої вправи.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-94"><a class="heading-link" href="#exercise-94">Вправа 9.4</a></h3>
  <p>Виберіть будь-який зі зважених алгоритмів відбору та адаптуйте алгоритм, щоб гарантувати вибір двох унікальних батьків.</p>
</div>
<h3 id="step-3-reproduction-crossover-and-mutation"><a class="heading-link" href="#step-3-reproduction-crossover-and-mutation">Крок 3: Відтворення (схрещування і мутація)</a></h3>
<p>Коли я вже отримав двох батьків, наступним кроком буде виконання операції <strong>схрещування</strong> для генерації дочірньої ДНК з подальшою <strong>мутацією</strong>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> child = parentA.<span class="hljs-title function_">crossover</span>(parentB);
</code></pre><div class="comment"><p>Метод для схрещування.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">child.<span class="hljs-title function_">mutate</span>();
</code></pre><div class="comment"><p>Метод для мутації.</p></div></div></div>
<p>Звісно, методи <code>crossover()</code> і <code>mutate()</code> не з’явилися у класі <code>DNA</code> магічним чином й мені потрібно їх написати. Спосіб виклику мого методу <code>crossover()</code> вказує на те, що він повинен отримати екземпляр <code>DNA</code> як аргумент (тут це <code>parentB</code>) і повернути новий екземпляр <code>DNA</code>, тобто <code>child</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title function_">crossover</span>(<span class="hljs-params">partner</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>);
</code></pre><div class="comment"><p>child — це новий екземпляр DNA.
(Зауважте, що гени генеруються випадковим чином у конструкторі DNA,
але метод схрещування перезаписує масив.)</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> midpoint = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>));
</code></pre><div class="comment"><p>Вибір випадкової середини у масиві генів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (i &lt; midpoint) {
      child.<span class="hljs-property">genes</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i];
</code></pre><div class="comment"><p>До серединної точки беруться гени з поточної ДНК.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p>Після серединної точки береться ДНК від партнера.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      child.<span class="hljs-property">genes</span>[i] = partner.<span class="hljs-property">genes</span>[i];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">return</span> child;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ця імплементація використовує метод схрещування з підходом випадкової середньої точки, у якому перша частина генів береться від батьківського елемента A, а друга — від B.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-95"><a class="heading-link" href="#exercise-95">Вправа 9.5</a></h3>
  <p>Перепишіть функцію схрещування, щоб натомість використовувати метод підкидання монети, у якому кожен ген матиме 50-відсотковий шанс походити від батьківського елементу A та 50-відсотковий шанс походити від елементу B.</p>
</div>
<p>Написати метод <code>mutate()</code> навіть простіше ніж <code>crossover()</code>. Все, що мені потрібно зробити, це пройтись масивом генів і випадковим чином вибрати новий символ відповідно до визначеної частоти мутації. Наприклад, при частоті мутації в 1 відсоток, новий символ буде створено лише 1 раз на 100 разів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> mutationRate = <span class="hljs-number">0.01</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; mutationRate) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-comment">/* Будь-який код тут виконуватиметься в 1% випадків. */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<div class="avoid-break">
  <p>Тому весь метод виглядає наступним чином:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title function_">mutate</span>(<span class="hljs-params">mutationRate</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p>Перегляд кожного гена у масиві.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; mutationRate) {
</code></pre><div class="comment"><p>Порівняння випадкового числа із частотою мутації.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">randomCharacter</span>();
</code></pre><div class="comment"><p>Мутація означає вибір нового випадкового символа.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Щоб спростити процес мутації, я знову можу використати допоміжну функцію <code>randomCharacter()</code>.</p>
<h3 id="putting-it-all-together"><a class="heading-link" href="#putting-it-all-together">Збираємо все разом</a></h3>
<p>На цей час я двічі пройшов кроками ГА: перший раз описав алгоритм у формі розповіді, а другий раз із фрагментами коду, що імплементують кожен із кроків. Тепер я готовий зібрати все до купи й показати вам повний код разом з основними кроками алгоритму.</p>
<div data-type="example">
  <h3 id="example-91-genetic-algorithm-for-evolving-shakespeare"><a class="heading-link" href="#example-91-genetic-algorithm-for-evolving-shakespeare">Приклад 9.1: Генетичний алгоритм для еволюції фрази Шекспіра</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/09_ga/9_1_ga_shakespeare"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/q4F192JCV" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> mutationRate = <span class="hljs-number">0.01</span>;
</code></pre><div class="comment"><p>Частота мутацій.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> populationSize = <span class="hljs-number">150</span>;
</code></pre><div class="comment"><p>Розмір популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> population = [];
</code></pre><div class="comment"><p>Масив для популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> target = <span class="hljs-string">&quot;to be or not to be&quot;</span>;
</code></pre><div class="comment"><p>Цільова фраза.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">360</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; populationSize; i++) {
    population[i] = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>(target.<span class="hljs-property">length</span>);
  }
</code></pre><div class="comment"><p>Крок 1: Ініціалізація.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p>Крок 2: Відбір.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> phrase <span class="hljs-keyword">of</span> population) {
    phrase.<span class="hljs-title function_">calculateFitness</span>(target);
  }
</code></pre><div class="comment"><p>Крок 2а: обчислення оцінки пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> matingPool = [];
</code></pre><div class="comment"><p>Крок 2b: Створення шлюбного пулу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> phrase <span class="hljs-keyword">of</span> population) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> n = <span class="hljs-title function_">floor</span>(phrase.<span class="hljs-property">fitness</span> * <span class="hljs-number">100</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
      matingPool.<span class="hljs-title function_">push</span>(phrase);
    }
</code></pre><div class="comment"><p>Додавання кожного елементу популяції n разів відповідно до його оцінки пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; population.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">let</span> parentA = <span class="hljs-title function_">random</span>(matingPool);
    <span class="hljs-keyword">let</span> parentB = <span class="hljs-title function_">random</span>(matingPool);
</code></pre><div class="comment"><p>Крок 3: Відтворення.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> child = parentA.<span class="hljs-title function_">crossover</span>(parentB);
</code></pre><div class="comment"><p>Крок 3a: Схрещування.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    child.<span class="hljs-title function_">mutate</span>(mutationRate);
</code></pre><div class="comment"><p>Крок 3b: Мутація.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    population[i] = child;
</code></pre><div class="comment"><p>Зверніть увагу, що ми перезаписуємо популяцію новими дочірніми
елементами. Під час циклічного виконання функції draw() ми виконуватимемо
всі ті самі кроки з новою популяцією нащадків.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p>Крок 4: Повторення. Повернення до початку циклічної функції draw().</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Файл <em>sketch.js</em> точно відображає кроки ГА. Однак більшість функціональних можливостей інкапсульовано у класі <code>DNA</code>:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">randomCharacter</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
  }
</code></pre><div class="comment"><p>Конструктор (створює випадкову ДНК).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">getPhrase</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);
  }
</code></pre><div class="comment"><p>Перетворення масиву на рядок фенотипу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params">target</span>) {
    <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] === target.<span class="hljs-title function_">charAt</span>(i)) {
        score++;
      }
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = score / target.<span class="hljs-property">length</span>;
  }
</code></pre><div class="comment"><p>Розрахунок оцінки пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">crossover</span>(<span class="hljs-params">partner</span>) {
    <span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">let</span> midpoint = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (i &lt; midpoint) {
        child.<span class="hljs-property">genes</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i];
      } <span class="hljs-keyword">else</span> {
        child.<span class="hljs-property">genes</span>[i] = partner.<span class="hljs-property">genes</span>[i];
      }
    }
    <span class="hljs-keyword">return</span> child;
  }
</code></pre><div class="comment"><p>Схрещування.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">mutate</span>(<span class="hljs-params">mutationRate</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; mutationRate) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">randomCharacter</span>();
      }
    }
  }
</code></pre><div class="comment"><p>Мутація.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomCharacter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> c = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">32</span>, <span class="hljs-number">127</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(c);
}
</code></pre><div class="comment"><p>Повернення випадкового символу (букви, цифри, символу, пробілу тощо).</p></div></div></div>
</div>
<p>У прикладі 9.1 ви можете помітити, що нові дочірні елементи безпосередньо додаються до масиву <code>population</code>. Такий підхід можливий, оскільки у мене є окремий масив шлюбного пулу, який містить посилання на оригінальні батьківські елементи. Однак, якби замість цього я використовував функцію з підходом естафети <code>weightedSelection()</code>, мені потрібно було б створити тимчасовий масив для нової популяції. Цей тимчасовий масив міститиме дочірні елементи й замінюватиме вихідний масив лише після завершення кроку відтворення. Ви побачите, як це реалізовано у прикладі 9.2.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-96"><a class="heading-link" href="#exercise-96">Вправа 9.6</a></h3>
  <p>Додайте функціональності до прикладу 9.1, щоб відобразити більше інформації про прогрес самого ГА. Наприклад, покажіть фразу, найближчу до цільової в кожному поколінні, а також звіт про кількість поколінь, середню пристосованість тощо. Зупиніть ГА після того, як він досягне потрібної фрази. Спробуйте написати клас <code>Population</code> для керування ГА замість того, щоб включати весь код у функцію <code>draw()</code>.</p>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/09_ga/exercise_9_6_annotated_ga_shakespeare"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/ZwT5cPix2" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-97"><a class="heading-link" href="#exercise-97">Вправа 9.7</a></h3>
  <p>Дослідіть ідею динамічної частоти мутації. Наприклад, спробуйте обчислити частоту мутації, яка обернено корельована із середньою пристосованістю батьківських фраз, щоб вища пристосованість призводила до меншої кількості мутацій. Чи впливає ця зміна на поведінку всієї системи та на те, як швидко буде знайдена цільова фраза?</p>
</div>
<p></p>
<h2 id="customizing-genetic-algorithms"><a class="heading-link" href="#customizing-genetic-algorithms">Налаштування генетичних алгоритмів</a></h2>
<p>Хороша річ у використанні ГА у проєктах в тому, що приклад коду можна легко переносити із програми у програму. Основні механізми відбору і відтворення не потребують змін. Однак вам, творцю, доведеться налаштувати три ключові компоненти ГА для кожного використання. Це надзвичайно важливо для переходу від тривіальних демонстрацій еволюційного моделювання (як у прикладі з Шекспіром) до творчого використання в проєктах, які ви робите в p5.js та інших середовищах програмування.</p>
<h3 id="key-1-the-global-variables"><a class="heading-link" href="#key-1-the-global-variables">Ключовий аспект 1: Глобальні змінні</a></h3>
<p>ГА не має багато змінних. Якщо ви подивитеся на код у прикладі 9.1, то побачите лише дві глобальні змінні (не враховуючи масиви для зберігання популяції й шлюбного пулу):</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> mutationRate = <span class="hljs-number">0.01</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> populationSize = <span class="hljs-number">150</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ці дві змінні можуть значно вплинути на поведінку системи, і використовування довільних значень тут не краща ідея (хоча їх налаштування методом проб і помилок є цілком розумним способом отримати оптимальні значення).</p>
<p>Я вибрав спеціальні значення для демонстрації прикладу з Шекспіром, щоб практично гарантувати, що ГА розв’яже фразу, але не надто швидко (у середньому приблизно за 1000 поколінь), щоб продемонструвати процес протягом певного періоду часу. Однак набагато більша популяція дасть швидші результати (для мети з більшою ефективністю алгоритму, а не демонстрацією). Ось таблиця з деякими результатами:</p>
<table><thead><tr><th style="width:100px">Розмір популяції</th><th style="width:100px">Частота мутацій</th><th>Кількість пройдених поколінь для отримання цільової фрази</th><th>Загальний час (у секундах) для отримання цільової фрази</th></tr></thead><tbody><tr><td>150</td><td>1%</td><td>1 089</td><td>18.8</td></tr><tr><td>300</td><td>1%</td><td>448</td><td>8.2</td></tr><tr><td>1 000</td><td>1%</td><td>71</td><td>1.8</td></tr><tr><td>50 000</td><td>1%</td><td>27</td><td>4.3</td></tr></tbody></table>
<p>Зауважте, що збільшення чисельності популяції різко зменшує кількість поколінь, необхідних для розв’язання фрази. Однак це не обов’язково зменшує кількість часу. Коли популяція зростає до 50 000 елементів, програма починає виконуватися повільно, враховуюч и кількість часу, необхідного для обробки оцінки пристосованості та створення шлюбного пулу з такої кількості елементів. (Звісно, якщо вам потрібна така велика популяція, можна зробити певну оптимізацію.)</p>
<p>Окрім розміру популяції, на продуктивність може сильно вплинути частота мутацій:</p>
<table><thead><tr><th style="width:100px">Розмір популяції</th><th style="width:100px">Частота мутацій</th><th>Кількість пройдених поколінь для отримання цільової фрази</th><th>Загальний час (у секундах) для отримання цільової фрази</th></tr></thead><tbody><tr><td>1 000</td><td>0%</td><td>37 або ніколи?</td><td>1.2 або ніколи?</td></tr><tr><td>1 000</td><td>1%</td><td>71</td><td>1.8</td></tr><tr><td>1 000</td><td>2%</td><td>60</td><td>1.6</td></tr><tr><td>1 000</td><td>10%</td><td>Ніколи?</td><td>Ніколи?</td></tr></tbody></table>
<p>Без жодної мутації (0 відсотків) вам може просто пощастити. Якщо всі правильні символи присутні десь в елементах початкової популяції, ви дуже швидко розвинете потрібну фразу. Якщо ні, то програма не зможе досягти точної фрази. Запустіть її кілька разів і побачите обидва варіанти. Крім того, як тільки рівень мутації стає достатньо високим (наприклад, 10 відсотків), виникає стільки випадковості (одна з кожних 10 букв є випадковою у кожному новому дочірньому елементі), що симуляція майже повертається до випадкової версії котів-друкарів. Теоретично це зрештою призведе до потрібної фрази, але ви можете чекати набагато, набагато довше, ніж це буде розумним.</p>
<h3 id="key-2-the-fitness-function"><a class="heading-link" href="#key-2-the-fitness-function">Ключовий аспект 2: Функія оцінки пристосованості</a></h3>
<p>Пограти з частотою мутації або чисельністю популяції досить легко і потребує лише введення потрібних чисел у вашу програму. Справжня важка робота розробки ГА полягає в написанні функції, що оцінює пристосованість. Якщо ви не можете визначити цілі вашої проблеми й чисельно оцінити наскільки вони були досягнуті, то не матимете успішної еволюції у вашій симуляції.</p>
<p>Перш ніж я перейду до інших сценаріїв дослідження складніших оцінювальних функцій, я хочу поглянути на недоліки у моїй шекспірівській функції. Подумайте про розв’язання фрази, яка містить не 18 символів, а 1000. І візьміть два елементи популяції, один із 800 правильними символами, а інший із 801. Ось їхні оцінки пристосованості:</p>
<table><thead><tr><th style="width:100px">Фраза</th><th style="width:200px">Правильні символи</th><th>Пристосованість</th></tr></thead><tbody><tr><td>A</td><td>800</td><td>80.0%</td></tr><tr><td>B</td><td>801</td><td>80.1%</td></tr></tbody></table>
<p>Цей сценарій має кілька проблем. По-перше, я додаю елементи до шлюбного пулу <em>N</em> разів, де <em>N</em> дорівнює значенню пристосованості, помноженому на 100. Але об’єкти можна додавати до масиву лише цілу кількість разів, тому A і B буде додано 80 разів, даючи їм рівну ймовірність для відбору. Навіть із покращеним рішенням, яке враховує ймовірності з рухомою крапкою, 80.1 відсотка лише трохи перевищують 80 відсотків. Але отримати в еволюційному сценарії 801 правильний символ набагато краще, ніж 800. Я справді хочу, щоб цей додатковий символ враховувався. Я хочу, щоб оцінка пристосованості для 801 символу була <em>суттєво</em> кращою, ніж оцінка для 800 символів.</p>
<p>Іншими словами, малюнок 9.8 показує графіки двох можливих функцій оцінки пристосованості.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;734&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4f2a61b3c289dc4010e3d7a856fcbee5/77b42/09_ga_9.webp 576w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/57035/09_ga_9.webp 1152w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/42a3e/09_ga_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/4f2a61b3c289dc4010e3d7a856fcbee5/386cb/09_ga_9.png" data-srcset="./static/4f2a61b3c289dc4010e3d7a856fcbee5/c6515/09_ga_9.png 576w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/0b1df/09_ga_9.png 1152w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/386cb/09_ga_9.png 2304w" alt="Малюнок 9.8: Графік пристосованості y = x (ліворуч) і y = x^2 (праворуч)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4f2a61b3c289dc4010e3d7a856fcbee5/77b42/09_ga_9.webp 576w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/57035/09_ga_9.webp 1152w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/42a3e/09_ga_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/4f2a61b3c289dc4010e3d7a856fcbee5/386cb/09_ga_9.png" srcSet="./static/4f2a61b3c289dc4010e3d7a856fcbee5/c6515/09_ga_9.png 576w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/0b1df/09_ga_9.png 1152w,./static/4f2a61b3c289dc4010e3d7a856fcbee5/386cb/09_ga_9.png 2304w" alt="Малюнок 9.8: Графік пристосованості y = x (ліворуч) і y = x^2 (праворуч)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.8: Графік пристосованості <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> (ліворуч) і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">y = x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> (праворуч)</figcaption>
</figure>
<p>Зліва — лінійний графік. Зі збільшенням кількості символів лінійно зростає і показник пристосованості. Напротивагу, на графіку праворуч, зі збільшенням кількості символів показник пристосованості <em>значно</em> зростає. Тобто зі збільшенням кількості правильних символів оцінка пристосованості зростає з прискореною швидкістю.</p>
<p>Я можу досягти результату другого типу різними способами. Наприклад, я міг би сказати так:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>оцінка пристосованості</mtext><mo>=</mo><msup><mtext>(кількість правильних символів)</mtext><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\text{оцінка пристосованості} = \text{(кількість правильних символів)}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">оцінка</span><span class="mord"> </span><span class="mord cyrillic_fallback">пристосованості</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em"></span><span class="mord"><span class="mord text"><span class="mord">(</span><span class="mord cyrillic_fallback">кількість</span><span class="mord"> </span><span class="mord cyrillic_fallback">правильних</span><span class="mord"> </span><span class="mord cyrillic_fallback">символів</span><span class="mord">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em"><span style="top:-3.2029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></div>
<p>Тут показники пристосованості зростають <strong>квадратично</strong>, тобто пропорційно до квадрата кількості правильних символів. Скажімо, у мене є два члени популяції, один із п’ятьма правильними символами, а інший із шістьма. Число 6 на 20 відсотків більше, ніж число 5. Однак, при піднесенні кількості правильних символів у квадрат, оцінка пристосованості збільшиться з 25 до 36, тобто на 44 відсотки:</p>
<table><thead><tr><th style="width:250px">Кількість правильних символів</th><th>Оцінка пристосованості</th></tr></thead><tbody><tr><td>5</td><td>25</td></tr><tr><td>6</td><td>36</td></tr></tbody></table>
<p>Ось інша можлива формула:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>оцінка пристосованості</mtext><mo>=</mo><msup><mn>2</mn><mtext>у степені кількості правильних символів</mtext></msup></mrow><annotation encoding="application/x-tex">\text{оцінка пристосованості} = 2^\text{у степені кількості правильних символів}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">оцінка</span><span class="mord"> </span><span class="mord cyrillic_fallback">пристосованості</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8913em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord cyrillic_fallback mtight">у</span><span class="mord mtight"> </span><span class="mord cyrillic_fallback mtight">степені</span><span class="mord mtight"> </span><span class="mord cyrillic_fallback mtight">кількості</span><span class="mord mtight"> </span><span class="mord cyrillic_fallback mtight">правильних</span><span class="mord mtight"> </span><span class="mord cyrillic_fallback mtight">символів</span></span></span></span></span></span></span></span></span></span></span></span></span></div>
<p>А ось як ця формула працює зі збільшенням кі лькості правильних символів:</p>
<table><thead><tr><th style="width:250px">Кількість правильних символів</th><th>Оцінка пристосованості</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>8</td></tr><tr><td>4</td><td>16</td></tr></tbody></table>
<p>Тут показники оцінки пристосованості зростають <strong>експоненціально</strong>, подвоюючись з кожним додатковим правильним символом.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-98"><a class="heading-link" href="#exercise-98">Вправа 9.8</a></h3>
  <p>Перепишіть функцію оцінки пристосованості, щоб збільшувати її квадратично або експоненціально відповідно до кількості правильних символів. Зауважте, що вам, швидше за все, доведеться нормалізувати значення пристосованості до діапазону від 0 до 1, щоб їх можна було додавати до шлюбного пулу розумну кількість разів, або використати інший метод зваженого відбору.</p>
</div>
<p>Хоча це конкретне обговорення експоненціальних і лінійних рівнянь є важливою деталлю у розробці хорошої оцінювальної функції, я не хочу, щоб ви випустили тут більш важливий момент: <em>ви можете створювати власні оцінювальні функції</em>! Я дуже сумніваюся, що будь-який проєкт, який ви робитимете на p5.js із ГА, передбачатиме підрахунок пр авильної кількості символів у рядку. У контексті цієї книги ви, швидше за все, захочете еволюціонувати створіння, яке є частиною фізичної системи. Можливо, ви прагнете оптимізувати ваги поведінкових шаблонів, щоб створіння могло найкраще втікати від хижака, уникати перешкоди чи проходити через лабіринт. Ви повинні запитати себе, що ви збираєтеся оцінювати.</p>
<p>Розглянемо симуляцію перегонів, у якій перегонове авто розвиває оптимізацію свого дизайну для кращої швидкості:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>оцінка пристосованості</mtext><mo>=</mo><mtext>кількість кадрів, необхідних для досягнення болідом фінішу</mtext></mrow><annotation encoding="application/x-tex">\text{оцінка пристосованості} = \text{кількість кадрів, необхідних для досягнення болідом фінішу}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">оцінка</span><span class="mord"> </span><span class="mord cyrillic_fallback">пристосованості</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">кількість</span><span class="mord"> </span><span class="mord cyrillic_fallback">кадрів</span><span class="mord">, </span><span class="mord cyrillic_fallback">необхідних</span><span class="mord"> </span><span class="mord cyrillic_fallback">для</span><span class="mord"> </span><span class="mord cyrillic_fallback">досягнення</span><span class="mord"> </span><span class="mord cyrillic_fallback">болідом</span><span class="mord"> </span><span class="mord cyrillic_fallback">фінішу</span></span></span></span></span></span></div>
<p>Як щодо миші, яка еволюціонує оптимальним шляхом, щоб знайти шматок сиру?</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>оцінка пристосованості</mtext><mo>=</mo><mtext>відстань миші до сиру</mtext></mrow><annotation encoding="application/x-tex">\text{оцінка пристосованості} = \text{відстань миші до сиру}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">оцінка</span><span class="mord"> </span><span class="mord cyrillic_fallback">пристосованості</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">відстань</span><span class="mord"> </span><span class="mord cyrillic_fallback">миші</span><span class="mord"> </span><span class="mord cyrillic_fallback">до</span><span class="mord"> </span><span class="mord cyrillic_fallback">сиру</span></span></span></span></span></span></div>
<p>Розробка керованих комп’ютером гравців у грі також є поширеним сценарієм. Скажімо, ви програмуєте футбольну гру, у якій користувач є воротарем. Решта гравців керуються вашою програмою і мають набір параметрів, які визначають, як вони б’ють м’яч у напрямку воріт. Якою буде оцінка пристосованості для будь-якого гравця?</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>оцінка пристосованості</mtext><mo>=</mo><mtext>загальна кількість забитих голів</mtext></mrow><annotation encoding="application/x-tex">\text{оцінка пристосованості} = \text{загальна кількість забитих голів}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">оцінка</span><span class="mord"> </span><span class="mord cyrillic_fallback">пристосованості</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord cyrillic_fallback">загальна</span><span class="mord"> </span><span class="mord cyrillic_fallback">кількість</span><span class="mord"> </span><span class="mord cyrillic_fallback">забитих</span><span class="mord"> </span><span class="mord cyrillic_fallback">голів</span></span></span></span></span></span></div>
<p>Це, звичайно, спрощений погляд на гру у футбол, але він ілюструє суть. Чим більше голів забиває гравець, тим вище його оцінка пристосованості й тим більша ймовірність появи його генетичної інформації у наступній грі. Навіть із такою простою оцінювальною функцією, яка описана тут, цей сценарій демонструє дещо потужне — адаптивність системи. Якщо гравці продовжуватимуть розвиватися від гри до гри й коли новий користувач, <em>людина</em>, входить у гру з абсолютно іншою стратегією, то система швидко виявить, що оцінки пристосованості падають, і розробить нову оптимальну стратегію. Вона буде адаптуватися. (Не хвилюйтеся, небезпека того, що це призведе до появи розумних роботів-футболістів, які поневолять усіх людей, дуже мала.)</p>
<p>Зрештою, якщо у вас немає оцінювальної функції, яка б ефективно оцінювала продуктивність окремих елементів вашої популяції, у вас не буде еволюції. А ще оцінювальна функція з одного прикладу, швидше за все, не підійде до зовсім іншого проєкту. Інколи вам доведеться розробляти таку функцію з нуля, щоб вона підходила саме для вашого конкретного проєкту. А де це імплементувати? Все, що вам потрібно відредагувати, це кілька рядків коду всередині методу, який обчислює змінну <code>fitness</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  ????????????
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  ????????????
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = ??????????
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Заповнення цих знаків запитання — це та частина, де ви зможете проявити себе!</p>
<h3 id="key-3-the-genotype-and-phenotype"><a class="heading-link" href="#key-3-the-genotype-and-phenotype">Ключовий аспект 3: Генотип і фенотип</a></h3>
<p>Останній аспект розробки власного ГА стосується способу кодування властивостей вашої системи. Що ви намагаєтеся виразити і як перевести це у купу чисел? Що таке генотип і фено тип?</p>
<p>Я почав із прикладу з Шекспіром через легкість проєктування як його генотипу (набору символів), так і його вираження — фенотипу (рядку, зображеному на полотні). Однак це не завжди так легко. Наприклад, говорячи про оцінювальну функцію для футбольного матчу, я з радістю припустив існування керованих комп’ютером гравців, кожен з яких має “набір параметрів, які визначають, як вони б’ють м’яч у напрямку воріт”, але насправді визначення того, що це за параметри та спосіб їх кодування, потребує певних роздумів і творчості. І, звісно, тут немає однозначної правильної відповіді: ви самі вирішуєте, як розробляти систему.</p>
<p>Хороша новина, і я натякнув про це раніше в цьому розділі, полягає в тому, що ви весь час переводили генотипи (дані) у фенотипи (вираження). Щоразу, коли ви пишете клас у p5.js, ви створюєте цілу купу змінних:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span> = ????;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxforce</span> = ????;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = ????;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">separationWeight</span> = ????;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* та інші змінні... */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Усе, що вам потрібно зробити, щоб розвивати значення цих змінних, це перетворити їх у масив, щоб його можна було використовувати з усіма методами такими як <code>crossover()</code>, <code>mutate()</code> і їм подібними, що є у класі <code>DNA</code>. Одним із поширених рішень є використання масиву чисел із рухомою крапкою від 0 до 1:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p>Порожній масив.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Завжди обирається число від 0 до 1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зверніть увагу, що зараз я помістив необроблені генетичні дані (генотип) і їх вираження (фенотип) у два окремі класи. Клас <code>DNA</code> — це генотип — це просто набір чисел. Клас <code>Vehicle</code> — це фенотип — вираження того, як перетворити ці цифри в анімовану візуальну поведінку. Обидва класи можна зв’язати, включивши у клас <code>Vehicle</code> екземпляр <code>DNA</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>(<span class="hljs-number">4</span>);
</code></pre><div class="comment"><p>Об’єкт DNA, включений у клас Vehicle.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span> = dna.<span class="hljs-property">genes</span>[<span class="hljs-number">0</span>];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxforce</span> = dna.<span class="hljs-property">genes</span>[<span class="hljs-number">1</span>];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = dna.<span class="hljs-property">genes</span>[<span class="hljs-number">2</span>];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">separationWeight</span> = dna.<span class="hljs-property">genes</span>[<span class="hljs-number">3</span>];
</code></pre><div class="comment"><p>Використання генів для встановлення змінних.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* та інші змінні... */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Звісно, ви, ймовірно, не хочете, щоб усі ваші змінні мали діапазон від 0 до 1. Але замість того, щоб намагатися запам’ятати, як налаштувати ці діапазони в класі <code>DNA</code> , простіше витягнути вихідну генетичну інформацію з об’єкта <code>DNA</code>, а потім використати функцію <code>map()</code> із p5.js, щоб змінити діапазон відповідно до вашого фенотипу. Наприклад, якщо вам потрібна змінна <code>size</code> зі значенням від 10 до 72, ви б написали наступне:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-title function_">map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-property">genes</span>[<span class="hljs-number">2</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">72</span>);
</code></pre><div class="comment"><p></p></div></div></div>
<p>В інших випадках ви можете створити генотип, який є масивом об’єктів. Розглянемо конструкцію ракети з низкою двигунів. Ви можете розглядати кожен двигун як вектор, який описує його направлення і відносну силу:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p>Генотип — це масив векторів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">random2D</span>();
</code></pre><div class="comment"><p>Вектор, що вказує у випадковому напрямку.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i].<span class="hljs-title function_">mult</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">10</span>));
</code></pre><div class="comment"><p>І масштабується випадковим чином.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Фенотип — це клас <code>Rocket</code>, який бере участь у фізичній системі:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rocket</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span> = ????;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* та інші змінні... */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}  
</code></pre><div class="comment"><p></p></div></div></div>
<p>Що чудово в розділенні генотипу та фенотипу на окремі класи (наприклад, <code>DNA</code> і <code>Rocket</code>), так це те, що коли прийде час створювати весь код, ви помітите, що клас <code>DNA</code>, який я розробив раніше, залишається незмінним. Єдине, що змінюється це тип даних, які зберігаються у масиві (числа, вектори тощо), і вираження цих даних у класі фенотипу.</p>
<p>У наступному розділі я розвину цю ідею трохи далі й пройду  необхідні кроки для реалізації прикладу, який включає рухомі тіла та ДНК у вигляді масиву векторів.</p>
<h2 id="evolving-forces-smart-rockets"><a class="heading-link" href="#evolving-forces-smart-rockets">Еволюція сил: Розумні ракети</a></h2>
<p>Я згадав про ракети з певної причини: у 2009 році Джер Торп опублікував приклад ГА у своєму блозі під назвою “Розумні ракети”. Торп зазначив, що національне управління з аеронавтики та дослідження космічного простору (NASA) використовує еволюційні обчислювальні методи для розв&#x27;язання різноманітних проблем, від конструкції супутникової антени до моделей запуску ракет. Це надихнуло його створити flash-програму з демонстрацією еволюції ракет.</p>
<p>Ось сценарій: група ракет запускається знизу екрана з метою вразити ціль у верхній частині екрана. Наявні перешкоди блокують прямолінійний шлях до цілі (див. малюнок 9.9).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1224&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d03a6066439e9c8bcab268c8619995ae/e639a/09_ga_10.webp 576w,./static/d03a6066439e9c8bcab268c8619995ae/a6f01/09_ga_10.webp 1152w,./static/d03a6066439e9c8bcab268c8619995ae/ddeb8/09_ga_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/d03a6066439e9c8bcab268c8619995ae/50e75/09_ga_10.png" data-srcset="./static/d03a6066439e9c8bcab268c8619995ae/8d8ab/09_ga_10.png 576w,./static/d03a6066439e9c8bcab268c8619995ae/a056d/09_ga_10.png 1152w,./static/d03a6066439e9c8bcab268c8619995ae/50e75/09_ga_10.png 2304w" alt="Малюнок 9.9: Популяція розумних ракет шукає смачну полуничну планету"/></picture><noscript><picture><source type="image/webp" srcSet="./static/d03a6066439e9c8bcab268c8619995ae/e639a/09_ga_10.webp 576w,./static/d03a6066439e9c8bcab268c8619995ae/a6f01/09_ga_10.webp 1152w,./static/d03a6066439e9c8bcab268c8619995ae/ddeb8/09_ga_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/d03a6066439e9c8bcab268c8619995ae/50e75/09_ga_10.png" srcSet="./static/d03a6066439e9c8bcab268c8619995ae/8d8ab/09_ga_10.png 576w,./static/d03a6066439e9c8bcab268c8619995ae/a056d/09_ga_10.png 1152w,./static/d03a6066439e9c8bcab268c8619995ae/50e75/09_ga_10.png 2304w" alt="Малюнок 9.9: Популяція розумних ракет шукає смачну полуничну планету"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.9: Популяція розумних ракет шукає смачну полуничну планету</figcaption>
</figure>
<p>Кожна ракета оснащена п’ятьма двигунами різної сили й напрямку дії (малюнок 9.10). Двигуни не запускаються усі разом і не працюють безперервно, скоріше, вони спрацьовують по одному у певній послідовності.</p>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1031&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/0cadc61085f67cbb46df06a39a0f6a33/d9ef5/09_ga_11.webp 288w,./static/0cadc61085f67cbb46df06a39a0f6a33/091d4/09_ga_11.webp 576w,./static/0cadc61085f67cbb46df06a39a0f6a33/b57e5/09_ga_11.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/0cadc61085f67cbb46df06a39a0f6a33/a497f/09_ga_11.png" data-srcset="./static/0cadc61085f67cbb46df06a39a0f6a33/ad253/09_ga_11.png 288w,./static/0cadc61085f67cbb46df06a39a0f6a33/fb5b5/09_ga_11.png 576w,./static/0cadc61085f67cbb46df06a39a0f6a33/a497f/09_ga_11.png 1152w" alt="Малюнок 9.10: Одна розумна ракета з п’ятьма двигунами, що несе астронавта Клавдія"/></picture><noscript><picture><source type="image/webp" srcSet="./static/0cadc61085f67cbb46df06a39a0f6a33/d9ef5/09_ga_11.webp 288w,./static/0cadc61085f67cbb46df06a39a0f6a33/091d4/09_ga_11.webp 576w,./static/0cadc61085f67cbb46df06a39a0f6a33/b57e5/09_ga_11.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/0cadc61085f67cbb46df06a39a0f6a33/a497f/09_ga_11.png" srcSet="./static/0cadc61085f67cbb46df06a39a0f6a33/ad253/09_ga_11.png 288w,./static/0cadc61085f67cbb46df06a39a0f6a33/fb5b5/09_ga_11.png 576w,./static/0cadc61085f67cbb46df06a39a0f6a33/a497f/09_ga_11.png 1152w" alt="Малюнок 9.10: Одна розумна ракета з п’ятьма двигунами, що несе астронавта Клавдія"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 9.10: Одна розумна ракета з п’ятьма двигунами, що не се астронавта Клавдія</figcaption>
  </figure>
</div>
<p>У цій частині розділу я збираюся розробити власні спрощені розумні ракети, натхненні Торпом. Коли я дійду до кінця розділу, то залишу реалізацію деяких додаткових просунутих функцій Торпа як вправу.</p>
<p>Мої ракети матимуть лише один двигун, який зможе діяти в будь-якому напрямку з будь-якою силою для кожного кадру анімації. Це не дуже реалістично, але це полегшить створення прикладу. (Пізніше ви завжди зможете зробити ракету та її двигуни більш досконалими й реалістичними.)</p>
<h3 id="developing-the-rockets"><a class="heading-link" href="#developing-the-rockets">Розробка ракет</a></h3>
<p>Щоб імплементувати мою еволюцію розумних ракети, я почну з того, що візьму клас <code>Mover</code> з <a href="/forces#section-forces">Розділу 2</a> і перейменую його на <code>Rocket</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rocket</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-title function_">createVector</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p>Ракета має три вектори: положення, швидкість і прискорення.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">applyForce</span>(<span class="hljs-params">force</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span>.<span class="hljs-title function_">add</span>(force);
  }
</code></pre><div class="comment"><p>Акумулювання сили у прискорення (другий закон Ньютона).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Простий фізичний механізм (інтеграція Ейлера).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span>);
</code></pre><div class="comment"><p>Швидкість змінюється відповідно до прискорення.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>);
</code></pre><div class="comment"><p>Положення змінюється відповідно до швидкості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span>.<span class="hljs-title function_">mult</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>За допомогою цього класу я можу рухати ракету, викликаючи метод <code>applyForce()</code> з новою силою для кожного кадру анімації. Двигун прикладає до ракети єдину силу на кожен кадр анімації у функції <code>draw()</code>. Але на цьому етапі я ще далекий від завершення. Щоб зробити мої ракети “розумними” і розвинутими, мені потрібно подумати про три ключові аспекти програмування власного ГА, як описано в попередній частині розділу.</p>
<p><strong>Ключовий аспект 1</strong> полягає у визначенні правильних глобальних змінних для розміру популяції та частоти мутації. Наразі я не буду надто турбуватися про ці змінні й довільно виберу значення, що виглядають розумно — можливо, чисельність популяції у 50 ракет і рівень мутації у 1 відсоток. Щойно я побудую систему і запущу свою програму, я зможу експериментувати з цими цифрами.</p>
<p><strong>Ключовий аспект 2</strong> полягає у розробці відповідної функції, що оцінюватиме пристосованість. У цьому випадку метою ракети є досягнення цілі. Чим ближче ракета наближається до цілі, тим вище її пристосованість. Отже, рівень пристосованості обернено пропорційний відстані: чим менша відстань, тим більша пристосованість, а чим більша відстань, тим менша пристосованість.</p>
<p>Щоб застосувати це на практиці, мені спочатку потрібно додати до класу <code>Rocket</code> властивість <code>fitness</code> для збереження значення пристосованості:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rocket</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Ракета має оцінку пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Далі, мені потрібно додати до класу <code>Rocket</code> метод розрахунку пристосованості. Зрештою, тільки об’єкт <code>Rocket</code> знає, як обчислити свою відстань до цілі, тому функція пристосованості має жити у цьому класі. Припускаючи, що у мене є вектор <code>target</code>, я можу написати наступне:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, target);
</code></pre><div class="comment"><p>Як близько дісталася ракета?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">1</span> / distance;
</code></pre><div class="comment"><p>Пристосованість обернено пропорційна відстані.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Це, мабуть, найпростіша оцінювальна функція, яку я міг написати. При діленні <code>1</code> на відстань, великі відстані стають малими числами, а малі — стають великими. Якщо я хочу використати мій квадратичний трюк із попереднього розділу, то можу натомість поділити <code>1</code> на відстань у квадраті:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(position, target);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">1</span> / (distance * distance);
</code></pre><div class="comment"><p>1 поділена на квадрат відстані.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я хотів би зробити кілька додаткових покращень у функції оцінки пристосування, але це хороший початок.</p>
<p>Нарешті, <strong>ключовий аспект 3</strong> полягає в тому, щоб подумати про зв’язок між генотипом і фенотипом. Я заявляв, що кожна ракета має двигун, який діє у змінному напрямку зі змінною величиною — іншими словами є вектором! Таким чином, генотип — дані, необхідні для кодування поведінки ракети — є масивом векторів, по одному для кожного кадру анімації:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Радісна новина — у класі <code>DNA</code> мені нічого не потрібно дороблювати. Уся функціональність яка потрібна була для кота-друкаря (схрещення і мутація) тут також підходить. Єдина відмінність, яку я повинен враховувати, це те, як ініціалізувати масив генів. З друкарським котом я мав масив символів і вибирав випадковий символ для кожного елемента масиву. Тепер я зроблю те саме й ініціалізую послідовність ДНК як масив випадкових векторів.</p>
<p>Вашим інстинктивним бажанням, при створенні випадкового вектора, може бути наступний код:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> v = <span class="hljs-title function_">createVector</span>(<span class="hljs-title function_">random</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-title function_">random</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));
</code></pre><div class="comment"><p></p></div></div></div>
<p>Цей код ідеально підходить і, ймовірно, зробить свою справу. Однак, якщо я намалюю кожен можливий вектор такого підходу, то результат заповнить квадратний простір (див. малюнок 9.11, ліворуч). У цьому випадку це, мабуть, не має особливого впливу, але серед значень існує невелике упередження до діагональних напрямків, оскільки вектор від центру квадрата до кута довший за чисто вертикальний або горизонтальний напрямок.</p>
<figure>
  <div class="col-list">
    <div>
      <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;774.9999999999999&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/286071b6db7990eec4fb95544309b82f/e5022/09_ga_12.webp 288w,./static/286071b6db7990eec4fb95544309b82f/98c2b/09_ga_12.webp 576w,./static/286071b6db7990eec4fb95544309b82f/4666a/09_ga_12.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/286071b6db7990eec4fb95544309b82f/16549/09_ga_12.png" data-srcset="./static/286071b6db7990eec4fb95544309b82f/40e12/09_ga_12.png 288w,./static/286071b6db7990eec4fb95544309b82f/3248b/09_ga_12.png 576w,./static/286071b6db7990eec4fb95544309b82f/16549/09_ga_12.png 1152w" alt="Малюнок 9.11: Вектори, створені з випадковими x і y значеннями (зліва) з використанням p5.Vector.random2D() (праворуч)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/286071b6db7990eec4fb95544309b82f/e5022/09_ga_12.webp 288w,./static/286071b6db7990eec4fb95544309b82f/98c2b/09_ga_12.webp 576w,./static/286071b6db7990eec4fb95544309b82f/4666a/09_ga_12.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/286071b6db7990eec4fb95544309b82f/16549/09_ga_12.png" srcSet="./static/286071b6db7990eec4fb95544309b82f/40e12/09_ga_12.png 288w,./static/286071b6db7990eec4fb95544309b82f/3248b/09_ga_12.png 576w,./static/286071b6db7990eec4fb95544309b82f/16549/09_ga_12.png 1152w" alt="Малюнок 9.11: Вектори, створені з випадковими x і y значеннями (зліва) з використанням p5.Vector.random2D() (праворуч)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    </div>
    <div>
      <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;774.9999999999999&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/c210f606e9365b03c1b30f6b09edd0bf/e5022/09_ga_13.webp 288w,./static/c210f606e9365b03c1b30f6b09edd0bf/98c2b/09_ga_13.webp 576w,./static/c210f606e9365b03c1b30f6b09edd0bf/4666a/09_ga_13.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/c210f606e9365b03c1b30f6b09edd0bf/16549/09_ga_13.png" data-srcset="./static/c210f606e9365b03c1b30f6b09edd0bf/40e12/09_ga_13.png 288w,./static/c210f606e9365b03c1b30f6b09edd0bf/3248b/09_ga_13.png 576w,./static/c210f606e9365b03c1b30f6b09edd0bf/16549/09_ga_13.png 1152w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/c210f606e9365b03c1b30f6b09edd0bf/e5022/09_ga_13.webp 288w,./static/c210f606e9365b03c1b30f6b09edd0bf/98c2b/09_ga_13.webp 576w,./static/c210f606e9365b03c1b30f6b09edd0bf/4666a/09_ga_13.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/c210f606e9365b03c1b30f6b09edd0bf/16549/09_ga_13.png" srcSet="./static/c210f606e9365b03c1b30f6b09edd0bf/40e12/09_ga_13.png 288w,./static/c210f606e9365b03c1b30f6b09edd0bf/3248b/09_ga_13.png 576w,./static/c210f606e9365b03c1b30f6b09edd0bf/16549/09_ga_13.png 1152w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    </div>
  </div>
  <figcaption>Малюнок 9.11: Вектори, створені з випадковими <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> значеннями (зліва) та з використанням <code>p5.Vector.random2D()</code> (праворуч)</figcaption>
</figure>
<p>Як ви пам’ятаєте з <a href="/oscillation#section-oscillation">Розділу 3</a>, кращим варіантом буде вибрати випадковий кут і створити з нього одиничний вектор з довжиною 1. Це продукує результати, які утворюють кругле поле векторних значень (див. праву частину малюнку 9.11) і їх можна досягти за допомогою полярного підходу створення координат за допомогою методу <code>p5.Vector.random2D()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">random2D</span>();
</code></pre><div class="comment"><p>Випадковий одиничний вектор.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Вектор з довжиною 1 насправді створить досить велику силу. Пам’ятайте, що сили застосовуються до прискорення, яке акумулюється у швидкості від 30 разів на секунду (або залежно від налаштованої частоти кадрів). Тому для цього прикладу я додам до класу <code>DNA</code> ще одну змінну, максимальну силу, і випадковим чином масштабую всі вектори, щоб значення були десь між 0 і максимумом. Це контролюватиме потужність двигуна:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
</code></pre><div class="comment"><p>Генетична послідовність — це масив векторів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxForce</span> = <span class="hljs-number">0.1</span>;
</code></pre><div class="comment"><p>Наскільки потужними можуть бути двигуни?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lifeSpan; i++) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">random2D</span>();
</code></pre><div class="comment"><p>Зауважте, що довжина генів дорівнює глобальній змінній lifeSpan.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i].<span class="hljs-title function_">mult</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">0</span>, maxforce));
</code></pre><div class="comment"><p>Масштабування векторів випадковим чином, але не більше максимальної сили.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Зверніть увагу, що я використовую змінну <code>lifeSpan</code> для встановлення довжини масиву векторів <code>genes</code>. Ця глобальна змінна зберігає загальну кількість кадрів у життєвому циклі кожного покоління, що дозволяє мені створити вектор для кожного кадру ракетного буття.</p>
<p>Вираження цього масиву векторів, його фенотипом, є мій клас <code>Rocket</code>. Щоб закріпити зв’язок, мені потрібно додати до класу екземпляр об’єкта <code>DNA</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rocket</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, dna</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span> = dna;
</code></pre><div class="comment"><p>Ракета має ДНК.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Ракета має значення пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Для чого я використовую <code>this.dna</code>? Коли ракета запускається, вона проходить крізь ряд вектор ів і застосовує їх один за одним як силу. Для досягнення цього, мені потрібно включити до класу змінну <code>this.geneCounter</code>, яка допоможе проходити через масив:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rocket</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, dna</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span> = dna;
</code></pre><div class="comment"><p>Ракета має ДНК.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Ракета має значення пристосованості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">geneCounter</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Лічильник для масиву генів ДНК.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">applyForce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-property">genes</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">geneCounter</span>]);
</code></pre><div class="comment"><p>Застосування сили з масиву генів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">geneCounter</span>++;
</code></pre><div class="comment"><p>Перехід до наступної сили у масиві генів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p>Оновлення фізики ракети.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер у мене є клас <code>DNA</code> (генотип) і клас <code>Rocket</code> (фенотип). Останній шматочок головоломки — це механізм управління популяцією ракет і здійснення селекції та відтворення.</p>
<h3 id="managing-the-population"><a class="heading-link" href="#managing-the-population">Управління популяцією</a></h3>
<p>Щоб файл <em>sketch.js</em> був більш охайним, я додам у класі <code>Population</code> код для керування масивом об’єктів <code>Rocket</code>. Як і у випадку з класом <code>DNA</code>, хорошою новиною є те, що мені майже нічого не потрібно змінювати з прикладу котів-друкарів. Я просто організую код у більш об’єктно-орієнтований спосіб з методами <code>selection()</code> і <code>reproduction()</code>. Щоб продемонструвати інший підхід, я також нормалізую значення пристосованості у методі <code>selection()</code> і використаю алгоритм зваженого відбору (естафету) у методі <code>reproduction()</code>. Це усуває потребу в окремому масиві шлюбних пулів. Код методу <code>weightedSelection()</code> такий самий, як і написаний раніше у цьому розділі:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Population</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">mutation, length</span>) {
</code></pre><div class="comment"><p>Популяція має змінні для частоти мутації,
поточного масиву популяції й кількості поколінь.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mutationRate</span> = mutation;
</code></pre><div class="comment"><p>Частота мутацій.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span> = [];
</code></pre><div class="comment"><p>Масив для поточної популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">generations</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Кількість поколінь.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rocket</span>(<span class="hljs-number">320</span>, <span class="hljs-number">220</span>, <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>());
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">fitness</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> rocket <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>) {
      rocket.<span class="hljs-title function_">calculateFitness</span>();
    }
  }
</code></pre><div class="comment"><p>Розрахунок пристосованості кожної ракети.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">selection</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Метод відбору нормалізує всі значення пристосованості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> totalFitness = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> rocket <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>) {
      totalFitness += rocket.<span class="hljs-property">fitness</span>;
    }
</code></pre><div class="comment"><p>Підсумування всіх значень пристосованості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> rocket <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>) {
      rocket.<span class="hljs-property">fitness</span> /= totalFitness;
    }
</code></pre><div class="comment"><p>Поділ поточної оцінки на загальну суму для нормалізації значення пристосованості.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">reproduction</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> newPopulation = [];
</code></pre><div class="comment"><p>Окремий масив для наступного покоління.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> parentA = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">weightedSelection</span>();
      <span class="hljs-keyword">let</span> parentB = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">weightedSelection</span>();
</code></pre><div class="comment"><p>Використання алгоритму зваженого відбору.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> child = parentA.<span class="hljs-title function_">crossover</span>(parentB);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      child.<span class="hljs-title function_">mutate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">mutationRate</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      newPopulation[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rocket</span>(<span class="hljs-number">320</span>, <span class="hljs-number">240</span>, child);
</code></pre><div class="comment"><p>Нова ракета для нового покоління.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span> = newPopulation;
</code></pre><div class="comment"><p>У кінці нова популяція стає поточною.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Однак мені потрібно внести ще одну досить важливу зміну. З котами, що друкують, випадкова фраза оцінювалася, як тільки вона була створена. Рядок символів н е мав тривалості життя, він існував виключно з метою обчислення його пристосованості. Однак ракетам потрібно проіснувати певний період часу, перш ніж їх можна буде оцінити, тобто їм потрібно дати шанс зробити спробу досягти ціль. Тому мені потрібно додати ще один метод до класу <code>Population</code>, який запускає симуляцію фізики. Це ідентично тому, що я робив у методі <code>run()</code> системи частинок — оновлення позиції всіх частинок і їх малювання:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">live</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> rocket <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      rocket.<span class="hljs-title function_">run</span>();
</code></pre><div class="comment"><p>Метод run() виконує симуляцію, оновлює положення ракети
і малює її на полотні.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Нарешті я готовий до функцій <code>setup()</code> і <code>draw()</code>. Тут моя основна відповідальність полягає в тому, щоб реалізувати кроки ГА у відповідному порядку, викликаючи методи з класу <code>Population</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">    population.<span class="hljs-title function_">fitness</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    population.<span class="hljs-title function_">selection</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    population.<span class="hljs-title function_">reproduction</span>();
</code></pre><div class="comment"><p></p></div></div></div>
<p>Однак, на відміну від прикладу з Шекспіром, я не хочу робити це для кожного кадру. Скоріше мої кроки працюють наступним чином:</p>
<ol>
  <li>Створення популяції ракет.</li>
  <li>Нехай ракети живуть <em>N</em> кадрів.</li>
  <li>Розвиток наступного покоління:
    <ul>
      <li>Відбір</li>
      <li>Відтворення</li>
    </ul>
  </li>
  <li>Повернення до кроку 2.</li>
</ol>
<p>Щоб знати, коли переходити від кроку 2 до кроку 3, мені потрібна змінна <code>lifeCounter</code>, яка відстежуватиме прогрес поточного покоління разом зі змінно <code>lifeSpan</code>. У функцій <code>draw()</code>, поки значення <code>lifeCounter</code> менше ніж <code>lifeSpan</code>, для запуску моделювання популяції викликається метод <code>live()</code>. Коли значення <code>lifeCounter</code> досягне значення <code>lifeSpan</code>, настане час виконання методів для розвитку нового покоління <code>fitness()</code>, <code>selection()</code> і <code>reproduction()</code>.</p>
<div data-type="example">
  <h3 id="example-92-smart-rockets"><a class="heading-link" href="#example-92-smart-rockets">Приклад 9.2: Розумні ракети</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/09_ga/9_2_smart_rockets_basic"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/jzfy_9p1ES" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> lifeSpan = <span class="hljs-number">500</span>;
</code></pre><div class="comment"><p>Кількість кадрів для тривалості життя покоління.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> lifeCounter = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Лічильник пройдених кадрів життя.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> population;
</code></pre><div class="comment"><p>Популяція.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  population = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Population</span>(<span class="hljs-number">0.01</span>, <span class="hljs-number">50</span>);
</code></pre><div class="comment"><p>Крок 1: створення популяції. Спробуйте різні значення
для частоти мутацій і розміру популяції.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (lifeCounter &lt; lifeSpan) {
</code></pre><div class="comment"><p>Умова ГА.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    population.<span class="hljs-title function_">live</span>();
    lifeCounter++;
</code></pre><div class="comment"><p>Крок 2: ракети живуть своїм життям, доки значення lifeCounter менше ніж lifeSpan.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    lifeCounter = <span class="hljs-number">0</span>;
    population.<span class="hljs-title function_">fitness</span>();
    population.<span class="hljs-title function_">selection</span>();
    population.<span class="hljs-title function_">reproduction</span>();
</code></pre><div class="comment"><p>Коли життя добігло кінця, значення lifeCounter обнуляється і розвивається
наступне покоління (кроки 3 і 4, відбір і відтворення).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mousePressed</span>(<span class="hljs-params"></span>) {
  target.<span class="hljs-property">x</span> = mouseX;
  target.<span class="hljs-property">y</span> = mouseY;
}
</code></pre><div class="comment"><p>Переміщення цілі після клацання мишкою. Ракети будуть адаптуватися до нової цілі.</p></div></div></div>
<p>У нижній частині коду ви побачите, що я додав нову функцію: коли клацнути мишкою, положення цілі переміщується до координат курсора. Ця зміна дозволяє спостерігати за тим, як ракети адаптуються і коригують свої траєкторії до нової цілі, оскільки система постійно змінюється у режимі реального часу.</p>
<h3 id="making-improvements"><a class="heading-link" href="#making-improvements">Внесення покращень</a></h3>
<p>Мої розумні ракети працюють, але поки що не дуже захопливо. Зрештою, ракети просто еволюціонують до отримання ДНК із купою векторів, які вказують прямо на ціль. Щоб зробити приклад цікавішим, я збираюся запропонувати два вдосконалення. Для початку, коли я вперше описав сценарій розумної ракети, я сказав, що ракети повинні розвинути здатність уникнення перешкод. Додавання цієї функціональності зробить систему складнішою й ефективніше продемонструє потужність еволюційного алгоритму.</p>
<p>Щоб розвинути уникнення перешкод, мені потрібна для цього наявність якихось перешкод. Я можу легко створити прямокутні нерухомі перешкоди, реалізувавши клас об’єктів типу <code>Obstacle</code>, які зберігатимуть своє положення і розміри:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obstacle</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, w, h</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = w;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span> = h;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Я додам до класу <code>Obstacle</code> метод <code>contains()</code>, який повертатиме <code>true</code>, якщо ракета влучила у перешкоду, або <code>false</code> — у протилежному випадку:</p>
<div class="snip-below snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">contains</span>(<span class="hljs-params">spot</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> (
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      spot.<span class="hljs-property">x</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> &amp;&amp;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      spot.<span class="hljs-property">x</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> &amp;&amp;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      spot.<span class="hljs-property">y</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> &amp;&amp;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      spot.<span class="hljs-property">y</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    );
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Якщо я створю масив об’єктів <code>Obstacle</code>, то зможу перевірити кожну ракету, чи не зіткнулася вона з якоюсь із перешкод. Якщо відбудеться зіткнення, то ракета змінить свою булеву змінну <code>hitObstacle</code> на <code>true</code>. Щоб досягти цього, мені потрібно додати відповідний метод до класу <code>Rocket</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">checkObstacles</span>(<span class="hljs-params">obstacles</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> obstacle <span class="hljs-keyword">of</span> obstacles) {
      <span class="hljs-keyword">if</span> (obstacle.<span class="hljs-title function_">contains</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>)) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hitObstacle</span> = <span class="hljs-literal">true</span>;
      }
    }
  }
</code></pre><div class="comment"><p>Цей новий метод знаходиться в класі Rocket і перевіряє
чи ракета зіткнулася із перешкодою.</p></div></div></div>
<p>Якщо ракета вдариться у перешкоду, я зупиню ракету від оновлення свого положення. Оновлений метод <code>run()</code> тепер отримує як аргумент масив <code>obstacles</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">run</span>(<span class="hljs-params">obstacles</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">hitObstacle</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">applyForce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-property">genes</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">geneCounter</span>]);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">geneCounter</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">geneCounter</span> + <span class="hljs-number">1</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p>Якщо ракета зіткнулася з перешкодою, зупиняємо її.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">checkObstacles</span>(obstacles);
</code></pre><div class="comment"><p>Перевіримо, чи не врізалася ракета у перешкоду.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Також у мене є можливість налаштувати пристосованість ракети. Якщо ракета вдаряється у перешкоду, оцінка пристосованості повинна скорегуватися і стати значно зменшеною:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, target);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">1</span> / (distance * distance);
</code></pre><div class="comment"><p></p></div></div><div class="bold pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">hitObstacle</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> *= <span class="hljs-number">0.1</span>;
    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>При цьому ракети мають можливість розвиватися для уникнення перешкод. Але я не зупинюся на цьому. Я хочу зробити ще одне покращення.</p>
<p>Якщо ви уважно подивитеся на приклад 9.2, то помітите, що ракети не отримують винагороди за те, що вони швидше досягають цілі. Єдиною змінною у розрахунку пристосованості є відстань до цілі в кінці життя покоління. Насправді якщо ракета наближається до цілі дуже близько, але перестрибує її та пролітає повз, вона може бути покарана за те, що досягла ціль швидше. У цьому випадку перегони виграє повільність і стабільність.</p>
<p>Я міг би покращити алгоритм к ількома способами, щоб оптимізувати швидкість досягнення мети. По-перше, я міг би розрахувати пристосованість ракети на основі того, як вона наближається до цілі у будь-який момент свого життя, замість того, щоб використовувати її відстань до цілі у кінці покоління. Я створю для цього нову змінну <code>recordDistance</code> і буду оновлювати її у методі <code>checkTarget()</code> класу <code>Rocket</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">checkTarget</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, target);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (distance &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">recordDistance</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">recordDistance</span> = distance;
    }
</code></pre><div class="comment"><p>Перевірка чи відстань менша за мінімально зафіксовану. Якщо так, то встановлюється нове значення.</p></div></div></div>
</div>
<p>Крім того, ракета заслуговує винагороди залежно від швидкості, з якою вона досягає ціль. Для цього мені потрібен спосіб дізнатися, коли ракета влучила у ціль. Фактично, у мене вже є один: у класі <code>Obstacle</code> є метод <code>contains()</code>, оскільки ціль також може буде реалізована як своєрідна перешкода. Це просто перешкода, яку ракета <em>хоче</em> вразити! Я можу використовувати метод <code>contains()</code>, щоб встановити нову змінну <code>hitTarget</code> у кожному об’єкті <code>Rocket</code>. Якщо ракета потрапить у ціль, то зупиниться так само як вона зупиняється, коли потрапляє у перешкоду:</p>
<div class="snip-above snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">contains</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">hitTarget</span> = <span class="hljs-literal">true</span>;
    }
</code></pre><div class="comment"><p>Якщо об’єкт досягає цілі, для логічної змінної hitTarget встановлюється значення true.</p></div></div></div>
</div>
<p>Пам’ятайте, що я також хочу, щоб ракета мала тим вищу пристосованість, чим швидше вона досягає цілі. І навпаки, чим повільніше вона досягає цілі, тим нижчий її показник пристосованості. Щоб в провадити це, змінну <code>finishCounter</code> можна збільшувати кожен цикл життя ракети, поки вона не досягне цілі. Після закінчення життя популяції лічильник дорівнюватиме часу за який ракета досягла цілі:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">hitTarget</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishCounter</span>++;
    }
  }
</code></pre><div class="comment"><p>Збільшування finishCounter, поки ракета не влучила в ціль.</p></div></div></div>
</div>
<p>Я хочу, щоб пристосованість також була обернено пропорційною до значення <code>finishCounter</code>. Щоб досягти цього, я можу покращити оцінювальну функцію за допомогою наступних змін:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">calculateFitness</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">1</span> / (<span class="hljs-variable language_">this</span>.<span class="hljs-property">finishTime</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">recordDistance</span>);
</code></pre><div class="comment"><p>Винагородження за швидше фінішування і наближення.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-title function_">pow</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span>, <span class="hljs-number">4</span>);
</code></pre><div class="comment"><p>Спробуємо звести значення до 4-го степеня, а не до квадрата!</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">hitObstacle</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> *= <span class="hljs-number">0.1</span>;
    }
</code></pre><div class="comment"><p>При зіткненні з перешкодою втрачається 90% пристосованості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">hitTarget</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> *= <span class="hljs-number">2</span>;
    }
</code></pre><div class="comment"><p>Подвоєння оцінки пристосованості за досягнення цілі!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Обидва вдосконалення включено в код прикладу 9.3.</p>
<div data-type="example">
  <h3 id="example-93-smarter-rockets"><a class="heading-link" href="#example-93-smarter-rockets">Приклад 9.3: Розумніші ракети</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/09_ga/9_3_smart_rockets"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/565K_KXSA" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<p> Цей приклад можна покращити й розширити багатьма способами. Наступні вправи пропонують ідеї та завдання для глибшого дослідження ГА. Подумайте що ще ви можете спробувати?</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-99"><a class="heading-link" href="#exercise-99">Вправа 9.9</a></h3>
  <p>Створіть складнішу смугу перешкод. Оскільки ви ускладнюєте ракетам досягнення цілі, чи потрібно покращувати інші аспекти ГА, наприклад, функцію пристосованості?</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-910"><a class="heading-link" href="#exercise-910">Вправа 9.10</a></h3>
  <p>Реалізуйте модель пострілів оригінальних розумних ракет Торпа. Кожна ракета має лише п’ять двигунів (будь-якого напрямку та сили), які виконують послідовність включення (довільної тривалості). Симуляція Торпа також дає ракетам скінченну кількість палива.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-911"><a class="heading-link" href="#exercise-911">Вправа 9.11</a></h3>
  <p>Візуалізуйте симуляцію інакше. Чи можете ви намалювати лінію для найкоротшого шляху до цілі? Чи можете ви намалювати ракети цікавіше? А як щодо додавання систем частинок, які рухаються як дим у напрямку дії ракетних двигунів?</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-912"><a class="heading-link" href="#exercise-912">Вправа 9.12</a></h3>
  <p>Ще один спосіб навчити ракету досягати ціль — це розвивати поле потоків. Чи можете ви зробити генотип ракети як векторне поле?</p>
</div>
<h2 id="interactive-selection"><a class="heading-link" href="#interactive-selection">Інтерактивний відбір</a></h2>
<p>Карл Сімс — дослідник комп’ютерної графіки й візуальний художник, який багато працював із ГА-мами. Він також добре відомий своєю роботою з системами частинок! Одним із його інноваційних еволюційних проєктів є музейна інсталяція “<em>Galapagos</em>”. Початково ця інсталяція була встановлена в NTT InterCommunication Center в Токіо у 1997 році. Вона складається з 12 моніторів на яких відображаються комп’ютерні зображення. Ці зображення розвиваються з часом, дотримуючись кроків ГА відбору і відтворення.</p>
<p>Інновація тут полягає не у використанні ГА, а скоріше у стратегії функції оцінювання пристосованості. Перед кожним монітором на підлозі розташований датчик, який може визначити присутність відвідувача, який дивиться на екран. Придатність зображення пов’язана з тривалістю часу, протягом якого глядачі дивляться на зображення. Цей підхід відомий як <strong>інтерактивний відбір</strong> — ГА зі значеннями пристосованості, які призначають люди.</p>
<p>Інтерактивний відбір не обмежується мистецькими інсталяціями, а досить поширений у цифрову епоху оцінок і оглядів, створених користувачами. Чи можете ви уявити собі створення ідеальної пісні на основі ваших рейтингів у Spotify? Чи ідеальної книги за відгуками з Goodreads? Проте, дотримуючись природної теми книги, я проілюструю, як працює інтерактивний відбір, використовуючи популяцію цифрових квітів, як на малюнку 9.12.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1221&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/34e27892f28a00169257cc2387ff779d/b562b/09_ga_14.webp 576w,./static/34e27892f28a00169257cc2387ff779d/90be3/09_ga_14.webp 1152w,./static/34e27892f28a00169257cc2387ff779d/6b268/09_ga_14.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/34e27892f28a00169257cc2387ff779d/acacb/09_ga_14.png" data-srcset="./static/34e27892f28a00169257cc2387ff779d/702fe/09_ga_14.png 576w,./static/34e27892f28a00169257cc2387ff779d/94dd9/09_ga_14.png 1152w,./static/34e27892f28a00169257cc2387ff779d/acacb/09_ga_14.png 2304w" alt="Малюнок 9.12: Квітковий дизайн для інтерактивного відбору"/></picture><noscript><picture><source type="image/webp" srcSet="./static/34e27892f28a00169257cc2387ff779d/b562b/09_ga_14.webp 576w,./static/34e27892f28a00169257cc2387ff779d/90be3/09_ga_14.webp 1152w,./static/34e27892f28a00169257cc2387ff779d/6b268/09_ga_14.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/34e27892f28a00169257cc2387ff779d/acacb/09_ga_14.png" srcSet="./static/34e27892f28a00169257cc2387ff779d/702fe/09_ga_14.png 576w,./static/34e27892f28a00169257cc2387ff779d/94dd9/09_ga_14.png 1152w,./static/34e27892f28a00169257cc2387ff779d/acacb/09_ga_14.png 2304w" alt="Малюнок 9.12: Квітковий дизайн для інтерактивного відбору"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 9.12: Квітковий дизайн для інтерактивного відбору</figcaption>
</figure>
<p>Кожна квітка матиме набір властивостей: колір пелюстки, розмір пелюстки, кількі сть пелюсток, колір серцевинки, розмір серцевинки, довжину стебла і колір стебла. ДНК квітки (генотип) — це масив десяткових чисел від 0 до 1, з окремим значенням для кожної властивості:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++) {
</code></pre><div class="comment"><p>Генетична послідовність (14 властивостей для кожної квітки).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">random</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Кожен ген є випадковим значенням з рухомою крапкою від 0 до 1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Фенотип — це клас <code>Flower</code>, який включає екземпляр об’єкта <code>DNA</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flower</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">dna</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span> = dna;
</code></pre><div class="comment"><p>ДНК квітки.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">1</span>;
</code></pre><div class="comment"><p>Наскільки придатна ця квітка?</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Коли прийде час малювати квітку, я скористаюся функцією <code>map()</code> із p5.js, щоб перетворити будь-яке значення гена у відповідний діапазон розмірів у пікселях або значення кольору. (Я також використовую функцію <code>colorMode(RGB, 1)</code>, щоб встановити діапазон RGB значень від 0 до 1.)</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="offset-top pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> genes = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-property">genes</span>;
</code></pre><div class="comment"><p>Значення ДНК призначаються властивостям квітки,
таким як колір пелюсток, розмір пелюсток і кількість пелюсток.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> petalColor  = <span class="hljs-title function_">color</span>(genes[<span class="hljs-number">0</span>], genes[<span class="hljs-number">1</span>], genes[<span class="hljs-number">2</span>], genes[<span class="hljs-number">3</span>]);
    <span class="hljs-keyword">let</span> petalSize   = <span class="hljs-title function_">map</span>(genes[<span class="hljs-number">4</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">24</span>);
    <span class="hljs-keyword">let</span> petalCount  = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">map</span>(genes[<span class="hljs-number">5</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">16</span>));
    <span class="hljs-keyword">let</span> centerColor = <span class="hljs-title function_">color</span>(genes[<span class="hljs-number">6</span>], genes[<span class="hljs-number">7</span>], genes[<span class="hljs-number">8</span>]);
    <span class="hljs-keyword">let</span> centerSize  = <span class="hljs-title function_">map</span>(genes[<span class="hljs-number">9</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">24</span>, <span class="hljs-number">48</span>);
    <span class="hljs-keyword">let</span> stemColor   = <span class="hljs-title function_">color</span>(genes[<span class="hljs-number">10</span>], genes[<span class="hljs-number">11</span>], genes[<span class="hljs-number">12</span>]);
    <span class="hljs-keyword">let</span> stemLength  = <span class="hljs-title function_">map</span>(genes[<span class="hljs-number">13</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>); 
</code></pre><div class="comment"><p>Я встановив діапазон RGB значень від 0 до 1 за допомогою функції colorMode() і використовую функцію map() де потрібно для малювання.</p></div></div></div>
</div>
<p>До цього моменту я не зробив нічого нового. Це той самий процес, який я використовував у кожному прикладі ГА. Різниця полягає в тому, що я не збираюся писати функцію <code>fitness()</code> для обчислення оцінки придатності на основі математичної формули. Натомість я попрошу призначити придатність у користувача.</p>
<p>Спосіб, як саме попросити користувача призначити придатність, найкраще розглядати як дизайн-проблему взаємодії, і це насправді не входить до сфери цієї книги. Я не збираюся розпочинати докладну дискусію про те, як запрограмувати повзунки чи створити власні апаратні циферблати або вебпрограму, яка дозволить людям виставляти результати онлайн. Спосіб отримання показників для оцінки придатності залежить від вас і конкретної програми, яку ви розробляєте. Для цієї демонстрації я буду надихатися інсталяцією <em>Galapagos</em> і просто збільшуватиму значення придатності квітки щоразу, коли на неї буде наведено курсор. А після натискання на кнопку <code>Evolve Next Generation</code> буде створюватися наступне покоління квітів.</p>
<p>Подивіться, як етапи ГА — відбір і відтворення — застосовуються у функції <code>nextGeneration()</code>, яка запускається подією <code>mousePressed()</code>, яку під’єднано до елементу <code>button</code>. Придатність підвищується у методі <code>rollover()</code> з класу <code>Population</code>. Метод виявляє присутність курсора над будь-якою квіткою. Ви можете знайти докладнішу інформацію про програму у супровідному прикладі коду на вебсайті книги.</p>
<div data-type="example">
  <h3 id="example-94-interactive-selection"><a class="heading-link" href="#example-94-interactive-selection">Приклад 9.4: Інтерактивний відбір</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/09_ga/9_4_interactive_selection"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/dUeAaapkQ" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> population;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">colorMode</span>(<span class="hljs-variable constant_">RGB</span>, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> populationSize = <span class="hljs-number">8</span>;
</code></pre><div class="comment"><p>Це дуже мала популяція!</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> mutationRate = <span class="hljs-number">0.05</span>;
</code></pre><div class="comment"><p>Тут досить високий рівень мутацій. Оскільки популяція досить невелика, нам потрібно посилювати різноманітність.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  population = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Population</span>(mutationRate, populationSize);
</code></pre><div class="comment"><p>Створення популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  button = <span class="hljs-title function_">createButton</span>(<span class="hljs-string">&quot;evolve new generation&quot;</span>);
  button.<span class="hljs-title function_">mousePressed</span>(nextGeneration);
  button.<span class="hljs-title function_">position</span>(<span class="hljs-number">10</span>, <span class="hljs-number">210</span>);
</code></pre><div class="comment"><p>Створення кнопки за допомоги p5.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  population.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Малювання квіток.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  population.<span class="hljs-title function_">rollover</span>(mouseX, mouseY);
  <span class="hljs-title function_">textAlign</span>(<span class="hljs-variable constant_">LEFT</span>);
  <span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;Generation &quot;</span> + population.<span class="hljs-property">generations</span>, <span class="hljs-number">12</span>, height - <span class="hljs-number">40</span>);
</code></pre><div class="comment"><p>Перевірка потреби підвищення оцінки придатності.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextGeneration</span>(<span class="hljs-params"></span>) {
  population.<span class="hljs-title function_">selection</span>();
  population.<span class="hljs-title function_">reproduction</span>();
}
</code></pre><div class="comment"><p>Якщо кнопку натиснуто, формується наступне покоління.</p></div></div></div>
<p>Цей приклад є лише демонстрацією ідеї інтерактивного відбору й не забезпечує особливо значущого результату. По-перше, я не приділяв особливої уваги візуальному вигляду квітів — це лише кілька простих форм різних розмірів і кольорів. (Подивіться, чи можете ви помітити використання полярних координат у коді?) Сімс використовував складніші математичні функції для генотипу своїх зображень. Ви також можете розглянути векторний підхід, у якому генотип дизайну є набором точок або шляхів.</p>
<p>Однак більш важливою проблемою тут є проблема часу. У природному світі еволюція відбувається протягом мільйонів років. У світі комп’ютерного моделювання перших прикладів цього розділу популяції здатні розвивати свою поведінку відносно швидко, оскільки нові покоління продукуються алгоритмічно. У прик ладі з котами, що друкують, нове покоління народжується у кожному запуску функції <code>draw()</code> (приблизно 60 разів на секунду). Кожне покоління інтелектуальних ракет має термін життя 250 кадрів — це все лише мить ока у порівнянні з еволюційним часом. Однак у випадку інтерактивного відбору вам доведеться сидіти й чекати, поки хтось оцінить кожен елемент популяції, перш ніж ви зможете перейти до наступного покоління. Оцінка великої популяції була б невиправдано виснажливою для користувача — не кажучи вже про те, скільки поколінь ви могли б витримати?</p>
<p>Ви, звичайно, можете обійти цю проблему розумними способами. Виставка Сімса “<em>Galapagos</em>” приховала процес оцінювання від глядачів, оскільки це відбувалося через звичайну поведінку перегляду творів мистецтва у галереї. Створення вебдодатку, який дозволить багатьом людям розподілено оцінювати сукупність, також є хорошою стратегією для швидкого досягнення потрібних оцінок великих популяцій.</p>
<p>Зрештою, ключ до успішної інтерактивної системи відбору зводиться до тих самих аспектів, які були встановлені раніше. Що таке генотип і фенотип? І як ви обчислюєте оцінку пристосованості або, у цьому випадку, яка ваша стратегія визначення придатності відповідно до взаємодії з користувачем?</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-913"><a class="heading-link" href="#exercise-913">Вправа 9.13</a></h3>
  <p>Створіть власний інтерактивний проєкт відбору. На додаток до візуального дизайну, розгляньте еволюцію звуків, наприклад, коротку послідовність тонів. Чи можете ви розробити стратегію, таку як вебпрограма або фізична сенсорна система, щоб з часом отримати оцінки від багатьох людей?</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-914"><a class="heading-link" href="#exercise-914">Вправа 9.14</a></h3>
  <p>Ще одною з основоположних робіт Карла Сімса в галузі ГА-мів є “Evolved Virtual Creatures”. У цьому проєкті популяція цифрових істот у змодельованому фізичному середовищі оцінюється на предмет їх здатності виконувати такі завдання, як плавання, біг, стрибки, слідування і змагання з кубика рубіка. У проєкті використовується генотип на основі вузлів: ДНК істоти — це не лінійний список векторів чи чисел, а карта вузлів (дуже подібно до симуляції м’якого тіла з <a href="/physics-libraries#section-physics-libraries">Розділу 6</a>). Фенотип — це саме тіло істоти, мережа кінцівок, з’єднаних м’язами.</p>
  <div class="half-width-right">
    <figure>
      <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1647&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/7a00db17c60cfa814608c85325c8eeeb/49247/09_ga_15.webp 576w,./static/7a00db17c60cfa814608c85325c8eeeb/9340a/09_ga_15.webp 1152w,./static/7a00db17c60cfa814608c85325c8eeeb/37c28/09_ga_15.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/7a00db17c60cfa814608c85325c8eeeb/71cd9/09_ga_15.png" data-srcset="./static/7a00db17c60cfa814608c85325c8eeeb/a4b6e/09_ga_15.png 576w,./static/7a00db17c60cfa814608c85325c8eeeb/bc6fc/09_ga_15.png 1152w,./static/7a00db17c60cfa814608c85325c8eeeb/71cd9/09_ga_15.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/7a00db17c60cfa814608c85325c8eeeb/49247/09_ga_15.webp 576w,./static/7a00db17c60cfa814608c85325c8eeeb/9340a/09_ga_15.webp 1152w,./static/7a00db17c60cfa814608c85325c8eeeb/37c28/09_ga_15.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/7a00db17c60cfa814608c85325c8eeeb/71cd9/09_ga_15.png" srcSet="./static/7a00db17c60cfa814608c85325c8eeeb/a4b6e/09_ga_15.png 576w,./static/7a00db17c60cfa814608c85325c8eeeb/bc6fc/09_ga_15.png 1152w,./static/7a00db17c60cfa814608c85325c8eeeb/71cd9/09_ga_15.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
      <figcaption></figcaption>
    </figure>
  </div>
  <p>Чи можете ви створити ДНК квітки, рослини чи істоти як мережу частин? Однією з ідей є використання інтерактивного відбору для вдосконалення дизайну. Крім того, щоб створити спрощену 2D-версію істот Сімса, ви можете включити пружинні сили, можливо, за допомогою Toxiclibs.js або Matter.js. Що, якби істоти розвивалися відповідно до оцінювальної функції, пов’язаної з конкретною метою? Щоб дізнатися більше про підходи Сімса <a href="https://www.karlsims.com/papers/siggraph94.pdf" target="_blank" rel="noopener">ви можете прочитати його статтю 1994 року</a> і переглянути на YouTube відео <a href="https://youtu.be/RZtZia4ZkX8" target="_blank" rel="noopener">“Evolved Virtual Creatures”</a>.</p>
</div>
<h2 id="ecosystem-simulation"><a class="heading-link" href="#ecosystem-simulation">Моделювання екосистеми</a></h2>
<p>Можливо, ви помітили дещо дивне в еволюційних системах, які я побудував у цьому розділі. У реальному світі популяція немовлят не народжується одночасно. Ці малюки не ростуть і не розмножуються усі разом в один і той самий час, а потім не гинуть миттєво, залишаючи чисельність популяції абсолютно стабільною. Це було б смішно. Не кажучи вже про те, що ніхто точно не бігає по лісі з калькулятором, обчислюючи цифри та призначаючи оцінку пристосованості всім створінням.</p>
<p>У нашому реальному світі, як я розказував на початку розділу, ми насправді не маємо виживання саме найпристосованіших, а маємо <em>виживання тих хто розмножується</em>. Істоти, які живуть довше, у багатьох випадках мають більше шансів на розмноження. Діти народжуються, живуть деякий час, можливо, самі народжують дітей, а може і ні, а потім помирають. Чи міг би я написати програму, яка б відобразила цей більш реалістичний погляд на еволюційну біологію?</p>
<p>У підручниках зі штучного інтелекту ви не обов’язково знайдете симуляції еволюції реального світу. ГА-ми зазвичай використовуються у більш формальний спосіб, описаний раніше в цьому розділі.  Однак, оскільки ви читаєте цю книгу для моделювання природних систем, варто поглянути на те, як ви можете використовувати ГА для створення чогось, що нагадує живу екосистему, дуже схожу на ту, яку я описую у пропозиціях наприкінці кожного розділу.</p>
<p>Я почну з уявлення простого сценарію. Я створю створіння під назвою <em>bloop</em> (блуп), кульки, яка рухається по полотну відповідно до шуму Перліна. Створіння матиме радіус і максимальну швидкість. Чим меншого воно розміру, тим швидше буде рухатися, чим більшого — тим повільніше:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bloop</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xoff</span> = <span class="hljs-title function_">random</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yoff</span> = <span class="hljs-title function_">random</span>(<span class="hljs-number">1000</span>);
</code></pre><div class="comment"><p>Кожне блуп-створіння буде використовувати іншу частину 1D простору шуму.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxSpeed</span> = <span class="hljs-number">5</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">8</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> vx = <span class="hljs-title function_">map</span>(<span class="hljs-title function_">noise</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xoff</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span>);
    <span class="hljs-keyword">let</span> vy = <span class="hljs-title function_">map</span>(<span class="hljs-title function_">noise</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yoff</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xoff</span> += <span class="hljs-number">0.01</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yoff</span> += <span class="hljs-number">0.01</span>;
    <span class="hljs-keyword">let</span> velocity = <span class="hljs-title function_">createVector</span>(vx, vy);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">add</span>(velocity);
  }
</code></pre><div class="comment"><p>Призначення простого руху і швидкості на основі шуму Перліна.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p>Малювання блупа у вигляді кульки.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Як зазвичай, популяція блупів може зберігатися у масиві, яким своєю чергою може керувати клас під назвою <code>World</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">World</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">populationSize</span>) {
</code></pre><div class="comment"><p>Створення списку блупів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; populationSize; i++) {
</code></pre><div class="comment"><p>Масив блупів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bloop</span>(<span class="hljs-title function_">random</span>(width), <span class="hljs-title function_">random</span>(height)));
</code></pre><div class="comment"><p>Створення блупів з початковими положеннями.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Поки що я просто повторюю системи частинок як у <a href="/particles#section-particles">Розділі 4</a>. У мене є сутність під назвою <code>Bloop</code>, яка рухається по полотну, і клас під назвою <code>World</code>, який керує змінною кількістю цих сутностей. Щоб перетворити це на систему, яка розвивається, мені потрібно додати до свого світу дві додаткові функціональності:</p>
<ul>
  <li><strong>Вмирання блупів.</strong></li>
  <li><strong>Народження блупів.</strong></li>
</ul>
<p>Вмирання блупів — це моя заміна оцінювальної функції для придатності та процесу відбору. Якщо блуп помирає, його не можна вибрати батьківською сутністю, оскільки його більше не існує! Один зі способів створення механізму, який гарантує смертельні випадки у штучному світі, це додавання до класу <code>Bloop</code> змінної <code>health</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bloop</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">position, dna</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> = <span class="hljs-number">100</span>;
</code></pre><div class="comment"><p>Змінна для відстеження стану здоров’я блупа.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* Інша частина конструктора */</span>
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Кожного разу при роботі методу <code>update()</code> блуп-сутність втрачатиме частину здоров’я:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> -= <span class="hljs-number">0.2</span>;
    <span class="hljs-comment">/* Інша частина методу update() */</span>
</code></pre><div class="comment"><p>Смерть постійно наближається.</p></div></div></div>
</div>
<p>Якщо значення <code>health</code> падає нижче <code>0</code>, блуп гине:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">dead</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> &lt; <span class="hljs-number">0.0</span>);
  }
</code></pre><div class="comment"><p>Метод, щоб перевірити, чи блуп ще живий, чи вже мертвий.</p></div></div></div>
<p>Це хороший початок, але насправді я реально нічого не досяг. Зрештою, якщо всі блуп-створіння починають своє існування маючи 100 очок здоров’я і втрачають його з однаковою швидкістю, то всі вони житимуть однаково довго і помруть разом. Якщо кожний окремий блуп живе однаковий проміжок часу, то кожний з них має однакові шанси на розмноження і тому еволюційних змін не відбудеться.</p>
<p>У складнішому світі ви можете досягти мінливої тривалості життя декількома способами. Один із підходів полягає в тому, щоб додати хижаків, які їдять блупів. Швидші блупи з більшою ймовірністю уникнуть того, щоб їх з’їли, що призведе до еволюції швидших блупів. Ще один варіант — додати їжу. Коли блуп їсть їжу, його рівень здоров’я збільшується, подовжуючи життя.</p>
<p>Припустімо, що у мене є масив векторних позицій під назвою <code>food</code>. Я міг би перевірити близькість кожного блупа до кожної позиції їжі. Якщо блуп достатньо близько, тоді він їсть їжу (яка потім видаляється зі світу) і збільшує своє здоров’я:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">eat</span>(<span class="hljs-params">food</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = food.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</code></pre><div class="comment"><p>Перевіримо всі положення їжі.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> distance = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, food[i]);
</code></pre><div class="comment"><p>Як далеко знаходиться їжа?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">if</span> (distance &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>) {
</code></pre><div class="comment"><p>Якщо їжа знаходиться в радіусі тіла блупа...</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> += <span class="hljs-number">100</span>;
        food.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>...збільшимо рівень його здоров&#x27;я і видалимо їжу!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>У цьому сценарії очікується, що блупи, які їдять більше їжі, проживуть довше і матимуть більшу ймовірність розмноження. У результаті система повинна розвинути блупів з оптимальною здатністю знаходити та споживати їжу.</p>
<p>Тепер, коли світ побудовано, настав час додати компоненти, необхідні для еволюції. Насамперед необхідно встановити генотип і фенотип.</p>
<h3 id="genotype-and-phenotype"><a class="heading-link" href="#genotype-and-phenotype">Генотип і фенотип</a></h3>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;616&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/c661dfd998d35d0db8096c20c3cef529/9275a/09_ga_16.webp 288w,./static/c661dfd998d35d0db8096c20c3cef529/80097/09_ga_16.webp 576w,./static/c661dfd998d35d0db8096c20c3cef529/3a6ad/09_ga_16.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/c661dfd998d35d0db8096c20c3cef529/f6901/09_ga_16.png" data-srcset="./static/c661dfd998d35d0db8096c20c3cef529/6d6ce/09_ga_16.png 288w,./static/c661dfd998d35d0db8096c20c3cef529/762f0/09_ga_16.png 576w,./static/c661dfd998d35d0db8096c20c3cef529/f6901/09_ga_16.png 1152w" alt="Малюнок 9.13: Маленькі та великі блуп-створіння. У прикладі будуть використані прості круги, але ви можете проявити більше творчості!"/></picture><noscript><picture><source type="image/webp" srcSet="./static/c661dfd998d35d0db8096c20c3cef529/9275a/09_ga_16.webp 288w,./static/c661dfd998d35d0db8096c20c3cef529/80097/09_ga_16.webp 576w,./static/c661dfd998d35d0db8096c20c3cef529/3a6ad/09_ga_16.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/c661dfd998d35d0db8096c20c3cef529/f6901/09_ga_16.png" srcSet="./static/c661dfd998d35d0db8096c20c3cef529/6d6ce/09_ga_16.png 288w,./static/c661dfd998d35d0db8096c20c3cef529/762f0/09_ga_16.png 576w,./static/c661dfd998d35d0db8096c20c3cef529/f6901/09_ga_16.png 1152w" alt="Малюнок 9.13: Маленькі та великі блуп-створіння. У прикладі будуть використані прості круги, але ви можете проявити більше творчості!"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 9.13: Маленькі та великі блуп-створіння. У прикладі будуть використані прості круги, але ви можете проявити більше творчості!</figcaption>
  </figure>
</div>
<p>Здатність блупа знаходити їжу пов’язана з двома змінними: розміром і швидкістю (див. малюнок 9.13). Більшим блупам буде легше знаходити їжу просто тому, що їх розмір дозволить їм частіше перетинатися з їжею. А швидші блупи можуть знайти більше їжі, оскільки вони можуть покрити більше простору за коротший період часу.</p>
<p>Оскільки розмір і швидкість обернено пропорційні (великі блупи повільні, маленькі — швидкі), мені потрібен генотип лише з одним числом.</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>; i++) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = <span class="hljs-title function_">random</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    }
</code></pre><div class="comment"><p>Генетична послідовність має одне значення!
Використання масиву лише для одного числа може здатися абсурдним,
але цей підхід буде масштабовано для складніших конструкцій блупа.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<div class="avoid-break">
  <p>Фенотип — це сам блуп, розмір і швидкість якого призначаються через включення екземпляра об’єкта <code>DNA</code> до класу <code>Bloop</code>:</p>
  <div class="snip-below">
    <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bloop</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, dna</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span> = dna;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxSpeed</span> = <span class="hljs-title function_">map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-property">genes</span>[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-title function_">map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-property">genes</span>[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>);
    <span class="hljs-comment">/* Вся інша частина ініціалізації об’єкта */</span>
</code></pre><div class="comment"><p>ДНК визначить розмір і максимальну швидкість.
Чим більший блуп, тим він повільніший.</p></div></div></div>
  </div>
</div>
<p>Зауважте, що властивість <code>maxSpeed</code> зіставляється з діапазоном значень від <code>15</code> до <code>0</code>. Блуп зі значенням гена <code>0</code> рухатиметься зі швидкістю <code>15</code>, тоді як блуп зі значенням гена рівним <code>1</code> не рухатиметься взагалі (матиме швидкість <code>0</code>).</p>
<h3 id="selection-and-reproduction"><a class="heading-link" href="#selection-and-reproduction">Відбір і розмноження</a></h3>
<p>Тепер, коли я маю генотип і фенотип, мені потрібно перейти до розробки методу відбору блупів для батьківства. Раніше я казав, що чим довше живе блуп, тим більше у нього шансів розмножитися. Тривалість життя блупа — це його пристосованість.</p>
<p>Одним із можливих варіантів це створювати новий блуп, щоразу, коли два блупи стикаються між собою. Чим довше живе блуп, тим більша ймовірність його контакту з іншим блупом. Це також вплине на еволюційний результат, оскільки ймовірність народження, окрім споживання їжі, залежить від здатності блупу знаходити інших блупів.</p>
<p>Простішим варіантом було б, щоб блупи клонували самі себе, не потребуючи партнера і миттєво створюючи новий блуп з таким же генетичним набором. Наприклад, що якщо в будь-який момент блуп матиме 1 відсоток імовірності до самовідтворення? За допомогою цього алгоритму відбору, чим довше живе блуп, тим більша ймовірність, що він клонує себе. Це еквівалентно тому, що чим більше разів ви граєте в лотерею, тим більша ймовірність того, що ви виграєте (хоча, на жаль, ваші реальні шанси виграти в лотерею все ще дорівнюватимуть нулю).</p>
<p>Щоб реалізувати цей алгоритм відбору, я можу написати метод у класі <code>Bloop</code>, який кожного кадру вибиратиме випадкове число. Якщо число менше від 0.01 (1 відсоток), то народжуват иметься новий блуп:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">reproduce</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Цей метод поверне новий дочірній блуп.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; <span class="hljs-number">0.01</span>) {
      <span class="hljs-comment">/* Створення дочірнього блупу! */</span>
    }
</code></pre><div class="comment"><p>Імовірність виконання коду в даному операторі if становить 1%.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<div class="avoid-break">
  <p>Як розмножується блуп? У попередніх прикладах процес відтворення включав виклик методу <code>crossover()</code> у класі <code>DNA</code> і створення нового об’єкта з отриманого масиву генів. Однак у цьому випадку, оскільки я створюю дочірній об’єкт від єдиного блупу, я замість цього викличу метод із назвою <code>copy()</code>:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">reproduce</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; <span class="hljs-number">0.005</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> childDNA = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dna</span>.<span class="hljs-title function_">copy</span>();
</code></pre><div class="comment"><p>Тут дитина є точною копією свого батьківського об’єкта.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      childDNA.<span class="hljs-title function_">mutate</span>(<span class="hljs-number">0.01</span>);
</code></pre><div class="comment"><p>Рівень мутації складає 1%.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bloop</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">copy</span>(), childDNA);
</code></pre><div class="comment"><p>Дочірній блуп створюється у батьківській позиції.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Зверніть увагу, що я знизив імовірність відтворення з 1 відсотка до 0.05. Ця зміна має істотне значення, оскільки з високою ймовірністю відтворення система швидко переповниться, але при занадто низькій імовірності популяція, ск оріш за все швидко вимре.</p>
<p>Реалізувати метод <code>copy()</code> у класі <code>DNA</code> доволі легко за допомогою стандартного методу масиву <code>slice()</code>, який створює новий масив, копіюючи елементи з поточного масиву:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNA</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">copy</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Цей метод copy() замінює метод crossover().</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> newDNA = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>();
</code></pre><div class="comment"><p>Створення нової ДНК (з випадковими генами).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    newDNA.<span class="hljs-property">genes</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>.<span class="hljs-title function_">slice</span>();
</code></pre><div class="comment"><p>Перезапис випадкових генів копією генів поточної ДНК.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> newDNA;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>За допомогою фрагментів коду для відбору і відтворення я можу завершити клас <code>World</code>, щоб керувати списком об’єктів <code>Bloop</code>, а також об’єктом <code>Food</code>, який містить список позицій для їжі (які я намалюю у вигляді маленьких квадратів).</p>
<p>Перш ніж запускати приклад, приділіть хвилинку, щоб поміркувати й здогадатися, до якого розміру та швидкості блупів буде розвиватися система. Я обговорю ці деталі після коду.</p>
<div data-type="example">
  <h3 id="example-95-an-evolving-ecosystem"><a class="heading-link" href="#example-95-an-evolving-ecosystem">Приклад 9.5: Екосистема, що розвивається</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/09_ga/9_5_evolving_bloops"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/1HDlp_tKF" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> world;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  world = <span class="hljs-keyword">new</span> <span class="hljs-title class_">World</span>(<span class="hljs-number">20</span>);
</code></pre><div class="comment"><p>Світ починається з 20 блупів і 20 шматочків їжі.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  world.<span class="hljs-title function_">run</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">World</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">populationSize</span>) {
</code></pre><div class="comment"><p>Клас World керує
популяцією блупів і всією їжею.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; populationSize; i++) {
      <span class="hljs-keyword">let</span> position = <span class="hljs-title function_">createVector</span>(<span class="hljs-title function_">random</span>(width), <span class="hljs-title function_">random</span>(height));
      <span class="hljs-keyword">let</span> dna = <span class="hljs-keyword">new</span> <span class="hljs-title function_">DNA</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bloop</span>(position, dna));
    }
</code></pre><div class="comment"><p>Створення популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">food</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Food</span>(populationSize);
</code></pre><div class="comment"><p>Створення їжі.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Запуск світу.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">food</span>.<span class="hljs-title function_">run</span>();
</code></pre><div class="comment"><p>Цей метод малює і додає нову їжу, коли це необхідно.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</code></pre><div class="comment"><p>Управління блупами (оскільки тут можуть видалятися блупи, то прохід масивом відбувається у зворотньому напрямку).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> bloop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>[i];
      bloop.<span class="hljs-title function_">run</span>();
      bloop.<span class="hljs-title function_">eat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">food</span>);
</code></pre><div class="comment"><p>Всі блупи рухаються і харчуються, знайденою їжею.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">if</span> (bloop.<span class="hljs-title function_">dead</span>()) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">food</span>.<span class="hljs-title function_">add</span>(bloop.<span class="hljs-property">position</span>);
      } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p>Якщо блуп мертвий, він видаляється і створюється їжа.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">        <span class="hljs-keyword">let</span> child = <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>[i].<span class="hljs-title function_">reproduce</span>();
        <span class="hljs-keyword">if</span> (child) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">bloops</span>.<span class="hljs-title function_">push</span>(child);
        }
</code></pre><div class="comment"><p>Саме в цій частині коду кожен живий блуп має шанс до розмноження.
Якщо це сталося, то дитина додається до популяції.
Якщо відтворення не спрацювало, тоді значення дочірнього елемента буде undefined.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо ви вирішили, що блупи будуть середнього розміру з середньою швидкістю, то маєте рацію. Просто через спроєктованість цієї системи великі блупи занадто повільно знаходять їжу. А швидкі блупи занадто малі, щоб знайти їжу. Ті, які здатні прожити найдовше, як правило, знаходяться посередині, вони достатньо великі та швидкі, щоб знайти їжу (але не надто великі чи надто швидкі). Також існують деякі аномалії. Наприклад, якщо купа великих блупів опиниться в одному місці (і ледь рухатиметься, оскільки вони такі великі), усі вони можуть раптово вимерти, залишивши багато їжі для одного великого блупа, який випадково опиниться там, щоб поїсти й це дозволить таким чином мініпопуляції великих блупів підтримувати себе певний період часу в одному положенні.</p>
<p>Цей приклад досить спрощений, враховуючи його один ген і клонування замість схрещування. Нижче кілька пропозицій щодо застосування прикладу з блупами для складнішої симуляції екосистеми.</p>
<div data-type="project" class="callout">
  <h3 id="the-ecosystem-project-10"><a class="heading-link" href="#the-ecosystem-project-10">Проєкт “Екосистема”</a></h3>
  <p>Додайте здатність вашої екосистеми до еволюційних змін, спираючись на приклади цього розділу:</p>
  <ul>
    <li>Додайте у свою екосистему популяцію хижаків. Біологічну еволюцію між хижаками та здобиччю (або паразитами й господарями) часто називають <em>перегонами озброєнь</em> під час якої створіння постійно пристосовуються та протидіють одне одному. Чи можете ви досягти такої поведінки у системі з кількох створінь?</li>
    <li>Як би ви здійснили схрещування і мутацію між двома батьківськими об’єктами в екосистемі, змодельованій по прикладу блупів? Спробуйте застосувати алгоритм, щоб дві істоти спаровувалися, перебуваючи на певній відстані.</li>
    <li>Спробуйте використати ваги для кількох керувальних сил у якості ДНК створіння. Чи можете ви створити сценарій за яким створіння еволюціонують, щоб співпрацювати одне з одним?</li>
    <li>Однією з найбільших проблем у моделюванні екосистеми є досягнення балансу. Ймовірно, ви побачите, що більшість ваших спроб призводять або до масового перенаселення (з наступним масовим вимиранням), або до масового вимирання. Які способи можна застосувати, щоб досягти балансу? Розгляньте можливість використання ГА для розробки оптимальних параметрів для екосистеми.</li>
  </ul>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1420&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#989898;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/920f21aae258b059886edc23d756b507/be6fc/09_ga_17.webp 576w,./static/920f21aae258b059886edc23d756b507/7c4ba/09_ga_17.webp 1152w,./static/920f21aae258b059886edc23d756b507/2e9c6/09_ga_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/920f21aae258b059886edc23d756b507/43bff/09_ga_17.png" data-srcset="./static/920f21aae258b059886edc23d756b507/09264/09_ga_17.png 576w,./static/920f21aae258b059886edc23d756b507/8a8ae/09_ga_17.png 1152w,./static/920f21aae258b059886edc23d756b507/43bff/09_ga_17.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/920f21aae258b059886edc23d756b507/be6fc/09_ga_17.webp 576w,./static/920f21aae258b059886edc23d756b507/7c4ba/09_ga_17.webp 1152w,./static/920f21aae258b059886edc23d756b507/2e9c6/09_ga_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/920f21aae258b059886edc23d756b507/43bff/09_ga_17.png" srcSet="./static/920f21aae258b059886edc23d756b507/09264/09_ga_17.png 576w,./static/920f21aae258b059886edc23d756b507/8a8ae/09_ga_17.png 1152w,./static/920f21aae258b059886edc23d756b507/43bff/09_ga_17.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
</div>
</section>
<hr/><section class="not-prose flex w-full justify-between"><div><a class="group block" href="./fractals.html"><p class="text-gray-500">Попередній розділ</p><span class="text-lg font-semibold group-hover:underline">← <!-- -->8. Фрактали</span></a></div><div><a class="group block text-right" href="./neural-networks.html"><p class="text-gray-500">Наступний розділм</p><span class="text-lg font-semibold group-hover:underline">10. Нейронні мережі<!-- --> →</span></a></div></section></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div>
<script src="./assets/js/main.js"></script>
</body></html>