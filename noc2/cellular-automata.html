<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta data-react-helmet="true" name="description" content="У Розділі 5 я визначив складну систему як мережу елементів із короткочасними зв’язками, що працюють паралельно та демонструють емерджентну поведінку. "/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:url" content="https://natureofcode.com"/><meta data-react-helmet="true" property="og:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/><meta data-react-helmet="true" property="og:title" content="7. Клітинні автомати"/><meta data-react-helmet="true" property="og:description" content="У Розділі 5 я визначив складну систему як мережу елементів із короткочасними зв’язками, що працюють паралельно та демонструють емерджентну поведінку. "/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="7. Клітинні автомати"/><meta data-react-helmet="true" name="twitter:description" content="У Розділі 5 я визначив складну систему як мережу елементів із короткочасними зв’язками, що працюють паралельно та демонструють емерджентну поведінку. "/><meta data-react-helmet="true" name="twitter:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/>

  <link rel="stylesheet" href="./assets/styles/global.css">

  <noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="./favicon-32x32.png" type="image/png"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title data-react-helmet="true">7. Клітинні автомати / Nature of Code</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="fixed left-0 right-0 top-0 z-40 bg-white px-6 lg:px-8"><div class="mx-auto flex h-[5em] max-w-6xl items-center justify-between"><div class="flex flex-col gap-x-6 lg:flex-row lg:items-center"><a href="./"><span class="text-lg font-black tracking-widest text-noc-400"><span class="font-black">ПРИРОДА</span> КОДУ</span></a><span class="hidden text-sm tracking-widest text-noc-400 xl:block">ДАНІЕЛЬ ШИФФМАН</span></div><button class="flex h-9 w-11 cursor-pointer flex-col items-center justify-between p-2 lg:hidden" aria-label="Toggle menu" title="Toggle menu"><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-opacity" style="opacity:1"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span></button><div class="hidden items-center gap-6 lg:flex"><ul class="flex items-center gap-6"><li><a href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M458.4 64.3C400.6 15.7 311.3 23 256 79.3 200.7 23 111.4 15.6 53.6 64.3-21.6 127.6-10.6 230.8 43 285.5l175.4 178.7c10 10.2 23.4 15.9 37.6 15.9 14.3 0 27.6-5.6 37.6-15.8L469 285.6c53.5-54.7 64.7-157.9-10.6-221.3zm-23.6 187.5L259.4 430.5c-2.4 2.4-4.4 2.4-6.8 0L77.2 251.8c-36.5-37.2-43.9-107.6 7.3-150.7 38.9-32.7 98.9-27.8 136.5 10.5l35 35.7 35-35.7c37.8-38.5 97.8-43.2 136.5-10.6 51.1 43.1 43.5 113.9 7.3 150.8z"></path></svg>SUPPORT</a></li><li><a href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>GITHUB</a></li><li><a href="https://thecodingtrain.com/" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./static/codingtrain_logo-53b0a841be45c7eac7a12f88b7bea596.png" alt="Coding Train&#x27;s logo" class="-ml-2 w-8"/>CODING TRAIN</a></li></ul><div class="not-prose flex items-center gap-4 undefined"><div class="relative"><a href="https://natureofcode.com/" target="_blank" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./favicon-32x32.png" alt="The Nature Of Code logo" class="noc2-logo"/>THE NATURE OF CODE</a></div></div></div></div></header>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-YD31R75NSS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-YD31R75NSS');
  </script>
  <nav class="fixed bottom-0 left-0 right-0 top-[5em] z-20 overflow-y-auto bg-white px-6 lg:hidden mb-menu hidden">
    <ul class="my-7 space-y-2">
      <li><a class="text-lg text-gray-800" href="./dedication.html">Присвята</a></li>
      <li><a class="text-lg text-gray-800" href="./acknowledgements.html">Подяки</a></li>
      <li><a class="text-lg text-gray-800" href="./introduction.html">Вступ</a></li>
      <li>
        <button class="sub-menu-btn flex items-center gap-2 text-lg text-gray-800">
          <span>Розділи</span>
          <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 transition-transform" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="transform: scaleY(1);"><polyline points="6 9 12 15 18 9"></polyline></svg>
        </button>
        <ul class="space-y-2 py-2 pl-4 sub-menu hidden">
          <li><a class="flex items-center text-gray-600" href="./random.html"><span class="w-8">0</span><span>Випадковість</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./vectors.html"><span class="w-8">1</span><span>Вектори</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./forces.html"><span class="w-8">2</span><span>Сили</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./oscillation.html"><span class="w-8">3</span><span>Коливання</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./particles.html"><span class="w-8">4</span><span>Система частинок</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./autonomous-agents.html"><span class="w-8">5</span><span>Автономні агенти</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./physics-libraries.html"><span class="w-8">6</span><span>Фізичні бібліотеки</span></a></li>
          <li><a aria-current="page" class="flex items-center text-gray-600 font-bold" href="./cellular-automata.html"><span class="w-8">7</span><span>Клітинні автомати</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./fractals.html"><span class="w-8">8</span><span>Фрактали</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./genetic-algorithms.html"><span class="w-8">9</span><span>Еволюційне моделювання</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./neural-networks.html"><span class="w-8">10</span><span>Нейронні мережі</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./neuroevolution.html"><span class="w-8">11</span><span>Нейроеволюція</span></a></li>
        </ul>
      </li>
      <li><a class="text-lg text-gray-800" href="./appendix-creature.html">Додаток: Дизайн створінь</a></li>
      <li><a class="text-lg text-gray-800" href="./resources.html">Додаткові ресурси</a></li>
      <li><a class="text-lg text-gray-800" href="./credits.html">Credits</a></li>
      <li><a class="text-lg text-gray-800" href="./translation.html">Про переклад</a></li>
      <li><a class="text-lg text-gray-800" href="./examples.html">Приклади</a></li>
    </ul>
    <ul class="my-7 space-y-2">
      <li><a target="_blank" href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1 text-lg text-gray-800">Support<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
      <li><a target="_blank" href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1 text-lg text-gray-800">GitHub<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
      <li><a target="_blank" href="https://thecodingtrain.com/" class="flex items-center gap-1 text-lg text-gray-800">Coding Train<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>

      <li><a target="_blank" href="https://natureofcode.com/" class="flex items-center gap-1 text-lg text-gray-800">The Nature Of Code<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
    </ul>
  </nav>
  <div class="mt-[6em] px-6 lg:px-8"><div class="mx-auto max-w-6xl lg:flex lg:justify-between lg:gap-10 xl:gap-14"><aside class="sticky top-[6em] z-10 hidden max-h-[calc(100vh-6em)] min-w-[14em] overflow-y-auto pb-8 lg:block lg:flex-grow"><nav class="border-noc-200 rounded-3xl border"><ul class="divide-noc-200 divide-y"><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./dedication.html">Присвята</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./acknowledgements.html">Подяки</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./introduction.html">Вступ</a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./random.html"><span class="w-8">0</span><span class="group-hover:underline">Випадковість</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./vectors.html"><span class="w-8">1</span><span class="group-hover:underline">Вектори</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./forces.html"><span class="w-8">2</span><span class="group-hover:underline">Сили</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./oscillation.html"><span class="w-8">3</span><span class="group-hover:underline">Коливання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./particles.html"><span class="w-8">4</span><span class="group-hover:underline">Системи частинок</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./autonomous-agents.html"><span class="w-8">5</span><span class="group-hover:underline">Автономні агенти</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./physics-libraries.html"><span class="w-8">6</span><span class="group-hover:underline">Фізичні бібліотеки</span></a></li><li><a aria-current="page" class="group relative flex items-center px-3 py-2 text-sm font-bold" href="./cellular-automata.html"><span class="w-8">7</span><span class="group-hover:underline">Клітинні автомати</span></a><ul class="space-y-1 pb-2"><li><a href="#what-is-a-cellular-automaton" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Що таке клітинний автомат?</a></li><li><a href="#elementary-cellular-automata" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Елементарні клітинні автомати</a></li><li><a href="#wolfram-classification" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Класифікація Вольфрама</a></li><li><a href="#the-game-of-life" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Гра Життя</a></li><li><a href="#object-oriented-cells" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Об’єктно-орієнтовані клітини</a></li><li><a href="#variations-on-traditional-ca" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Варіації традиційного КА</a></li></ul></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./fractals.html"><span class="w-8">8</span><span class="group-hover:underline">Фрактали</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./genetic-algorithms.html"><span class="w-8">9</span><span class="group-hover:underline">Еволюційне моделювання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neural-networks.html"><span class="w-8">10</span><span class="group-hover:underline">Нейронні мережі</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neuroevolution.html"><span class="w-8">11</span><span class="group-hover:underline">Нейроеволюція</span></a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./appendix-creature.html">Додаток: Дизайн створінь </a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./resources.html">Додаткові ресурси</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./credits.html">Credits</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./translation.html">Про переклад</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./examples.html">Приклади</a></li></ul></nav></aside><main class="prose mx-auto max-w-[50em] pb-8"><section data-type="chapter" id="section-cellular-automata">
<h1 id="chapter-7-cellular-automata">Розділ 7. Клітинні автомати</h1>
<div class="chapter-opening-quote">
  <blockquote data-type="epigraph">
    <p>Поодинці ми одна крапля. Разом ми океан.</p>
    <div class="chapter-opening-quote-source">
      <p>— Рюноске Сатору</p>
    </div>
  </blockquote>
</div>
<p></p>
<div class="chapter-opening-figure">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2810px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1582&#x27; width=&#x27;2810&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#186888;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/8ab7751f42c0ad4eb7edaaea7871448a/552fc/07_ca_1.webp 703w,./static/8ab7751f42c0ad4eb7edaaea7871448a/7bb0e/07_ca_1.webp 1405w,./static/8ab7751f42c0ad4eb7edaaea7871448a/b3b62/07_ca_1.webp 2810w" sizes="(min-width: 2810px) 2810px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2810px) 2810px, 100vw" decoding="async" loading="lazy" data-src="./static/8ab7751f42c0ad4eb7edaaea7871448a/d7636/07_ca_1.jpg" data-srcset="./static/8ab7751f42c0ad4eb7edaaea7871448a/fa6ea/07_ca_1.jpg 703w,./static/8ab7751f42c0ad4eb7edaaea7871448a/f5d0a/07_ca_1.jpg 1405w,./static/8ab7751f42c0ad4eb7edaaea7871448a/d7636/07_ca_1.jpg 2810w" alt="Тканина кенте (фото ZSM)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/8ab7751f42c0ad4eb7edaaea7871448a/552fc/07_ca_1.webp 703w,./static/8ab7751f42c0ad4eb7edaaea7871448a/7bb0e/07_ca_1.webp 1405w,./static/8ab7751f42c0ad4eb7edaaea7871448a/b3b62/07_ca_1.webp 2810w" sizes="(min-width: 2810px) 2810px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2810px) 2810px, 100vw" decoding="async" loading="lazy" src="./static/8ab7751f42c0ad4eb7edaaea7871448a/d7636/07_ca_1.jpg" srcSet="./static/8ab7751f42c0ad4eb7edaaea7871448a/fa6ea/07_ca_1.jpg 703w,./static/8ab7751f42c0ad4eb7edaaea7871448a/f5d0a/07_ca_1.jpg 1405w,./static/8ab7751f42c0ad4eb7edaaea7871448a/d7636/07_ca_1.jpg 2810w" alt="Тканина кенте (фото ZSM)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
  <span id="kente-cloth-photo-by-zsm"><a class="heading-link" href="#kente-cloth-photo-by-zsm">Тканина кенте (фото ZSM)</a></span>
  <p>Тканина кенте походить від народу Акан із Гани — це тканина, яка славиться своїми яскравими кольорами та заплутаними візерунками. Кожний дизайн, витканий у вигляді вузьких смужок, унікальний, а коли смужки з’єднуються, вони утворюють гобелен зі складних і емерджентних візерунків, які розповідають історію або несуть повідомлення. На зображенні показано три типові смужки кенте, що підкреслюють різноманітні ткацькі традиції, які відображають багату культуру гобеленів Гани.</p>
<hr/></div>
<p>У <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a> я визначив складну систему як мережу елементів із короткочасними зв’язками, що працюють паралельно та демонструють емерджентну поведінку. Я створив симуляцію зграї, щоб продемонструвати, що складна система проявляє себе дещо більше, ніж проста сума її складових. У  цьому розділі я збираюся розробити інші складні системи, відомі як клітинні автомати.</p>
<p>У деяких аспектах ці приклади можуть здатися кроком назад. Окремі елементи моїх систем більше не будуть членами фізичного світу, керуватися силами й векторами чи рухатися по полотну. Натомість я створюватиму системи з найпростішої можливої цифрової одиниці: одного біта. Цей біт називається <strong>клітиною</strong>, а його значення (0 або 1) називається його <strong>станом</strong>. Робота з такими простими елементами допоможе зрозуміти, як працюють складні системи й дасть можливість детальніше розібратися в деяких техніках програмування, які застосовуються до проєктів, заснованих на коді. Побудова клітинних автоматів також стане основою для решти книги, де я все більше зосереджуватимусь на системах і алгоритмах, а не на векторах і русі, хоча ці системи й алгоритми я можу і буду застосовувати до рухомих тіл.</p>
<h2 id="what-is-a-cellular-automaton"><a class="heading-link" href="#what-is-a-cellular-automaton">Що таке клітинний автомат?</a></h2>
<p><strong>Клітинний автомат</strong> або скорочено <strong>КА</strong> — це модель системи клітинних об’єктів із наступними характеристиками:</p>
<ul>
  <li>Клітини живуть у <strong>сітці</strong>. (У цьому розділі я наведу приклади з одномірною та двомірною сітками, хоча КА може існувати у будь-якій вимірності.)</li>
  <li>Кожна клітина має <strong>стан</strong>, який може змінюватися з часом. Кількість можливих станів, як правило, обмежена. У найпростішому прикладі їх два: 1 і 0 (інакше їх називають <em>увімкнений</em> і <em>вимкнений</em>, або <em>живий</em> та <em>неживий</em>).</li>
  <li>Кожна клітинка має <strong>околицю</strong>. Вона може визначатися різними способами, але зазвичай маються на увазі усі клітини, суміжні з поточною.</li>
</ul>
<p>Важливо підкреслити, що клітини в КА не належать до біологічних клітин (хоча ви побачите, як КА може імітувати реалістичну поведінку та мати застосування в біології). Натомість вони просто представляють окремі одиниці у сітці, подібно до клітинок в електронній таблиці (як у Microsoft Excel). На малюнку 7.1 показано КА та його різні характеристики.</p>
<p>Друга особливість КА, яку я назвав — це важлива ідея про те, що стан комірки може змінюватися з часом. Досі в цій книзі об’єкти (блукачі, частинки, боїди, тіла тощо) загалом існували лише в одному стані. Можливо, вони рухалися зі склад ною поведінкою та фізикою, але зрештою вони залишалися тим самим типом об’єктів протягом свого цифрового життя. Я натякав на можливість того, що ці сутності можуть змінюватися з часом (наприклад, вага певних поведінок може змінюватись), але я не повністю застосував це на практиці. Тепер за допомогою КА ви побачите, як стан об’єкта може змінюватися на основі системи правил.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1106&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/7e04e9dfde6c495fb1a474045d0a82a9/d5dc1/07_ca_2.webp 576w,./static/7e04e9dfde6c495fb1a474045d0a82a9/0f313/07_ca_2.webp 1152w,./static/7e04e9dfde6c495fb1a474045d0a82a9/c4d1d/07_ca_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/7e04e9dfde6c495fb1a474045d0a82a9/3f619/07_ca_2.png" data-srcset="./static/7e04e9dfde6c495fb1a474045d0a82a9/d062e/07_ca_2.png 576w,./static/7e04e9dfde6c495fb1a474045d0a82a9/d1c40/07_ca_2.png 1152w,./static/7e04e9dfde6c495fb1a474045d0a82a9/3f619/07_ca_2.png 2304w" alt="Малюнок 7.1: 2D сі тка клітинок, кожна зі станом увімкнено або вимкнено. Околиця — це частина великої сітки, яка зазвичай складається з усіх клітин, суміжних із поточною клітиною (обведено кружком)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/7e04e9dfde6c495fb1a474045d0a82a9/d5dc1/07_ca_2.webp 576w,./static/7e04e9dfde6c495fb1a474045d0a82a9/0f313/07_ca_2.webp 1152w,./static/7e04e9dfde6c495fb1a474045d0a82a9/c4d1d/07_ca_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/7e04e9dfde6c495fb1a474045d0a82a9/3f619/07_ca_2.png" srcSet="./static/7e04e9dfde6c495fb1a474045d0a82a9/d062e/07_ca_2.png 576w,./static/7e04e9dfde6c495fb1a474045d0a82a9/d1c40/07_ca_2.png 1152w,./static/7e04e9dfde6c495fb1a474045d0a82a9/3f619/07_ca_2.png 2304w" alt="Малюнок 7.1: 2D сітка клітинок, кожна зі станом увімкнено або вимкнено. Околиця — це частина великої сітки, яка зазвичай складається з усіх клітин, суміжних із поточною клітиною (обведено кружком)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.1: 2D сітка клітин, кожна зі станом <em>увімкнено</em> або <em>вимкнено</em>. Околиця — це частина великої сітки, яка зазвичай складається з усіх клітин, суміжних із поточною клітиною (обведено кружком)</figcaption>
</figure>
<p>Розробку систем КА зазвичай приписують Станіславу Уламу та Джону фон Нейману — обидва були дослідниками в національній лабораторії Лос-Аламоса у Нью-Мексико в 1940-х роках. Улам вивчав ріст кристалів, а фон Нейман розглядав світ самовідтворюваних роботів. Ви правильно прочитали: роботів, які можуть створювати власні копії.</p>
<p>Оригінальні клітини фон Неймана мали 29 можливих станів, тому, можливо, ідея самовідтворюваних роботів буде надто складною для відправної точки. Замість цього уявіть ряд доміно. Кожне доміно може перебувати в одному з двох станів: стояти вертикально (1) або бути поваленим (0). Подібно до того, як доміно реагують на свої сусідні доміно, на поведінку кожної клітини у КА впливає стан сусідніх клітин.</p>
<p>У цьому розділі досліджується, як навіть найпростіші правила гри в доміно можуть призвести до широкого спектра складних моделей і поведінки, подібних до п риродних процесів, таких як біологічне розмноження та еволюція. Робота фон Неймана в галузі самовідтворення та КА концептуально схожа на, ймовірно, найвідоміший КА під назвою Гра Життя, який я детально обговорю пізніше в цьому розділі.</p>
<p>Мабуть, найзначніша (і тривала) наукова праця, присвячена дослідженню КА, була опублікована у 2002 році під авторством Стівена Вольфрама: <a href="https://www.wolframscience.com/nks" target="_blank" rel="noopener"><em>A New Kind of Science</em></a> (1280 сторінок). У книзі Вольфрама, безплатно доступній у повному обсязі в інтернеті, розповідається про те, що клітинні автомати це не просто хитрі трюки, а вони є актуальними для вивчення біології, хімії, фізики та всіх галузей науки. За мить я перейду до створення симуляції роботи Вольфрама, хоча я ледь торкнуся поверхні теорій, які він окреслює — я зосереджуся на реалізації коду, а не на філософських наслідках. Якщо ці приклади викликають вашу цікавість, ви знайдете ще багато про що прочитати в книзі Вольфрама, а також у його поточних дослідженнях у рамках <a href="https://www.wolframphysics.org/" target="_blank" rel="noopener">Проєкту фізики Вольфрама</a>.</p>
<h2 id="elementary-cellular-automata"><a class="heading-link" href="#elementary-cellular-automata">Елементарні клітинні автомати</a></h2>
<p>Який найпростіший КА ви можете собі уявити? Для Вольфрама елементарний КА має три ключові елементи:</p>
<ul>
  <li>Сітка</li>
  <li>Стани</li>
  <li>Околиця</li>
</ul>
<p>Найпростішою сіткою буде одномірна: лінія клітин (малюнок 7.2).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;231&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/ed4516c96ef63923645a568d2a98f808/32805/07_ca_3.webp 576w,./static/ed4516c96ef63923645a568d2a98f808/5c76a/07_ca_3.webp 1152w,./static/ed4516c96ef63923645a568d2a98f808/72e2f/07_ca_3.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/ed4516c96ef63923645a568d2a98f808/c7fce/07_ca_3.png" data-srcset="./static/ed4516c96ef63923645a568d2a98f808/9bce1/07_ca_3.png 576w,./static/ed4516c96ef63923645a568d2a98f808/198b3/07_ca_3.png 1152w,./static/ed4516c96ef63923645a568d2a98f808/c7fce/07_ca_3.png 2304w" alt="Малюнок 7.2: 1D лінія клітин"/></picture><noscript><picture><source type="image/webp" srcSet="./static/ed4516c96ef63923645a568d2a98f808/32805/07_ca_3.webp 576w,./static/ed4516c96ef63923645a568d2a98f808/5c76a/07_ca_3.webp 1152w,./static/ed4516c96ef63923645a568d2a98f808/72e2f/07_ca_3.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/ed4516c96ef63923645a568d2a98f808/c7fce/07_ca_3.png" srcSet="./static/ed4516c96ef63923645a568d2a98f808/9bce1/07_ca_3.png 576w,./static/ed4516c96ef63923645a568d2a98f808/198b3/07_ca_3.png 1152w,./static/ed4516c96ef63923645a568d2a98f808/c7fce/07_ca_3.png 2304w" alt="Малюнок 7.2: 1D лінія клітин"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.2: Одномірна лінія клітин</figcaption>
</figure>
<p>Найпростішим набором станів (крім наявності лише одного стану) є два стани: 0 або 1 (малюнок 7.3). Початкові стани можуть встановлюватися випадковим чином.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;255&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/0e915170aeeae61c35405c1eba2cfaa4/a209d/07_ca_4.webp 576w,./static/0e915170aeeae61c35405c1eba2cfaa4/de9b1/07_ca_4.webp 1152w,./static/0e915170aeeae61c35405c1eba2cfaa4/3a78c/07_ca_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/0e915170aeeae61c35405c1eba2cfaa4/ba6d1/07_ca_4.png" data-srcset="./static/0e915170aeeae61c35405c1eba2cfaa4/58f03/07_ca_4.png 576w,./static/0e915170aeeae61c35405c1eba2cfaa4/94ce7/07_ca_4.png 1152w,./static/0e915170aeeae61c35405c1eba2cfaa4/ba6d1/07_ca_4.png 2304w" alt="Малюнок 7.3: 1D лінія клітин, позначених станами 0 або 1. Яка знайома структура даних програмування може представляти цю послідовність?"/></picture><noscript><picture><source type="image/webp" srcSet="./static/0e915170aeeae61c35405c1eba2cfaa4/a209d/07_ca_4.webp 576w,./static/0e915170aeeae61c35405c1eba2cfaa4/de9b1/07_ca_4.webp 1152w,./static/0e915170aeeae61c35405c1eba2cfaa4/3a78c/07_ca_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/0e915170aeeae61c35405c1eba2cfaa4/ba6d1/07_ca_4.png" srcSet="./static/0e915170aeeae61c35405c1eba2cfaa4/58f03/07_ca_4.png 576w,./static/0e915170aeeae61c35405c1eba2cfaa4/94ce7/07_ca_4.png 1152w,./static/0e915170aeeae61c35405c1eba2cfaa4/ba6d1/07_ca_4.png 2304w" alt="Малюнок 7.3: 1D лінія клітин, позначених станами 0 або 1. Яка знайома структура даних програмування може представляти цю послідовність?"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.3: Одномірна лінія клітин, позначених станами 0 або 1. Яка знайома структура даних програмування може представляти цю послідовність?</figcaption>
</figure>
<p>Найпростішою околицею в одному вимірі для будь-якої даної клітини буде сама комірка та два її сусіди: один ліворуч і один праворуч (малюнок 7.4). Мені доведеться вирішити, що я хочу робити з крайніми комірками сітки ліворуч і праворуч, оскільки кожна з них має лише по одному сусіду, але я можу розібратися з цими питанням пізніше.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;255&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/efe1c3f074054bb741de4556d5d6b5ac/a209d/07_ca_5.webp 576w,./static/efe1c3f074054bb741de4556d5d6b5ac/de9b1/07_ca_5.webp 1152w,./static/efe1c3f074054bb741de4556d5d6b5ac/3a78c/07_ca_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/efe1c3f074054bb741de4556d5d6b5ac/ba6d1/07_ca_5.png" data-srcset="./static/efe1c3f074054bb741de4556d5d6b5ac/58f03/07_ca_5.png 576w,./static/efe1c3f074054bb741de4556d5d6b5ac/94ce7/07_ca_5.png 1152w,./static/efe1c3f074054bb741de4556d5d6b5ac/ba6d1/07_ca_5.png 2304w" alt="Малюнок 7.4: Околиця в одному вимірі складається з трьох клітинок"/></picture><noscript><picture><source type="image/webp" srcSet="./static/efe1c3f074054bb741de4556d5d6b5ac/a209d/07_ca_5.webp 576w,./static/efe1c3f074054bb741de4556d5d6b5ac/de9b1/07_ca_5.webp 1152w,./static/efe1c3f074054bb741de4556d5d6b5ac/3a78c/07_ca_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/efe1c3f074054bb741de4556d5d6b5ac/ba6d1/07_ca_5.png" srcSet="./static/efe1c3f074054bb741de4556d5d6b5ac/58f03/07_ca_5.png 576w,./static/efe1c3f074054bb741de4556d5d6b5ac/94ce7/07_ca_5.png 1152w,./static/efe1c3f074054bb741de4556d5d6b5ac/ba6d1/07_ca_5.png 2304w" alt="Малюнок 7.4: Околиця в одному вимірі складається з трьох клітинок"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.4: Околиця в одному вимірі складається з трьох клітинок</figcaption>
</figure>
<p>У мене є ряд клітин, кожна з яких має початковий стан і кожна з двома сусідами. Найцікавіше те, що навіть із цим найпростішим КА, який тільки можна собі уявити, можуть проявлятися властивості складних систем. Але я ще не обговорював, мабуть, найважливішу деталь того, як працює КА: його зміни з часом.</p>
<p>Я не говорю тут про реальний час, а скоріше про КА, що змінюється і розвивається через серію окремих часових кроків, які також можна назвати <strong>поколіннями</strong>. У випадку КА у програмі p5.js час, ймовірно, буде прив’язаний до кількості кадрів анімації. Питання, зображене на малюнку 7.5, наступне: якщо у початковій стадії (покоління 0) клітини мають певний стан, як мені обчислити стан для всіх клітин у наступному поколінні 1? І як тоді я можу перейти від покоління 1 до поколінн я 2 і так далі?</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;535&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d2db0b0977de2d66aad6a96fbd7bacc0/d24e9/07_ca_6.webp 576w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/f9675/07_ca_6.webp 1152w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/dee1f/07_ca_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/d2db0b0977de2d66aad6a96fbd7bacc0/be90e/07_ca_6.png" data-srcset="./static/d2db0b0977de2d66aad6a96fbd7bacc0/95b86/07_ca_6.png 576w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/499ab/07_ca_6.png 1152w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/be90e/07_ca_6.png 2304w" alt="Малюнок 7.5: Стани для покоління 1 обчислюються з використанням станів клітин з покоління 0"/></picture><noscript><picture><source type="image/webp" srcSet="./static/d2db0b0977de2d66aad6a96fbd7bacc0/d24e9/07_ca_6.webp 576w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/f9675/07_ca_6.webp 1152w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/dee1f/07_ca_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/d2db0b0977de2d66aad6a96fbd7bacc0/be90e/07_ca_6.png" srcSet="./static/d2db0b0977de2d66aad6a96fbd7bacc0/95b86/07_ca_6.png 576w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/499ab/07_ca_6.png 1152w,./static/d2db0b0977de2d66aad6a96fbd7bacc0/be90e/07_ca_6.png 2304w" alt="Малюнок 7.5: Стани для покоління 1 обчислюються з використанням станів клітин з покоління 0"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.5: Стани для покоління 1 обчислюються з використанням станів клітин з покоління 0</figcaption>
</figure>
<p>Скажімо, КА має окрему клітину, що називається <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cell</mtext></mrow><annotation encoding="application/x-tex">\text{cell}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord">cell</span></span></span></span></span></span>. Формула для розрахунку стану клітини в будь-який момент часу <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span></span> (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>cell</mtext><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\text{cell}_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord text"><span class="mord">cell</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>) виглядає наступним чином:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mtext>cell</mtext><mi>t</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mtext>cell neighborhood</mtext><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{cell}_t = f(\text{cell neighborhood}_{t-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord text"><span class="mord">cell</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0525em;vertical-align:-0.3025em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">cell neighborhood</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3025em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></div>
<p>Іншими словами, новий стан клітини є функцією всіх станів у сусідніх клітинах із попереднього покоління (що відповідає часу <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>). Нове значення стану обчислюється шляхом перегляду сусідніх станів попереднього покоління (малюнок 7.6).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;487&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/358c00cc01196d451c4781c23836e3a4/6a699/07_ca_7.webp 576w,./static/358c00cc01196d451c4781c23836e3a4/d0ea3/07_ca_7.webp 1152w,./static/358c00cc01196d451c4781c23836e3a4/c89fd/07_ca_7.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/358c00cc01196d451c4781c23836e3a4/dd5a2/07_ca_7.png" data-srcset="./static/358c00cc01196d451c4781c23836e3a4/f1230/07_ca_7.png 576w,./static/358c00cc01196d451c4781c23836e3a4/da001/07_ca_7.png 1152w,./static/358c00cc01196d451c4781c23836e3a4/dd5a2/07_ca_7.png 2304w" alt="Малюнок 7.6: Стан клітини із покоління 1 є функцією сусідніх станів із попереднього покоління"/></picture><noscript><picture><source type="image/webp" srcSet="./static/358c00cc01196d451c4781c23836e3a4/6a699/07_ca_7.webp 576w,./static/358c00cc01196d451c4781c23836e3a4/d0ea3/07_ca_7.webp 1152w,./static/358c00cc01196d451c4781c23836e3a4/c89fd/07_ca_7.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/358c00cc01196d451c4781c23836e3a4/dd5a2/07_ca_7.png" srcSet="./static/358c00cc01196d451c4781c23836e3a4/f1230/07_ca_7.png 576w,./static/358c00cc01196d451c4781c23836e3a4/da001/07_ca_7.png 1152w,./static/358c00cc01196d451c4781c23836e3a4/dd5a2/07_ca_7.png 2304w" alt="Малюнок 7.6: Стан клітини із покоління 1 є функцією сусідніх станів із попереднього покоління"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.6: Стан клітини із покоління 1 є функцією сусідніх станів із попереднього покоління</figcaption>
</figure>
<p>Ви можете обчислити стан кліти нки на основі станів її сусідів різними способами. Розгляньте процес розмиття зображення. (Вгадайте що? Обробка зображень працює за правилами, подібними до КА!) Новий стан пікселя (його колір) є середнім значенням кольорів його сусідів. Подібним чином новий стан клітини може бути сумою станів усіх її сусідів. Однак в елементарному КА Вольфрама цей процес використовує інший підхід: замість математичних операцій нові стани визначаються заздалегідь визначеними правилами, які враховують кожну можливу конфігурацію клітини та її сусідів. Ці правила відомі під загальною назвою <strong>набір правил (ruleset)</strong>.</p>
<p>Спочатку такий підхід може здатися сміховинним — чи не буде забагато можливостей для його практичності? Що ж, спробуймо. Околиця складається з трьох клітинок, кожна зі станом 0 або 1. Скількома можливими способами можна налаштувати стани околиці? Швидкий спосіб з’ясувати це — подумати про кожну конфігурацію сусідства як про бінарне число. Бінарні числа мають <em>основу</em>, що дорівнює 2, тобто вони представлені лише двома можливими цифрами (0 і 1). У цьому випадку кожна конфігурація сусідства відповідає 3- бітовому числу, а скільки значень можна представити за допомогою 3-х біт? Вісім, від 0 (000) до 7 (111). На малюнку 7.7 показано, як.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;125.00000000000001&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/865b52f31d5e1386ba4b40e8ee9fc90b/22e6c/07_ca_8.webp 576w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/de347/07_ca_8.webp 1152w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/a9c8c/07_ca_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/865b52f31d5e1386ba4b40e8ee9fc90b/3a503/07_ca_8.png" data-srcset="./static/865b52f31d5e1386ba4b40e8ee9fc90b/ee6c3/07_ca_8.png 576w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/29acb/07_ca_8.png 1152w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/3a503/07_ca_8.png 2304w" alt="Малюнок 7.7: Підрахунок 3-х бітів у двійковій системі або вісім можливих конфігурацій оточення із трьох клітинок"/></picture><noscript><picture><source type="image/webp" srcSet="./static/865b52f31d5e1386ba4b40e8ee9fc90b/22e6c/07_ca_8.webp 576w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/de347/07_ca_8.webp 1152w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/a9c8c/07_ca_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/865b52f31d5e1386ba4b40e8ee9fc90b/3a503/07_ca_8.png" srcSet="./static/865b52f31d5e1386ba4b40e8ee9fc90b/ee6c3/07_ca_8.png 576w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/29acb/07_ca_8.png 1152w,./static/865b52f31d5e1386ba4b40e8ee9fc90b/3a503/07_ca_8.png 2304w" alt="Малюнок 7.7: Підрахунок 3-х бітів у двійковій системі або вісім можливих конфігурацій оточення із трьох клітинок"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.7: Підрахунок 3-х бітів у двійковій системі або вісім можливих конфігурацій оточення із трьох клітинок</figcaption>
</figure>
<p>Після визначення всіх можливих комбінацій сусідства для кожної такої конфігурації вказується результат (нове значення стану: 0 або 1). В оригінальній нотації Вольфрама й інших поширених варіаціях ці конфігурації записані в порядку спадання. Малюнок 7.8 слідує цій у мові, починаючи зі 111 і ведучи зворотний відлік до 000.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;400&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/0ac0651f748517bd2a6f8520fcbda74f/ddb93/07_ca_9.webp 576w,./static/0ac0651f748517bd2a6f8520fcbda74f/81149/07_ca_9.webp 1152w,./static/0ac0651f748517bd2a6f8520fcbda74f/eaf0e/07_ca_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/0ac0651f748517bd2a6f8520fcbda74f/52ed5/07_ca_9.png" data-srcset="./static/0ac0651f748517bd2a6f8520fcbda74f/adbc2/07_ca_9.png 576w,./static/0ac0651f748517bd2a6f8520fcbda74f/16c81/07_ca_9.png 1152w,./static/0ac0651f748517bd2a6f8520fcbda74f/52ed5/07_ca_9.png 2304w" alt="Малюнок 7.8: Набір правил показує результат для кожної можливої конфігурації з трьох клітин"/></picture><noscript><picture><source type="image/webp" srcSet="./static/0ac0651f748517bd2a6f8520fcbda74f/ddb93/07_ca_9.webp 576w,./static/0ac0651f748517bd2a6f8520fcbda74f/81149/07_ca_9.webp 1152w,./static/0ac0651f748517bd2a6f8520fcbda74f/eaf0e/07_ca_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/0ac0651f748517bd2a6f8520fcbda74f/52ed5/07_ca_9.png" srcSet="./static/0ac0651f748517bd2a6f8520fcbda74f/adbc2/07_ca_9.png 576w,./static/0ac0651f748517bd2a6f8520fcbda74f/16c81/07_ca_9.png 1152w,./static/0ac0651f748517bd2a6f8520fcbda74f/52ed5/07_ca_9.png 2304w" alt="Малюнок 7.8: Набір правил показує результат для кожної можливої конфігурації з трьох клітин"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.8: Набір правил показує результат для кожної можливої конфігурації з трьох клітин</figcaption>
</figure>
<p>Майте на увазі, що на відміну від методів додавання або усереднення, набори правил в елементарному КА не дотримуються жодної арифметичної логіки — це лише довільне відображення вхідних і вихідних даних. Вхідними даними є поточна конфігурація околиці (одна з восьми можливостей), а виходом є наступний стан середньої клітини поточної околиці (0 або 1 — ви самі визначаєте це правило).</p>
<p>Отримавши набір правил, ви можете запустити КА у дію. Стандартна модель Вольфрама полягає в тому, щоб розпочати покоління 0 із того, що всі клітини мають стан 0, за винятком середньої, яка має мати стан 1. Ви можете зробити це із сіткою будь-якого розміру (довжини), але для ясності я використаю одномірний КА з дев’яти клітин, щоб легко було вибрати середину (див. малюнок 7.9).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;255&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4da3695f56465dfbce633f24231fa777/a209d/07_ca_10.webp 576w,./static/4da3695f56465dfbce633f24231fa777/de9b1/07_ca_10.webp 1152w,./static/4da3695f56465dfbce633f24231fa777/3a78c/07_ca_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/4da3695f56465dfbce633f24231fa777/ba6d1/07_ca_10.png" data-srcset="./static/4da3695f56465dfbce633f24231fa777/58f03/07_ca_10.png 576w,./static/4da3695f56465dfbce633f24231fa777/94ce7/07_ca_10.png 1152w,./static/4da3695f56465dfbce633f24231fa777/ba6d1/07_ca_10.png 2304w" alt="Малюнок 7.9: Покоління 0 у КА Вольфрама з центральною клітиною із увімкненим станом"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4da3695f56465dfbce633f24231fa777/a209d/07_ca_10.webp 576w,./static/4da3695f56465dfbce633f24231fa777/de9b1/07_ca_10.webp 1152w,./static/4da3695f56465dfbce633f24231fa777/3a78c/07_ca_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/4da3695f56465dfbce633f24231fa777/ba6d1/07_ca_10.png" srcSet="./static/4da3695f56465dfbce633f24231fa777/58f03/07_ca_10.png 576w,./static/4da3695f56465dfbce633f24231fa777/94ce7/07_ca_10.png 1152w,./static/4da3695f56465dfbce633f24231fa777/ba6d1/07_ca_10.png 2304w" alt="Малюнок 7.9: Покоління 0 у КА Вольфрама з центральною клітиною із увімкненим станом"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.9: Покоління 0 у КА Вольфрама із центральною клітиною з увімкненим станом</figcaption>
</figure>
<p>Виходячи з набору правил на малюнку 7.8, як клітини змінюються від покоління 0 до покоління 1? На малюнку 7.10 показано, як цен тральна комірка з околицею 010 перемикається з 1 на 0. Спробуйте застосувати набір правил до решти клітин, щоб заповнити решту станів покоління 1.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;621&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/110edb4cffa1c52f5e0bed42307bca02/9291b/07_ca_11.webp 576w,./static/110edb4cffa1c52f5e0bed42307bca02/dbb91/07_ca_11.webp 1152w,./static/110edb4cffa1c52f5e0bed42307bca02/df0d2/07_ca_11.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/110edb4cffa1c52f5e0bed42307bca02/96b82/07_ca_11.png" data-srcset="./static/110edb4cffa1c52f5e0bed42307bca02/8ce1c/07_ca_11.png 576w,./static/110edb4cffa1c52f5e0bed42307bca02/e2d2c/07_ca_11.png 1152w,./static/110edb4cffa1c52f5e0bed42307bca02/96b82/07_ca_11.png 2304w" alt="Малюнок 7.10: Визначення стану для покоління 1 за допомогою набору правил КА"/></picture><noscript><picture><source type="image/webp" srcSet="./static/110edb4cffa1c52f5e0bed42307bca02/9291b/07_ca_11.webp 576w,./static/110edb4cffa1c52f5e0bed42307bca02/dbb91/07_ca_11.webp 1152w,./static/110edb4cffa1c52f5e0bed42307bca02/df0d2/07_ca_11.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/110edb4cffa1c52f5e0bed42307bca02/96b82/07_ca_11.png" srcSet="./static/110edb4cffa1c52f5e0bed42307bca02/8ce1c/07_ca_11.png 576w,./static/110edb4cffa1c52f5e0bed42307bca02/e2d2c/07_ca_11.png 1152w,./static/110edb4cffa1c52f5e0bed42307bca02/96b82/07_ca_11.png 2304w" alt="Малюнок 7.10: Визначення стану для покоління 1 за допомогою набору правил КА"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.10: Визначення стану для покоління 1 за допомогою набору правил КА</figcaption>
</figure>
<p>Тепер невелика зміна: замість представлення станів клітин за допомогою 0 і 1, я позначатиму їх візуальними ознаками — білим для 0 і чорним для 1 (див. малюнок 7.11). Хоча це може здатися суперечливим, оскільки 0 зазвичай означає чорний колір у комп’ютерній графіці, я використовую цю конвенцію, оскільки приклади в цій книзі мають білий фон, тому “увімкнення”  клітини відповідатиме зміні її кольору з білого на чорний.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;623&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/772fa182ad8975883e91c6bf0422a4fe/24d7d/07_ca_12.webp 576w,./static/772fa182ad8975883e91c6bf0422a4fe/a251f/07_ca_12.webp 1152w,./static/772fa182ad8975883e91c6bf0422a4fe/a691e/07_ca_12.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/772fa182ad8975883e91c6bf0422a4fe/61d4e/07_ca_12.png" data-srcset="./static/772fa182ad8975883e91c6bf0422a4fe/b6563/07_ca_12.png 576w,./static/772fa182ad8975883e91c6bf0422a4fe/c8599/07_ca_12.png 1152w,./static/772fa182ad8975883e91c6bf0422a4fe/61d4e/07_ca_12.png 2304w" alt="Малюнок 7.11: Біла клітинка означає стан 0, а чорна — 1"/></picture><noscript><picture><source type="image/webp" srcSet="./static/772fa182ad8975883e91c6bf0422a4fe/24d7d/07_ca_12.webp 576w,./static/772fa182ad8975883e91c6bf0422a4fe/a251f/07_ca_12.webp 1152w,./static/772fa182ad8975883e91c6bf0422a4fe/a691e/07_ca_12.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/772fa182ad8975883e91c6bf0422a4fe/61d4e/07_ca_12.png" srcSet="./static/772fa182ad8975883e91c6bf0422a4fe/b6563/07_ca_12.png 576w,./static/772fa182ad8975883e91c6bf0422a4fe/c8599/07_ca_12.png 1152w,./static/772fa182ad8975883e91c6bf0422a4fe/61d4e/07_ca_12.png 2304w" alt="Малюнок 7.11: Біла клітинка означає стан 0, а чорна — 1"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.11: Біла клітинка означає стан 0, а чорна — 1</figcaption>
</figure>
<p>З цим переходом від числових представлень до візуальних форм ви побачите захопливу динаміку та патерни КА! Щоб показати їх ще наочніше, замість того, щоб малювати лише одне покоління за раз, я почну складати їх у стопки, причому кожне нове покоління з’являтиметься під попереднім, як показано на малюнку 7.12.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;907.9999999999999&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/ba8619c9868676b8952e2caaa4140aea/079c7/07_ca_13.webp 576w,./static/ba8619c9868676b8952e2caaa4140aea/35231/07_ca_13.webp 1152w,./static/ba8619c9868676b8952e2caaa4140aea/854a0/07_ca_13.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/ba8619c9868676b8952e2caaa4140aea/0560b/07_ca_13.png" data-srcset="./static/ba8619c9868676b8952e2caaa4140aea/bed23/07_ca_13.png 576w,./static/ba8619c9868676b8952e2caaa4140aea/43273/07_ca_13.png 1152w,./static/ba8619c9868676b8952e2caaa4140aea/0560b/07_ca_13.png 2304w" alt="Малюнок 7.12: Перетворення сітки з 0 і 1 на білі та чорні квадрати"/></picture><noscript><picture><source type="image/webp" srcSet="./static/ba8619c9868676b8952e2caaa4140aea/079c7/07_ca_13.webp 576w,./static/ba8619c9868676b8952e2caaa4140aea/35231/07_ca_13.webp 1152w,./static/ba8619c9868676b8952e2caaa4140aea/854a0/07_ca_13.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/ba8619c9868676b8952e2caaa4140aea/0560b/07_ca_13.png" srcSet="./static/ba8619c9868676b8952e2caaa4140aea/bed23/07_ca_13.png 576w,./static/ba8619c9868676b8952e2caaa4140aea/43273/07_ca_13.png 1152w,./static/ba8619c9868676b8952e2caaa4140aea/0560b/07_ca_13.png 2304w" alt="Малюнок 7.12: Перетворення сітки з 0 і 1 на білі та чорні квадрати"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.12: Перетворення сітки з 0-ми й 1-ми на білі та чорні квадрати</figcaption>
</figure>
<p>Фігура з низькою роздільною здатністю, яка показана на малюнку 7.12, є <strong>трикутником Серпінського</strong>. Він названий на честь польського математика Вацлава Серпінського і це також відомий приклад <strong>фракталу</strong>. Я докладніше розгляну фрактали у <a href="/fractals#section-fractals">Розділі 8</a>, але, коротко кажучи, це моделі, в яких ті самі фігури повторюються в різних масштабах. Щоб краще зрозуміти це, на малюнку 7.13 показано КА з більшою кількістю поколінь і більшим розміром сітки.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;600&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#e8e8e8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/ce7e94b17a9690f8b4182e120755263f/cf86d/07_ca_14.webp 450w,./static/ce7e94b17a9690f8b4182e120755263f/7ce7a/07_ca_14.webp 900w,./static/ce7e94b17a9690f8b4182e120755263f/2c91d/07_ca_14.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_14.png" data-srcset="./static/ce7e94b17a9690f8b4182e120755263f/eda37/07_ca_14.png 450w,./static/ce7e94b17a9690f8b4182e120755263f/f2f87/07_ca_14.png 900w,./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_14.png 1800w" alt="Малюнок 7.13: Елементарний КА Вольфрама"/></picture><noscript><picture><source type="image/webp" srcSet="./static/ce7e94b17a9690f8b4182e120755263f/cf86d/07_ca_14.webp 450w,./static/ce7e94b17a9690f8b4182e120755263f/7ce7a/07_ca_14.webp 900w,./static/ce7e94b17a9690f8b4182e120755263f/2c91d/07_ca_14.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_14.png" srcSet="./static/ce7e94b17a9690f8b4182e120755263f/eda37/07_ca_14.png 450w,./static/ce7e94b17a9690f8b4182e120755263f/f2f87/07_ca_14.png 900w,./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_14.png 1800w" alt="Малюнок 7.13: Елементарний КА Вольфрама"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.13: Елементарний КА Вольфрама</figcaption>
</figure>
<p>На малюнку 7.14 знову показано КА, цього разу з клітинами шириною лише в один піксель і набагато вищою роздільною здатністю.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;600&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/5ec9c72c8d09a61e3c548349f81c40ea/cf86d/07_ca_15.webp 450w,./static/5ec9c72c8d09a61e3c548349f81c40ea/7ce7a/07_ca_15.webp 900w,./static/5ec9c72c8d09a61e3c548349f81c40ea/2c91d/07_ca_15.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/5ec9c72c8d09a61e3c548349f81c40ea/6f677/07_ca_15.png" data-srcset="./static/5ec9c72c8d09a61e3c548349f81c40ea/eda37/07_ca_15.png 450w,./static/5ec9c72c8d09a61e3c548349f81c40ea/f2f87/07_ca_15.png 900w,./static/5ec9c72c8d09a61e3c548349f81c40ea/6f677/07_ca_15.png 1800w" alt="Малюн ок 7.14: Елементарний КА Вольфрама з вищою роздільною здатністю"/></picture><noscript><picture><source type="image/webp" srcSet="./static/5ec9c72c8d09a61e3c548349f81c40ea/cf86d/07_ca_15.webp 450w,./static/5ec9c72c8d09a61e3c548349f81c40ea/7ce7a/07_ca_15.webp 900w,./static/5ec9c72c8d09a61e3c548349f81c40ea/2c91d/07_ca_15.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/5ec9c72c8d09a61e3c548349f81c40ea/6f677/07_ca_15.png" srcSet="./static/5ec9c72c8d09a61e3c548349f81c40ea/eda37/07_ca_15.png 450w,./static/5ec9c72c8d09a61e3c548349f81c40ea/f2f87/07_ca_15.png 900w,./static/5ec9c72c8d09a61e3c548349f81c40ea/6f677/07_ca_15.png 1800w" alt="Малюнок 7.14: Елементарний КА Вольфрама з вищою роздільною здатністю"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.14: Елементарний КА Вольфрама з вищою роздільною здатністю</figcaption>
</figure>
<p>Візьміть хвилинку, щоб зрозуміти величність того, що ви щойно побачили. Використовуючи неймовірно просту систему нулів і одиниць з невеликими околицями з трьох клітинок, я зміг створити таку ж складну та детальну форму, як трикутник Серпінського. У цьому краса складних систем.</p>
<p>Звичайно, цей конкретний результат стався не випадково. Для малюнку 7.8 я вибрав конкретний набір правил, тому що знав який патерн він створить. Простий акт визначення набору правил не гарантує візуально захопливих результатів. Насправді для одномірного КА, в якому кожна клітина може мати два можливих стани, існує рівно 256 можливих наборів правил і лише кілька з них відповідають трикутнику Серпінського. Звідки я знаю, що існує 256 можливих наборів правил? Це можна порахувати за допомогою бінарної математики.</p>
<h3 id="defining-rulesets"><a class="heading-link" href="#defining-rulesets">Визначення наборів правил</a></h3>
<p>Погляньте на малюнок 7.7 і знову зверніть увагу на вісім можливих конфігурацій сусідства, від 000 до 111. Це вхідні конфігураційні дані для набору правил і вони залишаються постійними для різних наборів правил. Лише вихідні дані відрізняються від одного набору правил до іншого — індивідуальний 0 або 1 у парі з кожною конфігурацією сусідства. На малюнку 7.8 зображено набір правил, що містить нулі та одиниці. На малюнку 7.15 показано той самий набір правил, візуалізований білими й чорними квадратами.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;223.99999999999997&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d1254d5012e41a452887b62821698f76/2dbfd/07_ca_16.webp 576w,./static/d1254d5012e41a452887b62821698f76/196a8/07_ca_16.webp 1152w,./static/d1254d5012e41a452887b62821698f76/c20ac/07_ca_16.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/d1254d5012e41a452887b62821698f76/9bcd1/07_ca_16.png" data-srcset="./static/d1254d5012e41a452887b62821698f76/23d55/07_ca_16.png 576w,./static/d1254d5012e41a452887b62821698f76/4a7f9/07_ca_16.png 1152w,./static/d1254d5012e41a452887b62821698f76/9bcd1/07_ca_16.png 2304w" alt="Малюнок 7.15: Представлення набору правил (такого самого як на малюнку 7.8) з білими й чорними квадратами"/></picture><noscript><picture><source type="image/webp" srcSet="./static/d1254d5012e41a452887b62821698f76/2dbfd/07_ca_16.webp 576w,./static/d1254d5012e41a452887b62821698f76/196a8/07_ca_16.webp 1152w,./static/d1254d5012e41a452887b62821698f76/c20ac/07_ca_16.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/d1254d5012e41a452887b62821698f76/9bcd1/07_ca_16.png" srcSet="./static/d1254d5012e41a452887b62821698f76/23d55/07_ca_16.png 576w,./static/d1254d5012e41a452887b62821698f76/4a7f9/07_ca_16.png 1152w,./static/d1254d5012e41a452887b62821698f76/9bcd1/07_ca_16.png 2304w" alt="Малюнок 7.15: Представлення набору правил (такого самого як на малюнку 7.8) з білими й чорними квадратами"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.15: Представлення набору правил (такого самого як на малюнку 7.8) з білими й чорними квадратами</figcaption>
</figure>
<p>Оскільки вісім можливих вхідних комбінацій є однаковими, незважаючи ні на що, можливим скороченням для позначення набору правил є визначення лише вихідних значень із записом їх у вигляді послідовності з восьми 0 або 1, іншими словами, 8-бітного бінарного числа. Наприклад, набір правил на малюнку 7.15  може бути записаний як 01011010. Правий 0 відповідає вхідній конфігурації 000, 1 поруч із нею відповідає до 001 і так далі. На вебсайті Вольфрама правила КА проілюстровано за допомогою комбінації цього двійкового скорочення та представлення чорно-білих квадратів, що дає зображення, як на малюнку 7.16.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;350&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/a2ff719228ef1ceb8f4970382bc40811/a534c/07_ca_17.webp 576w,./static/a2ff719228ef1ceb8f4970382bc40811/97e3a/07_ca_17.webp 1152w,./static/a2ff719228ef1ceb8f4970382bc40811/b1b96/07_ca_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/a2ff719228ef1ceb8f4970382bc40811/48471/07_ca_17.png" data-srcset="./static/a2ff719228ef1ceb8f4970382bc40811/9e251/07_ca_17.png 576w,./static/a2ff719228ef1ceb8f4970382bc40811/a6342/07_ca_17.png 1152w,./static/a2ff719228ef1ceb8f4970382bc40811/48471/07_ca_17.png 2304w" alt="Малюнок 7.16: Як вебсайт Вольфрама представляє набір правил"/></picture><noscript><picture><source type="image/webp" srcSet="./static/a2ff719228ef1ceb8f4970382bc40811/a534c/07_ca_17.webp 576w,./static/a2ff719228ef1ceb8f4970382bc40811/97e3a/07_ca_17.webp 1152w,./static/a2ff719228ef1ceb8f4970382bc40811/b1b96/07_ca_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/a2ff719228ef1ceb8f4970382bc40811/48471/07_ca_17.png" srcSet="./static/a2ff719228ef1ceb8f4970382bc40811/9e251/07_ca_17.png 576w,./static/a2ff719228ef1ceb8f4970382bc40811/a6342/07_ca_17.png 1152w,./static/a2ff719228ef1ceb8f4970382bc40811/48471/07_ca_17.png 2304w" alt="Малюнок 7.16: Як вебсайт Вольфрама представляє набір правил"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.16: Як вебсайт Вольфрама представляє набір правил</figcaption>
</figure>
<p>Я вже казав, що кожен набір правил можна звести до 8-бітного числа, тож скільки тоді існує комбінацій із восьми 0 та 1? Їх рівно <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> або 256. Можливо, ви пам’ятаєте про таку саму кількість значень при налаштуванні каналів для RGB-кольорів у p5.js. Коли ви пишете <code>background(r, g, b)</code>, кожен компонент кольору (червоний, зелений і синій) представляється 8-бітним числом у діапазоні від 0 до 255 у десятковій чи від 00000000 до 11111111 у двійковій системі числення.</p>
<p>Набір правил на малюнку 7.16 можна назвати правилом 01011010, але Вольфрам натомість називає його правилом 90. Звідки береться 90? Щоб зробити найменування набору правил ще більш лаконічним, Вольфрам використовує десяткове представлення чисел, а не двійкове. Щоб назвати правило, ви перетворюєте його 8-розрядне двійкове число в десяткове. Двійкове число 01011010 перетворюється на десяткове число 90, тому воно і називається правилом 90.</p>
<p>Оскільки існує 256 можливих комбінацій з восьми 0 і 1, існує також 256 унікальних наборів правил. Перевірмо ще один. Як щодо правила 11011110 або, інакше кажучи, правила 222? На малюнку 7.17 показано, як виглядає результат.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;600&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#080808;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/2533af5c3ebf16406a753f5d27ca1932/cf86d/07_ca_18.webp 450w,./static/2533af5c3ebf16406a753f5d27ca1932/7ce7a/07_ca_18.webp 900w,./static/2533af5c3ebf16406a753f5d27ca1932/2c91d/07_ca_18.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/2533af5c3ebf16406a753f5d27ca1932/6f677/07_ca_18.png" data-srcset="./static/2533af5c3ebf16406a753f5d27ca1932/eda37/07_ca_18.png 450w,./static/2533af5c3ebf16406a753f5d27ca1932/f2f87/07_ca_18.png 900w,./static/2533af5c3ebf16406a753f5d27ca1932/6f677/07_ca_18.png 1800w" alt="Малюнок 7.17: Елементарний КА Вольфрама, правило 222"/></picture><noscript><picture><source type="image/webp" srcSet="./static/2533af5c3ebf16406a753f5d27ca1932/cf86d/07_ca_18.webp 450w,./static/2533af5c3ebf16406a753f5d27ca1932/7ce7a/07_ca_18.webp 900w,./static/2533af5c3ebf16406a753f5d27ca1932/2c91d/07_ca_18.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/2533af5c3ebf16406a753f5d27ca1932/6f677/07_ca_18.png" srcSet="./static/2533af5c3ebf16406a753f5d27ca1932/eda37/07_ca_18.png 450w,./static/2533af5c3ebf16406a753f5d27ca1932/f2f87/07_ca_18.png 900w,./static/2533af5c3ebf16406a753f5d27ca1932/6f677/07_ca_18.png 1800w" alt="Малюнок 7.17: Елементарний КА Вольфрама, правило 222"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.17: Елементарний КА Вольфрама, правило 222</figcaption>
</figure>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;600&#x27; width=&#x27;800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#b8b8a8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/458aabdc6e0e82c3c72d81c97ba3702b/b5535/07_ca_19.webp 200w,./static/458aabdc6e0e82c3c72d81c97ba3702b/f5c71/07_ca_19.webp 400w,./static/458aabdc6e0e82c3c72d81c97ba3702b/0d27e/07_ca_19.webp 800w" sizes="(min-width: 800px) 800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 800px) 800px, 100vw" decoding="async" loading="lazy" data-src="./static/458aabdc6e0e82c3c72d81c97ba3702b/d0b9c/07_ca_19.jpg" data-srcset="./static/458aabdc6e0e82c3c72d81c97ba3702b/90ed1/07_ca_19.jpg 200w,./static/458aabdc6e0e82c3c72d81c97ba3702b/2070e/07_ca_19.jpg 400w,./static/458aabdc6e0e82c3c72d81c97ba3702b/d0b9c/07_ca_19.jpg 800w" alt="Малюнок 7.18: Черепашка конуса текстильного — конічного молюска (Conus textile), Великий Бар’єрний риф, Австралія. (фото Річарда Лінга)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/458aabdc6e0e82c3c72d81c97ba3702b/b5535/07_ca_19.webp 200w,./static/458aabdc6e0e82c3c72d81c97ba3702b/f5c71/07_ca_19.webp 400w,./static/458aabdc6e0e82c3c72d81c97ba3702b/0d27e/07_ca_19.webp 800w" sizes="(min-width: 800px) 800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 800px) 800px, 100vw" decoding="async" loading="lazy" src="./static/458aabdc6e0e82c3c72d81c97ba3702b/d0b9c/07_ca_19.jpg" srcSet="./static/458aabdc6e0e82c3c72d81c97ba3702b/90ed1/07_ca_19.jpg 200w,./static/458aabdc6e0e82c3c72d81c97ba3702b/2070e/07_ca_19.jpg 400w,./static/458aabdc6e0e82c3c72d81c97ba3702b/d0b9c/07_ca_19.jpg 800w" alt="Малюнок 7.18: Черепашка конуса текстильного — конічного молюска (Conus textile), Великий Бар’єрний риф, Австралія. (фото Річарда Лінга)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 7.18: Черепашка конуса текстильного — конічного молюска (<em>Conus textile</em>), Великий Бар’єрний риф, Австралія. (фото Річарда Лінга)</figcaption>
  </figure>
</div>
<p>У результаті маємо впізнавану форму, хоча вона, звичайно, не така захоплива, як трикутник Серпінського. Як я вже говорив раніше, більшість із 256 елементарних наборів правил не дають привабливих результатів. Проте все одно неймовірно, що навіть кілька з цих наборів правил — простих систем клітин лише з двома можливими станами — можуть створювати захопливі візерунки, які можна побачити в природі щодня. Наприклад, на малюнку 7.18 показана черепашка молюска, що нагадує правило 30. Це демонструє, наскільки цінними можуть бути КА-ти у моделюванні та створенні патернів.</p>
<p>Перш ніж зайти надто далеко в опис результатів різних наборів правил, подивімось, як створити програму p5.js, яка генерує та візуалізує елементарний КА Вольфрама.</p>
<h3 id="programming-an-elementary-ca"><a class="heading-link" href="#programming-an-elementary-ca">Програмування елементарного КА</a></h3>
<p>Ви можете подумати: “Гаразд, у мене є клітина. І вона має такі властивості, як стан, покоління до якого вона належить, хто її сусіди та де вона знаходиться на екрані. І, можливо, вона має функції, для зображення себе та визначення свого нового стану”. Це чудовий напрямок думок і, ймовірно, він приведе до написання подібного коду:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Однак це не та дорога, якою я хочу піти. Далі у цьому розділі я обговорю, чому об’єктно-орієнтований підхід може виявитися цінним у розробці симуляції КА, але для початку легше працювати з більш елементарною структурою даних. Зрештою, що таке елементарний КА, як не список із 0 і 1? Чому б не описати створення одномірного КА за допомогою масиву?</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> cells = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Цей масив відповідає рядку клітин, зображеному на малюнку 7.19.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;135&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/384c9ed789fb8783d3ce2e0e30ece3ea/2f3fc/07_ca_20.webp 576w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/3c1e8/07_ca_20.webp 1152w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/f1461/07_ca_20.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/384c9ed789fb8783d3ce2e0e30ece3ea/f5a38/07_ca_20.png" data-srcset="./static/384c9ed789fb8783d3ce2e0e30ece3ea/f585a/07_ca_20.png 576w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/11ec5/07_ca_20.png 1152w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/f5a38/07_ca_20.png 2304w" alt="Малюнок 7.19: Одне покоління одномірного КА"/></picture><noscript><picture><source type="image/webp" srcSet="./static/384c9ed789fb8783d3ce2e0e30ece3ea/2f3fc/07_ca_20.webp 576w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/3c1e8/07_ca_20.webp 1152w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/f1461/07_ca_20.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/384c9ed789fb8783d3ce2e0e30ece3ea/f5a38/07_ca_20.png" srcSet="./static/384c9ed789fb8783d3ce2e0e30ece3ea/f585a/07_ca_20.png 576w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/11ec5/07_ca_20.png 1152w,./static/384c9ed789fb8783d3ce2e0e30ece3ea/f5a38/07_ca_20.png 2304w" alt="Малюнок 7.19: Одне покоління одномірного КА"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.19: Одне покоління одномірного КА</figcaption>
</figure>
<p>Щоб зобразити цей масив, я перевіряю значення кожного елементу відповідно до 0 чи 1, вибираю відповідний колір заливки й малюю прямокутник:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cells.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p>Ітерація через кожну клітину.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (cells[i] === <span class="hljs-number">0</span>) {
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
  }
</code></pre><div class="comment"><p>Створення заливки залежно від стану клітини (0 або 1).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">rect</span>(i * <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Масив описує стан клітини у поточному поколінні. Тепер мені потрібен механізм для обчислення станів наступних поколінь. Ось псевдокод, який описує, що я хочу досягти:</p>
<p>Дл я кожної клітини у масиві:</p>
<ol>
  <li>Перегляньте сусідні стани: ліворуч, посередині, праворуч.</li>
  <li>Знайдіть нове значення для стану клітини відповідно до набору правил.</li>
  <li>Установіть для клітини знайдене нове значення.</li>
</ol>
<p>Цей псевдокод може навіяти написання наступного коду:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cells.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p>Для кожної клітини у масиві...</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> left   = cells[i - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">let</span> middle = cells[i];
  <span class="hljs-keyword">let</span> right  = cells[i + <span class="hljs-number">1</span>];
</code></pre><div class="comment"><p>...переглянути її околицю.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> newstate = <span class="hljs-title function_">rules</span>(left, middle, right);
</code></pre><div class="comment"><p>Знайти нове значення відповідно до правил.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  cells[i] = newstate;
</code></pre><div class="comment"><p>Установити для клітини знайдене нове значення.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я досить близький до того, щоб зробити це правильно, але маю вирішити кілька проблем. По-перше, я передаю обчислення нового значення для стану функції під назвою <code>rules()</code>. Очевидно, що мені доведеться написати цю функцію, тому моя робота ще не закінчена, але я прагну тут до модульності. Мені потрібен цикл <code>for</code>, який забезпечує організацію для базового керування будь-яким КА, незалежно від конкретного набору правил. Якщо я хочу випробувати різні набори правил, мені взагалі не доведеться торкатися цієї частини. Я можу просто переписати функцію <code>rules()</code>, щоб по-іншому обчислювати нові стани.</p>
<p>Тож мені все ще потрібно написати функцію <code>rules()</code>, але важливіше те, що я припустився однієї незначної та однієї великої помилки в циклі <code>for</code>. Перегляньте код уважніше.</p>
<p>По-перше, зверніть увагу, як легко дивитися на сусідів клітини. Оскільки масив — це впорядкований список даних, я можу використовувати нумерацію індексів, щоб дізнатися, які клітини поруч із якими. Наприклад, я знаю, що клітина номер 15 ліворуч має клітину 14 і 16 — праворуч. Загалом я можу сказати, що для будь-якої клітини <code>i</code> її сусідами є <code>i - 1</code> та <code>i + 1</code>.</p>
<p>То що я зробив не так? Подумайте про те, як буде виконуватися код. Під час першого проходження циклу індекс клітинки <code>i</code> дорівнює <code>0</code>. Код хоче переглянути сусідів клітини під індексом 0. Зліва це <code>i - 1</code> або <code>-1</code>. Ой! Масив за визначенням не має елемента з індексом <code>-1</code>. Він починається з <code>0</code>.</p>
<p>Я згадував про цю проблему граничних випадків раніше в цьому розділі й сказав, що можу потурбуватися про це пізніше. Це пізніше вже зараз. Як мені обробляти клітини на межі, які не мають сусіда зліва чи справа? Ось три можливі вирішення цього питання:</p>
<ol>
  <li><strong>Краї залишаються незмінними.</strong> Це, мабуть, найпростіше рішення. Не турбуйтеся про переоцінку країв і завжди залишайте значення їх стану постійними (0 або 1).</li>
  <li><strong>Краї згортаються один до одного.</strong> Уявіть КА як смужку паперу та перетворіть цю смужку на кільце. Клітина з лівого краю стає сусідом клітини з правого краю, і навпаки. Це може створити враження нескінченної сітки, і це, мабуть, найпоширеніше рішення.</li>
  <li><strong>Краї мають різні околиці та правила.</strong> Якби я захотів, я міг би обробляти клітинки на краях по-іншому та створити правила для осередків, які мають околиці у дві, а не три клітини. Ви можете зробити це за деяких обставин, але в цьому випадку потрібно буде багато додаткових рядків коду з невеликою користю.</li>
</ol>
<p>Щоб зробити код найпростішим для читання та розуміння прямо зараз, я виберу варіант 1 і пропущу крайні клітини, залишивши їх значення незмінними. Це можна зробити, якщо почати цикл на одну клітину пізніше і завершити його на одну клітину раніше:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="bold pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; cells.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
  <span class="hljs-keyword">let</span> left   = cells[i - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">let</span> middle = cells[i];
  <span class="hljs-keyword">let</span> right  = cells[i + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">let</span> newstate = <span class="hljs-title function_">rules</span>(left, middle, right);
  cells[i] = newstate;
}
</code></pre><div class="comment"><p>Цикл, який ігнорує першу та останню клітини.</p></div></div></div>
<p>Мені потрібно вирішити ще одну проблему і її ідентифікація є абсолютно фундаментальною для методів програмування моделюва ння КА. Проблема незначна і не викликає помилку, КА просто не працюватиме належним чином. Проблема знаходиться у цьому рядку коду:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  cells[i] = newstate;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Це може здатися абсолютно невинним. Зрештою, коли я обчислив нове значення стану, я хочу призначити комірці її новий стан. Але подумайте про наступну ітерацію циклу <code>for</code>. Припустімо, новий стан клітини 5 щойно обчислено, і цикл переходить до клітини 6. Що станеться далі?</p>
<p><span class="callout highlight"> Клітина 6, покоління 1 = функція станів клітин 5, 6 і 7 із покоління 0</span></p>
<p>Новий стан клітини є функцією попередніх сусідніх станів, тому в цьому випадку значення клітини 5 у поколінні 0 потрібне для обчислення нового стану клітини 6 у поколінні 1. Чи зберіг я значення клітини 5 із покоління 0? Ні! Пам’ятайте, що цей рядок коду було щойно виконано, коли <code>i</code> дорівнював <code>5</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  cells[i] = newstate;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо це станеться, то стан клітини 5 у поколінні 0 зникне і <code>cells[5]</code> тепер зберігатиме значення для покоління 1. Я не можу перезаписувати значення в масиві під час обробки масиву, тому що мені потрібні ці значення для обчислення нових значень!</p>
<p>Розв’язання цієї проблеми полягає в тому, щоб мати два масиви, один для зберігання станів поточного покоління, а інший для станів наступного покоління. Щоб спростити собі повторну ініціалізацію масиву, я скористаюся методом масиву <code>slice()</code>, який створить копію масиву:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="bold pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> newcells = cells.<span class="hljs-title function_">slice</span>();
</code></pre><div class="comment"><p>Створення іншого масиву для зберігання станів для наступного покоління.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; cells.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> left   = cells[i - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">let</span> middle = cells[i];
  <span class="hljs-keyword">let</span> right  = cells[i + <span class="hljs-number">1</span>];
</code></pre><div class="comment"><p>Перегляд станів поточного масиву.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> newstate = <span class="hljs-title function_">rules</span>(left, middle, right);
</code></pre><div class="comment"><p></p></div></div><div class="bold pair split"><pre><code class="hljs code language-javascript">  newcells[i] = newstate;
</code></pre><div class="comment"><p>Збереження нового стану у новому масиві.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Після повної обробки масиву значень поточного покоління, для змінної <code>cells</code> можна призначити новий масив станів, фактично відкидаючи значення попереднього покоління:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="bold pair split"><pre><code class="hljs code language-javascript">cells = newcells;
</code></pre><div class="comment"><p>Нове покоління стає поточним.</p></div></div></div>
<p>Я майже закінчив, але мені потрібно ще визначити функцію <code>rules()</code>, яка обчислюватиме нове значення стану на основі околиці (лівої, середньої й правої клітини). Я знаю, що функція має повертати ціле число (0 або 1), а також отримувати три аргументи (для трьох сусідів):</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rules</span>(<span class="hljs-params">a, b, c</span>) { <span class="hljs-keyword">return</span> _______ }
</code></pre><div class="comment"><p>Сигнатура функції: отримує 3 цілі числа і повертає одне.</p></div></div></div>
<p>Я міг би написати цю функцію різними способами, але я хотів би почати з розгорнутого варіанту, який, сподіваюся, надасть чітку ілюстрацію того, що відбувається. Як зберігати набір правил? Пам’ятайте, що набір правил — це набір із 8 бітів (0 або 1), які визначають результат для кожної можливої конфігурації сусідства. Якщо вам потрібно пригадати, малюнок 7.20 показує нотацію Вольфрама для набору правил трикутника Серпінського, а також відповідні нулі та одиниці. Це повинно дати вам підказку щодо структури даних, яку я маю на увазі!</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;535&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/f23bf8da6671ebbbb5cc32d1c7d01c10/d24e9/07_ca_21.webp 576w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/f9675/07_ca_21.webp 1152w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/dee1f/07_ca_21.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/f23bf8da6671ebbbb5cc32d1c7d01c10/be90e/07_ca_21.png" data-srcset="./static/f23bf8da6671ebbbb5cc32d1c7d01c10/95b86/07_ca_21.png 576w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/499ab/07_ca_21.png 1152w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/be90e/07_ca_21.png 2304w" alt="Малюнок 7.20: Візуальне представлення набору правил Вольфрама із цифровим кодуванням"/></picture><noscript><picture><source type="image/webp" srcSet="./static/f23bf8da6671ebbbb5cc32d1c7d01c10/d24e9/07_ca_21.webp 576w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/f9675/07_ca_21.webp 1152w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/dee1f/07_ca_21.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/f23bf8da6671ebbbb5cc32d1c7d01c10/be90e/07_ca_21.png" srcSet="./static/f23bf8da6671ebbbb5cc32d1c7d01c10/95b86/07_ca_21.png 576w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/499ab/07_ca_21.png 1152w,./static/f23bf8da6671ebbbb5cc32d1c7d01c10/be90e/07_ca_21.png 2304w" alt="Малюнок 7.20: Візуальне представлення набору правил Вольфрама із цифровим кодуванням"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.20: Візуальне представлення набору правил Вольфрама із цифровим кодуванням</figcaption>
</figure>
<p>Я можу зберегти цей набір правил у масиві:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> ruleset = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
</code></pre><div class="comment"><p></p></div></div></div>
<p>А потім я можу написати, наприклад, наступне:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">if</span> (a === <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">1</span> &amp;&amp; c === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">0</span>];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо клітина ліворуч, посередині та праворуч одночасно мають стан 1, то це відповідає конфігурації 111, тому новий стан має дорівнювати першому значенню в масиві <code>ruleset</code>. Дублювання цієї стратегії для всіх восьми можливостей виглядає наступним чином:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rules</span>(<span class="hljs-params">a, b, c</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span>      (a === <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">1</span> &amp;&amp; c === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">0</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">1</span> &amp;&amp; c === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">1</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">0</span> &amp;&amp; c === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">2</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">0</span> &amp;&amp; c === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">3</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">1</span> &amp;&amp; c === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">4</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">1</span> &amp;&amp; c === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">5</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">0</span> &amp;&amp; c === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">6</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a === <span class="hljs-number">0</span> &amp;&amp; b === <span class="hljs-number">0</span> &amp;&amp; c === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">7</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Мені подобається писати функцію <code>rules()</code> таким чином, оскільки вона рядок за рядком точно описує, що відбувається для кожної конфігурації сусідства. Однак це не краще рішення. Зреш тою, що, якщо замість двох станів КА матиме чотири можливі стани (від 0 до 3)? Раптом буде 64 можливі конфігурації сусідства. А якщо буде 10 можливих станів чи 1000 конфігурацій. Тільки уявіть собі програмування 29 можливих станів фон Неймана. Я б застряг, друкуючи тисячі й тисячі операторів <code>else...if</code>!</p>
<p>Іншим рішенням, хоча й не таким прозорим, є перетворення конфігурації сусідства (3-бітового числа) у звичайне ціле число та використання цього значення як індексу в масиві набору правил. Це можна зробити, використовуючи вбудовану JavaScript функцію <code>parseInt()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rules</span>(<span class="hljs-params">a, b, c</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;&quot;</span> + a + b + c;
</code></pre><div class="comment"><p>Швидкий спосіб об’єднати три числа у рядок.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">parseInt</span>(s, <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p>Двійка у другому аргументі вказує на те, що число має бути проаналізовано як двійкове (з основою 2).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> ruleset[index];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Однак у цього рішення є одна маленька проблема. Розглянемо правило 222:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> ruleset = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Скажімо, околиця, що перевіряється, має конфігурацію 111. Отриманий стан має дорівнювати індексу 0 із набору правил, виходячи з того, як я вперше написав функцію <code>rules()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">1</span> &amp;&amp; b === <span class="hljs-number">1</span> &amp;&amp; c === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">0</span>];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Двійкове число 111 перетворюється на десяткове число 7. Але я не хочу <code>ruleset[7]</code>, а хочу — <code>ruleset[0]</code>. Для цього мені потрібно інвертувати індекс перед пошуком стану в масиві <code>ruleset</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">7</span> - index];
</code></pre><div class="comment"><p>Інверсія індексу, щоб 0 перетворити на 7, 1 на 6 і так далі.</p></div></div></div>
<p>Тепер я маю все необхідне для обчислення поколінь елементарного КА Вольфрама. Ось як код виглядає разом:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> cells = [];
</code></pre><div class="comment"><p>Масив для клітин.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> ruleset = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
</code></pre><div class="comment"><p>Довільно вибраний набір правил: 90.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; width; i++) {
    cells[i] = <span class="hljs-number">0</span>;
  }
</code></pre><div class="comment"><p>Усі клітини починають зі стану 0...</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  cells[<span class="hljs-title function_">floor</span>(cells.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)] = <span class="hljs-number">1</span>;
</code></pre><div class="comment"><p>...за винятком центральної клітини зі станом 1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> nextgen = cells.<span class="hljs-title function_">slice</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; cells.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">let</span> left = cells[i - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">let</span> me = cells[i];
    <span class="hljs-keyword">let</span> right = cells[i + <span class="hljs-number">1</span>];
    nextgen[i] = <span class="hljs-title function_">rules</span>(left, me, right);
  }
</code></pre><div class="comment"><p>Обчислення наступного покоління.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  cells = nextgen;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rules</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;&quot;</span> + a + b + c;
  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">parseInt</span>(s, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">7</span> - index];
}
</code></pre><div class="comment"><p>Знаходження нового стану із набору правил.</p></div></div></div>
</div>
<p>Це чудово, але не вистачає ще однієї деталі: яка користь від КА, якщо ви його не бачите?</p>
<h3 id="drawing-an-elementary-ca"><a class="heading-link" href="#drawing-an-elementary-ca">Малювання елементарного КА</a></h3>
<p>Стандартна техніка малювання елементарного КА полягає в тому, щоб розташувати покоління одне над одним та намалювати кожну клітину у вигляді чорного (для стану 1) або білого (для стану 0) квадрата, як на малюнку 7.21. Проте, перш ніж реалізувати цю конкретну візуалізацію, я хотів би зазначити дві речі.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;600&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#e8e8e8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/ce7e94b17a9690f8b4182e120755263f/cf86d/07_ca_22.webp 450w,./static/ce7e94b17a9690f8b4182e120755263f/7ce7a/07_ca_22.webp 900w,./static/ce7e94b17a9690f8b4182e120755263f/2c91d/07_ca_22.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_22.png" data-srcset="./static/ce7e94b17a9690f8b4182e120755263f/eda37/07_ca_22.png 450w,./static/ce7e94b17a9690f8b4182e120755263f/f2f87/07_ca_22.png 900w,./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_22.png 1800w" alt="Малюнок 7.21: Правило 90 візуалізовано у вигляді стека поколінь"/></picture><noscript><picture><source type="image/webp" srcSet="./static/ce7e94b17a9690f8b4182e120755263f/cf86d/07_ca_22.webp 450w,./static/ce7e94b17a9690f8b4182e120755263f/7ce7a/07_ca_22.webp 900w,./static/ce7e94b17a9690f8b4182e120755263f/2c91d/07_ca_22.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_22.png" srcSet="./static/ce7e94b17a9690f8b4182e120755263f/eda37/07_ca_22.png 450w,./static/ce7e94b17a9690f8b4182e120755263f/f2f87/07_ca_22.png 900w,./static/ce7e94b17a9690f8b4182e120755263f/6f677/07_ca_22.png 1800w" alt="Малюнок 7.21: Правило 90 візуалізовано у вигляді стека поколінь"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.21: Правило 90 візуалізовано у вигляді стека поколінь</figcaption>
</figure>
<p>По-перше, ця візуальна інтерпретація даних абсолютно буквальна. Це корисно для демонстрації алгоритмів і результатів елементарного КА Вольфрама, але це не обов’язково для вашої особистої роботи. Ви навряд чи створите проєкт, який потребує саме цього алгоритму з таким візуальним стилем. Тож хоча навчання малювати КА таким чином допоможе вам зрозуміти та реалізовувати системи КА, ця навичка має бути лише як основа.</p>
<p>По-друге, той факт, що одномірний КА візуалізується за допомогою 2D зображення, може вводити в оману. Дуже важливо пам’ятати, що це <em>не</em> двомірний КА. Я просто вирішив показати історію всіх поколінь у вертикальному стосі. Ця техніка створює 2D зображення з багатьох екземплярів 1D даних, але сама система одномірна. Пізніше я покажу вам справжній двовимірний КА (Гра Життя) і розповім, як візуалізувати таку систему.</p>
<p>Хороша новина у тому, що намалювати елементарний КА не особливо складно. Я почну з відтворення одного покоління. Скажімо, кожна клітинка має бути квадратом 10 на 10 пікселів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> w = <span class="hljs-number">10</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо полотно має ширину 640 пікселів, КА матиме 64 клітинки. Звісно, я можу обчислити це значення динамічно, коли ініціалізую масив <code>cells</code> у функції <code>setup()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> cells = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-title function_">floor</span>(width / w));
</code></pre><div class="comment"><p>Обчислення кількості клітин, що вміщується поперек певної ширини.</p></div></div></div>
<p>Малювання клітин тепер вимагає ітерації по масиву та малювання квадрата на основі стану кожної клітини:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cells.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">fill</span>(cells[i] * <span class="hljs-number">255</span>);
</code></pre><div class="comment"><p>Помноживши стан клітини (0 або 1) на 255, результатом буде 0 або 255.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">square</span>(i * w, <span class="hljs-number">0</span>, w);
</code></pre><div class="comment"><p>x-положення — це індекс клітини, помножений на ширину клітини:
0, 10, 20, 30 і так далі до 640.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Два аспекти цього коду не вирішені. По-перше, при множенні стану клітини на 255, клітини зі станом 1 будуть білими, а клітини з 0 будуть чорними, що є протилежністю тому, що я спочатку задумував! Хоча це, звичайно, нормально, оскільки представлення кольорів є довільним, я виправлю це у кінцевому прикладі.</p>
<p>Важливішою проблемою є те, що <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення для кожного квадрата жорстко закодована на 0. Якщо я хочу, щоб покоління були розташовані одне під одним, де кожний ряд клітин зображатиме нове покоління, мені також потрібно обчислювати <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-позицію на основі номера покоління. Я можу досягти цього, додавши змінну <code>generation</code> та збільшуючи її кожного разу у функції <code>draw()</code>. Тепер, завдяки цим доповненням, я можу переглянути всю програму.</p>
<div data-type="example">
  <h3 id="example-71-wolfram-elementary-cellular-automata"><a class="heading-link" href="#example-71-wolfram-elementary-cellular-automata">Приклад 7.1: Елементарний клітинний автомат Вольфрама</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/07_ca/7_1_elementary_wolfram_ca"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/SaLy-OnPZ" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> cells;
</code></pre><div class="comment"><p>Масив клітин.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> generation = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Лічильник поколінь.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> w = <span class="hljs-number">10</span>;
</code></pre><div class="comment"><p>Розмір клітини.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> ruleset = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
</code></pre><div class="comment"><p>Правило 90.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  cells = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-title function_">floor</span>(width / w));
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cells.<span class="hljs-property">length</span>; i++) {
    cells[i] = <span class="hljs-number">0</span>;
  }
  cells[<span class="hljs-title function_">floor</span>(cells.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)] = <span class="hljs-number">1</span>;
</code></pre><div class="comment"><p>Масив нулів і одиниць.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; cells.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (cells[i] === <span class="hljs-number">1</span>) {
</code></pre><div class="comment"><p>Малювання лише клітин зі станом 1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">square</span>(i * w, generation * w, w);
</code></pre><div class="comment"><p>Встановлення y-положення відповідно до покоління.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> nextgen = cells.<span class="hljs-title function_">slice</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; cells.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">let</span> left = cells[i - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">let</span> me = cells[i];
    <span class="hljs-keyword">let</span> right = cells[i + <span class="hljs-number">1</span>];
    nextgen[i] = <span class="hljs-title function_">rules</span>(left, me, right);
  }
</code></pre><div class="comment"><p>Обчислення наступного покоління.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  cells = nextgen;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  generation++;
</code></pre><div class="comment"><p>Збільшення лічильника поколінь.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rules</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;&quot;</span> + a + b + c;
  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">parseInt</span>(s, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">return</span> ruleset[<span class="hljs-number">7</span> - index];
}
</code></pre><div class="comment"><p>Знаходження нового стану із набору правил.</p></div></div></div>
<p>Можливо, ви помітили оптимізацію, яку я зробив у цьому прикладі, щоб спростити малювання: я намалював суцільний білий фон і малював лише чорні квадрати, що зекономило роботу із малювання багатьох квадратів. Це рішення підходить не для всіх випадків, особливо якщо потрібні різноколірні клітини. Але конкретно в цьому простому випадку це забезпечує підвищення продуктивності.</p>
<p>Попри цю оптимізацію, інший аспект коду для малювання є надзвичайно неефективним: програма продовжує малювати покоління за поколінням, виходячи за межі нижньої частини полотна. Код на вебсайті книги містить просту умову для зупинки, але ви можете знайти інші підходи для розв&#x27;язання цієї проблеми (деякі згадуються у наступних вправах).</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-71"><a class="heading-link" href="#exercise-71">Вправа 7.1</a></h3>
  <p>Розширте приклад 7.1 з такою особливістю: коли КА досягне нижньої частини полотна, він має початися спочатку, але вже з новим, випадковим набором правил.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-72"><a class="heading-link" href="#exercise-72">Вправа 7.2</a></h3>
  <p>Дослідіть патерни, які виникають, коли ви ініціалізуєте клітини в поколінні 0 випадковими станами.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-73"><a class="heading-link" href="#exercise-73">Вправа 7.3</a></h3>
  <p>Візуалізуйте КА незвичним способом. Порушуйте всі правила, які тільки можете. Не прив’язуйтесь до використання квадратів на ідеальній сітці з чорними й білими кольорами.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-74"><a class="heading-link" href="#exercise-74">Вправа 7.4</a></h3>
  <p>Створіть візуалізацію КА, яка прокручується вгору зі збільшенням поколінь, щоб ви могли переглядати покоління до “нескінченності”. Підказка: замість того, щоб відстежувати одне покоління за раз, вам потрібно буде зберігати історію поколінь, завжди додаючи нове та видаляючи найстаріше для кожного кадру анімації.</p>
</div>
<h2 id="wolfram-classification"><a class="heading-link" href="#wolfram-classification">Класифікація Вольфрама</a></h2>
<p>Тепер, коли у вас є програма для візуалізації елементарного КА, ви можете надати йому будь-який бажаний набір правил і побачити результати. Яких результатів можна очікувати? Як я зазначав раніше, переважна більшість елементарних наборів правил КА дають візуально не надто цікаві результати, тоді як деякі призводять до дивовижно складних патернів, подібних до тих, що зустрічаються у природі. Вольфрам розділив діапазон результатів на чотири класи.</p>
<h3 id="class-1-uniformity"><a class="heading-link" href="#class-1-uniformity"><strong>Клас 1: Однорідний</strong></a></h3>
<p>Після певної кількості поколінь клітинні автомати класу 1 залишаються незмінними для кожної клітини. На них не дуже цікаво дивитися. Правило 222 є КА класу 1, якщо ви запустите його на достатню кількість поколінь, кожна клітинка зрештою стане і залишиться чорною (див. малюнок 7.22).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;450&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#080808;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/15206514671a1460f50f5e15646ea827/5117c/07_ca_23.webp 450w,./static/15206514671a1460f50f5e15646ea827/800b7/07_ca_23.webp 900w,./static/15206514671a1460f50f5e15646ea827/94669/07_ca_23.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/15206514671a1460f50f5e15646ea827/934ee/07_ca_23.png" data-srcset="./static/15206514671a1460f50f5e15646ea827/0c968/07_ca_23.png 450w,./static/15206514671a1460f50f5e15646ea827/1e111/07_ca_23.png 900w,./static/15206514671a1460f50f5e15646ea827/934ee/07_ca_23.png 1800w" alt="Малюнок 7.22: Правило 222"/></picture><noscript><picture><source type="image/webp" srcSet="./static/15206514671a1460f50f5e15646ea827/5117c/07_ca_23.webp 450w,./static/15206514671a1460f50f5e15646ea827/800b7/07_ca_23.webp 900w,./static/15206514671a1460f50f5e15646ea827/94669/07_ca_23.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/15206514671a1460f50f5e15646ea827/934ee/07_ca_23.png" srcSet="./static/15206514671a1460f50f5e15646ea827/0c968/07_ca_23.png 450w,./static/15206514671a1460f50f5e15646ea827/1e111/07_ca_23.png 900w,./static/15206514671a1460f50f5e15646ea827/934ee/07_ca_23.png 1800w" alt="Малюнок 7.22: Правило 222"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.22: Правило 222</figcaption>
</figure>
<h3 id="class-2-repetition"><a class="heading-link" href="#class-2-repetition"><strong>Клас 2: Повторюваний</strong></a></h3>
<p>Як і КА-ти класу 1, КА-ти класу 2 залишаються стабільними, але стани клітинок непостійні. Натомість вони коливаються за повторюваною схемою 0 і 1. У правилі 190 кожна клітина відповідає послідовності <code>11101110111011101110</code> (малюнок 7.23).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;450&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/2ebc63b9142a35528493e4d991394b6d/5117c/07_ca_24.webp 450w,./static/2ebc63b9142a35528493e4d991394b6d/800b7/07_ca_24.webp 900w,./static/2ebc63b9142a35528493e4d991394b6d/94669/07_ca_24.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/2ebc63b9142a35528493e4d991394b6d/934ee/07_ca_24.png" data-srcset="./static/2ebc63b9142a35528493e4d991394b6d/0c968/07_ca_24.png 450w,./static/2ebc63b9142a35528493e4d991394b6d/1e111/07_ca_24.png 900w,./static/2ebc63b9142a35528493e4d991394b6d/934ee/07_ca_24.png 1800w" alt="Малюнок 7.23: Правило 190"/></picture><noscript><picture><source type="image/webp" srcSet="./static/2ebc63b9142a35528493e4d991394b6d/5117c/07_ca_24.webp 450w,./static/2ebc63b9142a35528493e4d991394b6d/800b7/07_ca_24.webp 900w,./static/2ebc63b9142a35528493e4d991394b6d/94669/07_ca_24.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/2ebc63b9142a35528493e4d991394b6d/934ee/07_ca_24.png" srcSet="./static/2ebc63b9142a35528493e4d991394b6d/0c968/07_ca_24.png 450w,./static/2ebc63b9142a35528493e4d991394b6d/1e111/07_ca_24.png 900w,./static/2ebc63b9142a35528493e4d991394b6d/934ee/07_ca_24.png 1800w" alt="Малюнок 7.23: Правило 190"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.23: Правило 190</figcaption>
</figure>
<h3 id="class-3-random"><a class="heading-link" href="#class-3-random"><strong>Клас 3: Випадковий</strong></a></h3>
<p>КА-ти класу 3 виглядають випадково і не мають легко помітного патерну. Насправді правило 30 (малюнок 7.24) використовується як генератор випадкових чисел у програмному забезпеченні Wolfram Mathematica. Знову ж таки, ви можете бути вражені тим, що така прост а система з простими правилами може переходити у хаотичний і випадковий патерн.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;450&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/daf885880e94d868c8c4e04286de5164/5117c/07_ca_25.webp 450w,./static/daf885880e94d868c8c4e04286de5164/800b7/07_ca_25.webp 900w,./static/daf885880e94d868c8c4e04286de5164/94669/07_ca_25.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/daf885880e94d868c8c4e04286de5164/934ee/07_ca_25.png" data-srcset="./static/daf885880e94d868c8c4e04286de5164/0c968/07_ca_25.png 450w,./static/daf885880e94d868c8c4e04286de5164/1e111/07_ca_25.png 900w,./static/daf885880e94d868c8c4e04286de5164/934ee/07_ca_25.png 1800w" alt="Малюнок 7.24: Правило 30"/></picture><noscript><picture><source type="image/webp" srcSet="./static/daf885880e94d868c8c4e04286de5164/5117c/07_ca_25.webp 450w,./static/daf885880e94d868c8c4e04286de5164/800b7/07_ca_25.webp 900w,./static/daf885880e94d868c8c4e04286de5164/94669/07_ca_25.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/daf885880e94d868c8c4e04286de5164/934ee/07_ca_25.png" srcSet="./static/daf885880e94d868c8c4e04286de5164/0c968/07_ca_25.png 450w,./static/daf885880e94d868c8c4e04286de5164/1e111/07_ca_25.png 900w,./static/daf885880e94d868c8c4e04286de5164/934ee/07_ca_25.png 1800w" alt="Малюнок 7.24: Правило 30"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.24: Правило 30</figcaption>
</figure>
<h3 id="class-4-complexity"><a class="heading-link" href="#class-4-complexity"><strong>Клас 4: Складний</strong></a></h3>
<p>КА-ти класу 4 можна розглядати як суміш між класом 2 і класом 3. Ви можете знайти повторювані, коливальні візерунки всередині КА, але де і коли ці патерни з’являються непередбачувано та, здається, випадково. Якщо КА класу 3 вас захопив, то клас 4 з правилом 110 має справді вразити (малюнок 7.25)!</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2000px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;500&#x27; width=&#x27;2000&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/cbf61723264edc4d5feff2c1ad178132/f4762/07_ca_26.webp 500w,./static/cbf61723264edc4d5feff2c1ad178132/156a8/07_ca_26.webp 1000w,./static/cbf61723264edc4d5feff2c1ad178132/874b2/07_ca_26.webp 2000w" sizes="(min-width: 2000px) 2000px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2000px) 2000px, 100vw" decoding="async" loading="lazy" data-src="./static/cbf61723264edc4d5feff2c1ad178132/0ce00/07_ca_26.png" data-srcset="./static/cbf61723264edc4d5feff2c1ad178132/8daec/07_ca_26.png 500w,./static/cbf61723264edc4d5feff2c1ad178132/5e025/07_ca_26.png 1000w,./static/cbf61723264edc4d5feff2c1ad178132/0ce00/07_ca_26.png 2000w" alt="Малюнок 7.25: Правило 110"/></picture><noscript><picture><source type="image/webp" srcSet="./static/cbf61723264edc4d5feff2c1ad178132/f4762/07_ca_26.webp 500w,./static/cbf61723264edc4d5feff2c1ad178132/156a8/07_ca_26.webp 1000w,./static/cbf61723264edc4d5feff2c1ad178132/874b2/07_ca_26.webp 2000w" sizes="(min-width: 2000px) 2000px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2000px) 2000px, 100vw" decoding="async" loading="lazy" src="./static/cbf61723264edc4d5feff2c1ad178132/0ce00/07_ca_26.png" srcSet="./static/cbf61723264edc4d5feff2c1ad178132/8daec/07_ca_26.png 500w,./static/cbf61723264edc4d5feff2c1ad178132/5e025/07_ca_26.png 1000w,./static/cbf61723264edc4d5feff2c1ad178132/0ce00/07_ca_26.png 2000w" alt="Малюнок 7.25: Правило 110"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.25: Правило 110</figcaption>
</figure>
<p>У <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a> я розглянув концепцію складної системи й використав флокінг, щоб продемонструвати, як прості правила можуть призвести до непередбачуваної поведінки. Клас 4 КА-тів чудово демонструє характеристики складних систем і є ключем до моделювання таких явищ, як лісові пожежі, схеми руху та поширення хвороб. Дослідження та застосування КА-тів постійно підкреслюють важливість класу 4 як мосту між КА та природою.</p>
<h2 id="the-game-of-life"><a class="heading-link" href="#the-game-of-life">Гра Життя</a></h2>
<p>Наступним кроком є перехід від 1D КА до 2D: Гра Життя. Це створює додаткову складність, адже кожна клітина матиме більшу околицю, але зі складністю приходить ширший діапазон можливих застосувань. Зрештою, більшість того, що відбувається в комп’ютерній графіці, живе у двох вимірах, і цей розділ демонструє, як застосувати КА-мислення до 2D полотна p5.js.</p>
<p>У 1970 році Мартін Гарднер написав статтю в журналі <em>Scientific American</em> у якій описав нову Гру Життя математика Джона Конвея, описуючи її як <em>розважальну математику</em>: “Щоб грати в життя, вам потрібно мати досить велику шахову дошку та великий запас пласких фішок двох кольорів. Можна використовувати олівець і міліметровий папір, але набагато простіше, особливо для початківців, використовувати фішки та дошку”.</p>
<p>Гра Життя стала чимось на кшталт обчислювального кліше, оскільки безліч проєктів відображають гру на світлодіодах, екранах, проєкційних поверхнях тощо. Але практика побудови системи за допомогою коду все ще є цінною з кількох причин.</p>
<p>По-перше, Гра Життя надає гарну можливість попрактикуватися в роботі з 2D-масивами, вкладеними циклами тощо. Однак, можливо, більш важливим є те, що основні принципи цього КА безпосередньо пов’язані з основною метою цієї книги: моделювання природного світу за допомогою коду. Алгоритм Гри Життя і технічна реалізація дадуть вам натхнення та основу для створення симуляцій, які демонструють характеристики та поведінку біологічних систем відтворення.</p>
<p>На відміну від фон Неймана, який створив надзвичайно складну систему станів і правил, Конвей хотів досягти схожого реалістичного результату за допомогою найпростішого набору правил. Гарднер окреслив цілі Конвея наступним чином:</p>
<ol>
  <li>Не повинно існувати початкового шаблону для якого є простий доказ того, що популяція може зростати без обмежень.</li>
  <li>Повинні існувати початкові шаблони, які очевидно, ростуть без обмежень.</li>
  <li>Повинні існувати прості початкові шаблони, які зростають і змінюються протягом значного періоду часу, перш ніж прийти до кінця трьома можливими способами: повністю зникнути (через перенаселеність або значну розрідженість), установитися у стабільну конфігурацію, яка після цього залишається незмінною, або війти у фазу коливань, у якій вони повторюють нескінченний цикл з двох або більше періодів.</li>
</ol>
<p>Це може здатися загадковим, але по суті це опис КА класу 4 від Вольфрама. КА має бути шаблонним, але непередбачуваним з плином часу, зрештою установлюючись у рівномірний або коливальний стан. Іншими словами, хоча Конвей не використовував цю термінологію, Гра Життя повинна мати всі властивості <em>склад ної системи</em>.</p>
<h3 id="the-rules-of-the-game"><a class="heading-link" href="#the-rules-of-the-game">Правила Гри</a></h3>
<p>Подивімось, як працює Гра Життя. Це не займе багато часу чи місця, оскільки я можу будувати все, починаючи з елементарного КА Вольфрама. По-перше, замість лінії клітин я тепер матиму 2D матрицю клітин. Як і у випадку з елементарним КА, можливими станами є 0 або 1. Однак у цьому випадку, оскільки в системі йдеться про життя, 0 означатиме “мертвий”, а 1 означатиме “живий”.</p>
<p>Оскільки Гра Життя є двомірною, околиці кожної клітини тепер розширено. Околиці тепер складаються з дев’яти клітинок замість трьох, як показано на малюнку 7.26.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1206&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/5222d56f2dfa01250edb695a0bed6697/6966f/07_ca_27.webp 576w,./static/5222d56f2dfa01250edb695a0bed6697/414d4/07_ca_27.webp 1152w,./static/5222d56f2dfa01250edb695a0bed6697/60a57/07_ca_27.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/5222d56f2dfa01250edb695a0bed6697/27336/07_ca_27.png" data-srcset="./static/5222d56f2dfa01250edb695a0bed6697/b8a7d/07_ca_27.png 576w,./static/5222d56f2dfa01250edb695a0bed6697/98d0a/07_ca_27.png 1152w,./static/5222d56f2dfa01250edb695a0bed6697/27336/07_ca_27.png 2304w" alt="Малюнок 7.26: двомірний КА, що показує околицю з дев’яти клітин"/></picture><noscript><picture><source type="image/webp" srcSet="./static/5222d56f2dfa01250edb695a0bed6697/6966f/07_ca_27.webp 576w,./static/5222d56f2dfa01250edb695a0bed6697/414d4/07_ca_27.webp 1152w,./static/5222d56f2dfa01250edb695a0bed6697/60a57/07_ca_27.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/5222d56f2dfa01250edb695a0bed6697/27336/07_ca_27.png" srcSet="./static/5222d56f2dfa01250edb695a0bed6697/b8a7d/07_ca_27.png 576w,./static/5222d56f2dfa01250edb695a0bed6697/98d0a/07_ca_27.png 1152w,./static/5222d56f2dfa01250edb695a0bed6697/27336/07_ca_27.png 2304w" alt="Малюнок 7.26: двомірний КА, що показує околицю з дев’яти клітин"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.26: двомірний КА, що показує околицю з дев’яти клітин</figcaption>
</figure>
<p>З трьома клітинами 3-бітове число мало вісім можливих конфігурацій. З дев’ятьма клітинами є 9 бітів, або 512 можливих комбінацій. У більшості випадків визначення результату для кожної окремої можливості було б непрактичним. Гра Життя вирішує цю проблему, визначаючи набір правил відповідно до загальних характеристик околиці: околиця може бути перенаселена життям або переважена смертю чи не так? Ось правила життя:</p>
<ol>
  <li><strong>Смерть:</strong> якщо клітина жива (стан = 1) вона гине (стан стане 0) за наступних обставин:
    <ul>
      <li><strong>Перенаселення:</strong> якщо клітина має чотири або більше живих сусідів.</li>
      <li><strong>Самотність:</strong> якщо клітина має одного або менше живих сусідів.</li>
    </ul>
  </li>
  <li><strong>Народження:</strong> якщо клітина мертва (стан = 0) вона оживає (стан стане 1), коли в неї буде рівно три живі сусіди (ні більше, ні менше).</li>
  <li><strong>Застій:</strong> у всіх інших випадках стан клітини не змінюється. Можливі два сценарії:
    <ul>
      <li><strong>Залишитися живою:</strong> якщо клітина жива і має рівно двох або трьох живих сусідів вона залишається живою.</li>
      <li><strong>Залишитися мертвою:</strong> якщо клітина мертва і має околицю відмінну від трьох живих сусідів вона залишається мертвою.</li>
    </ul>
  </li>
</ol>
<p>На малюнку 7.27 показано кілька прикладів цих правил. Зосередьтеся на тому, що відбувається з центральною клітиною.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;730&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/99dd5b32b72ce094d5a77f749c2ab9f0/a6b47/07_ca_28.webp 576w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/86bb2/07_ca_28.webp 1152w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/3ca65/07_ca_28.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/99dd5b32b72ce094d5a77f749c2ab9f0/bd3e4/07_ca_28.png" data-srcset="./static/99dd5b32b72ce094d5a77f749c2ab9f0/07e31/07_ca_28.png 576w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/fd370/07_ca_28.png 1152w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/bd3e4/07_ca_28.png 2304w" alt="Малюнок 7.27: Приклади сценаріїв смерті та народження у Грі Життя"/></picture><noscript><picture><source type="image/webp" srcSet="./static/99dd5b32b72ce094d5a77f749c2ab9f0/a6b47/07_ca_28.webp 576w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/86bb2/07_ca_28.webp 1152w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/3ca65/07_ca_28.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/99dd5b32b72ce094d5a77f749c2ab9f0/bd3e4/07_ca_28.png" srcSet="./static/99dd5b32b72ce094d5a77f749c2ab9f0/07e31/07_ca_28.png 576w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/fd370/07_ca_28.png 1152w,./static/99dd5b32b72ce094d5a77f749c2ab9f0/bd3e4/07_ca_28.png 2304w" alt="Малюнок 7.27: Приклади сценаріїв смерті та народження у Грі Життя"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.27: Приклади сценаріїв смерті та народження у Грі Життя</figcaption>
</figure>
<p>За допомогою елементарного КА я візуалізував багато поколінь одночасно, складених у вигляді рядків у 2D сітці. Однак у Грі Життя КА є двовимірним. Я міг би спробувати створити складну тривимірну візуалізацію результатів і скласти всі покоління в структуру куба (і наспр авді ви можете спробувати це як вправу), але більш типовий спосіб візуалізації Гри Життя полягає у розгляді кожного покоління як окремого кадру анімації. Таким чином, замість того, щоб переглядати всі покоління одночасно, ви будете бачити їх по одному, і результат нагадуватиме бактерії, що швидко розвиваються у чашці Петрі.</p>
<p>Одним із захопливих аспектів Гри Життя є те, що деякі відомі початкові шаблони дають результати, що інтригують. Наприклад, шаблони показані на малюнку 7.28 залишаються статичними й ніколи не змінюються.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1575&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4f9158d65163cbbb8fa41030a2000079/79f65/07_ca_29.webp 576w,./static/4f9158d65163cbbb8fa41030a2000079/090a6/07_ca_29.webp 1152w,./static/4f9158d65163cbbb8fa41030a2000079/e80fe/07_ca_29.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/4f9158d65163cbbb8fa41030a2000079/343cf/07_ca_29.png" data-srcset="./static/4f9158d65163cbbb8fa41030a2000079/0dc04/07_ca_29.png 576w,./static/4f9158d65163cbbb8fa41030a2000079/1d12a/07_ca_29.png 1152w,./static/4f9158d65163cbbb8fa41030a2000079/343cf/07_ca_29.png 2304w" alt="Малюнок 7.28: Початкові конфігурації клітин, які залишаються стабільними"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4f9158d65163cbbb8fa41030a2000079/79f65/07_ca_29.webp 576w,./static/4f9158d65163cbbb8fa41030a2000079/090a6/07_ca_29.webp 1152w,./static/4f9158d65163cbbb8fa41030a2000079/e80fe/07_ca_29.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/4f9158d65163cbbb8fa41030a2000079/343cf/07_ca_29.png" srcSet="./static/4f9158d65163cbbb8fa41030a2000079/0dc04/07_ca_29.png 576w,./static/4f9158d65163cbbb8fa41030a2000079/1d12a/07_ca_29.png 1152w,./static/4f9158d65163cbbb8fa41030a2000079/343cf/07_ca_29.png 2304w" alt="Малюнок 7.28: Початкові конфігурації клітин, які залишаються стабільними"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.28: Початкові конфігурації клітин, які залишаються стабільними</figcaption>
</figure>
<p>Шаблони на малюнку 7.29 перемикаються вперед і назад між двома станами.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;750&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/04f7903e1010ffd716e12c5c86785894/c5a0d/07_ca_30.webp 576w,./static/04f7903e1010ffd716e12c5c86785894/280a6/07_ca_30.webp 1152w,./static/04f7903e1010ffd716e12c5c86785894/d4cd6/07_ca_30.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/04f7903e1010ffd716e12c5c86785894/4b1f9/07_ca_30.png" data-srcset="./static/04f7903e1010ffd716e12c5c86785894/a9dfa/07_ca_30.png 576w,./static/04f7903e1010ffd716e12c5c86785894/bc99f/07_ca_30.png 1152w,./static/04f7903e1010ffd716e12c5c86785894/4b1f9/07_ca_30.png 2304w" alt="Малюнок 7.29: Початкові конфігурації клітин, які перемикаються між двома станами"/></picture><noscript><picture><source type="image/webp" srcSet="./static/04f7903e1010ffd716e12c5c86785894/c5a0d/07_ca_30.webp 576w,./static/04f7903e1010ffd716e12c5c86785894/280a6/07_ca_30.webp 1152w,./static/04f7903e1010ffd716e12c5c86785894/d4cd6/07_ca_30.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/04f7903e1010ffd716e12c5c86785894/4b1f9/07_ca_30.png" srcSet="./static/04f7903e1010ffd716e12c5c86785894/a9dfa/07_ca_30.png 576w,./static/04f7903e1010ffd716e12c5c86785894/bc99f/07_ca_30.png 1152w,./static/04f7903e1010ffd716e12c5c86785894/4b1f9/07_ca_30.png 2304w" alt="Малюнок 7.29: Початкові конфігурації клітин, які перемикаються між двома станами"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.29: Початкові конфігурації клітин, які перемикаються між двома станами</figcaption>
</figure>
<p>Шаблони на малюнку 7.30 будуть виглядати так, наче вони рухаються по сітці від покоління до покоління. Самі клітини насправді не рухатимуться, але ви будете бачити ілюзію руху в результаті ввімкнення і вимкнення сусідніх клітин.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;763&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/bbac4c485b936395226f8b6addd24e19/2f1be/07_ca_31.webp 576w,./static/bbac4c485b936395226f8b6addd24e19/da86c/07_ca_31.webp 1152w,./static/bbac4c485b936395226f8b6addd24e19/46ba6/07_ca_31.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/bbac4c485b936395226f8b6addd24e19/1c97f/07_ca_31.png" data-srcset="./static/bbac4c485b936395226f8b6addd24e19/aa287/07_ca_31.png 576w,./static/bbac4c485b936395226f8b6addd24e19/b7ad7/07_ca_31.png 1152w,./static/bbac4c485b936395226f8b6addd24e19/1c97f/07_ca_31.png 2304w" alt="Малюнок 7.30: Початкова конфігурація клітин, які наче рухаються від покоління до покоління"/></picture><noscript><picture><source type="image/webp" srcSet="./static/bbac4c485b936395226f8b6addd24e19/2f1be/07_ca_31.webp 576w,./static/bbac4c485b936395226f8b6addd24e19/da86c/07_ca_31.webp 1152w,./static/bbac4c485b936395226f8b6addd24e19/46ba6/07_ca_31.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/bbac4c485b936395226f8b6addd24e19/1c97f/07_ca_31.png" srcSet="./static/bbac4c485b936395226f8b6addd24e19/aa287/07_ca_31.png 576w,./static/bbac4c485b936395226f8b6addd24e19/b7ad7/07_ca_31.png 1152w,./static/bbac4c485b936395226f8b6addd24e19/1c97f/07_ca_31.png 2304w" alt="Малюнок 7.30: Початкова конфігурація клітин, які наче рухаються від покоління до покоління"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.30: Початкова конфігурація клітин, які наче рухаються від покоління до покоління</figcaption>
</figure>
<p>Якщо вас цікавлять ці шаблони, кілька хороших готових онлайн-демонстрацій Гри Життя дозволять вам налаштувати початковий стан КА та спостерігати за його роботою на різних швидкостях. Ось два приклади:</p>
<ul>
  <li><a href="https://www.playfulinvention.com/emergence/" target="_blank" rel="noopener">Дослідження емерджентності Мітчела Резніка і Браяна Сільвермана, Lifelong Kindergarten Group, медіалабораторія MIT)</a></li>
  <li><a href="https://sklise.github.io/conways-game-of-life/" target="_blank" rel="noopener">Гра Життя Конвея в p5.js Стівена Кліза</a></li>
</ul>
<p>Для прикладу, який я побудую у наступному розділі, я зосереджуся на випадковій ініціалізації станів для кожної клітини.</p>
<h3 id="the-implementation"><a class="heading-link" href="#the-implementation">Імплементація</a></h3>
<p>У мене вже є багато з того, що мені потрібно для реалізації Гри Життя у p5.js: здебільшого мені просто потрібно розширити код із програми КА Вольфрама до двох вимірів. Раніше я використовував 1D масив для зберігання списку станів клітин. Тепер я використаю 2D-масив:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> w = <span class="hljs-number">8</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> columns = width / w;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> rows = height / w;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(columns);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; columns; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  board[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(rows);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я почну з ініціалізації кожної клітини дошки випадковим станом, 0 або 1:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; columns; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; rows; j++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    board[i][j] = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>));
</code></pre><div class="comment"><p>Ініціалізація кожної клітини значенням 0 або 1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Як і раніше, мені потрібен додатковий 2D-масив для отримання станів наступного покоління, щоб я не перезаписував 2D-масив поточного покоління під час його обробки. Однак замість того, щоб писати всі кроки для створення 2D-масиву у функціях <code>setup()</code> і <code>draw()</code>, варто написати функцію, яка повертатиме 2D-масив на основі кількості стовпців і рядків. Я також ініціалізую кожен елемент  масиву значенням <code>0</code>, щоб він не заповнювався як <code>undefined</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create2DArray</span>(<span class="hljs-params">columns, rows</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(columns);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; columns; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(rows);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; rows; j++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      arr[i][j] = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">return</span> arr;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер я можу просто викликати цю функцію, коли потрібен новий 2D-масив:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> next = <span class="hljs-title function_">create2DArray</span>(columns, rows);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; columns; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; rows; j++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    next[x][y] = _______________?;
</code></pre><div class="comment"><p>Обчислення стану для кожної клітини.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Далі мені потрібно розібратися, як обчислити новий стан кожної клітини. Для цього мені потрібно визначити, як зчитувати значення сусідніх клітин. У випадку одномірного КА це було просто: якщо індекс клітини був <code>i</code>, то її сусідами були <code>i-1</code> та <code>i+1</code>. Але тепер кожна клітина має не єдиний індекс, а індекси стовпця і рядка: <code>i,j</code>. Як показано на малюнку 7.31, сусідами є <code>i-1,j-1</code> , <code>i,j-1</code>, <code>i+1,j-1</code>, <code>i-1,j</code>, <code>i+1,j</code>, <code>i-1,j+1</code>, <code>i,j+1</code> та <code>i+1,j+1</code>.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1211&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/e64d442d2fff57c22d6a2f81c693c21d/04908/07_ca_32.webp 576w,./static/e64d442d2fff57c22d6a2f81c693c21d/5592f/07_ca_32.webp 1152w,./static/e64d442d2fff57c22d6a2f81c693c21d/7f6f7/07_ca_32.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/e64d442d2fff57c22d6a2f81c693c21d/4a25c/07_ca_32.png" data-srcset="./static/e64d442d2fff57c22d6a2f81c693c21d/24ac1/07_ca_32.png 576w,./static/e64d442d2fff57c22d6a2f81c693c21d/80879/07_ca_32.png 1152w,./static/e64d442d2fff57c22d6a2f81c693c21d/4a25c/07_ca_32.png 2304w" alt="Малюнок 7.31: Значення індексів для сусідніх клітин"/></picture><noscript><picture><source type="image/webp" srcSet="./static/e64d442d2fff57c22d6a2f81c693c21d/04908/07_ca_32.webp 576w,./static/e64d442d2fff57c22d6a2f81c693c21d/5592f/07_ca_32.webp 1152w,./static/e64d442d2fff57c22d6a2f81c693c21d/7f6f7/07_ca_32.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/e64d442d2fff57c22d6a2f81c693c21d/4a25c/07_ca_32.png" srcSet="./static/e64d442d2fff57c22d6a2f81c693c21d/24ac1/07_ca_32.png 576w,./static/e64d442d2fff57c22d6a2f81c693c21d/80879/07_ca_32.png 1152w,./static/e64d442d2fff57c22d6a2f81c693c21d/4a25c/07_ca_32.png 2304w" alt="Малюнок 7.31: Значення індексів для сусідніх клітин"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 7.31: Значення індексів для сусідніх клітин</figcaption>
</figure>
<p>Правила Гри Життя можна задіяти, якщо знати скільки клітина має живих сусідів. Якщо я створю змінну <code>neighborSum</code> і збільшуватиму її для кожного сусіда зі станом 1, то матиму загальну кількість живих сусідів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> neighborSum = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">if</span> (board[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) neighborSum++;
<span class="hljs-keyword">if</span> (board[i    ][j - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) neighborSum++;
<span class="hljs-keyword">if</span> (board[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) neighborSum++;
</code></pre><div class="comment"><p>Верхній ряд сусідів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">if</span> (board[i - <span class="hljs-number">1</span>][j    ] === <span class="hljs-number">1</span>) neighborSum++;
<span class="hljs-keyword">if</span> (board[i + <span class="hljs-number">1</span>][j    ] === <span class="hljs-number">1</span>) neighborSum++;
</code></pre><div class="comment"><p>Середній ряд сусідів (зауважте, що j залишається без змін).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">if</span> (board[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) neighborSum++;
<span class="hljs-keyword">if</span> (board[i    ][j + <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) neighborSum++;
<span class="hljs-keyword">if</span> (board[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) neighborSum++;
</code></pre><div class="comment"><p>Нижній ряд сусідів.</p></div></div></div>
<p>Як і з КА Вольфрама, я пишу купу операторів <code>if</code>. Це ще одна ситуація, коли з метою навчання корисно та зрозуміло написати код таким чином, чітко зазначаючи кожен крок (кожного разу, коли сусід має стан 1, лічильник збільшується). Проте, трохи безглуздо говорити “Якщо стан клітини дорівнює 1, додайте 1 до лічильника”, тоді як замість цього я міг би просто сказати “Додайте стан клітини до лічильника”. Зрештою, якщо стан може бути тільки 0 або 1, сума всіх станів сусідів дасть загальну кількість живих клітин. Оскільки сусіди розташовані у мінісітці 3 на 3, я можу додати ще один вкладений цикл для більш ефективного обчислення суми:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> neighborSum = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = -<span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">1</span>; k++) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = -<span class="hljs-number">1</span>; l &lt;= <span class="hljs-number">1</span>; l++) {
</code></pre><div class="comment"><p>Використання змінних k та l як лічильники, оскільки i та j уже використовуються!</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    neighborSum += board[i + k][j + l];
</code></pre><div class="comment"><p>Складання усіх сусідніх станів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Звісно, я зробив суттєву помилку. У Грі Життя поточна клітина не вважається сусідньою. Я міг би включити умову, щоб пропустити додавання стану, коли <code>k</code> та <code>l</code> дорівнюють <code>0</code>, але іншим варіантом є віднімання стану центральної клітини після завершення циклу:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">neighborSum -= board[i][j];
</code></pre><div class="comment"><p>Після циклу віднімаємо стан поточної клітини!</p></div></div></div>
<p>Нарешті, коли мені відома загальна кількість живих сусідів я можу вирішити, яким має бути новий стан клітини згідно з правилами народження, смерті чи застою:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="code-wide pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-number">1</span> &amp;&amp; neighborSum &lt; <span class="hljs-number">2</span>) {
  next[i][j] = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Якщо клітина жива і має менше двох живих сусідів вона гине від самотності.</p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[x][y] === <span class="hljs-number">1</span> &amp;&amp; neighborSum &gt; <span class="hljs-number">3</span>) {
  next[i][j] = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Якщо клітина жива і має більш трьох живих сусідів вона гине від перенаселення.</p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[x][y] === <span class="hljs-number">0</span> &amp;&amp; neighborSum === <span class="hljs-number">3</span>) {
  next[i][j] = <span class="hljs-number">1</span>;
</code></pre><div class="comment"><p>Якщо клітина мертва і має рівно трьох живих сусідів вона народжується!</p></div></div><div class="code-wide pair split"><pre><code class="hljs code language-javascript">} <span class="hljs-keyword">else</span> {
  next[i][j] = board[i][j];
}
</code></pre><div class="comment"><p>У всіх інших випадках стан клітини залишається незмінним.</p></div></div></div>
<p>Зібравши все разом маємо:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> next = <span class="hljs-title function_">create2DArray</span>(columns, rows);
</code></pre><div class="comment"><p>Створення сітки.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; columns - <span class="hljs-number">1</span>; i++) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; rows - <span class="hljs-number">1</span>; j++) {
</code></pre><div class="comment"><p>Прохід по всій сітці, але без крайніх клітин.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> neighborSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = -<span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">1</span>; k++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = -<span class="hljs-number">1</span>; l &lt;= <span class="hljs-number">1</span>; l++) {
        neighborSum += board[i + k][j + l];
      }
    }
</code></pre><div class="comment"><p>Додавання усіх сусідніх станів,
щоб порахувати кількість живих сусідів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    neighborSum -= board[i][j];
</code></pre><div class="comment"><p>Корекція за рахунок віднімання стану центральної клітини.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-number">1</span> &amp;&amp; neighborSum &lt; <span class="hljs-number">2</span>) next[i][j] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-number">1</span> &amp;&amp; neighborSum &gt; <span class="hljs-number">3</span>) next[i][j] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-number">0</span> &amp;&amp; neighborSum === <span class="hljs-number">3</span>) next[i][j] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> next[i][j] = board[i][j];
</code></pre><div class="comment"><p>Застосування правил життя!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">board = next;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер мені просто потрібно намалювати сітку. Я намалюю квадрат для кожної клітини: білий — для живої, чорний — для неживої.</p>
<div data-type="example">
  <h3 id="example-72-game-of-life"><a class="heading-link" href="#example-72-game-of-life">Приклад 7.2: Гра Життя</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/07_ca/7_2_game_of_life"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/vzLjFYwJc" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; columns; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; rows; j++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span> - board[i][j] * <span class="hljs-number">255</span>);
</code></pre><div class="comment"><p>Коли стан клітин и дорівнює 0, розраховуємо значення 255, інакше буде 0.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">square</span>(i * w, j * w, w);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>У цьому прикладі я представляю ще один спосіб малювання квадратів на основі стану клітини. Пам’ятайте, що помноження стану клітини на 255 дає білий колір заливки для <em>ввімкненої</em> й чорний колір для <em>вимкненої</em> клітини. Щоб інвертувати ці значення, я віднімаю від числа 255 значення клітини помножене на 255: виходить чорний колір для <em>ввімкненої</em> й білий для <em>вимкненої</em> клітин.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-75"><a class="heading-link" href="#exercise-75">Вправа 7.5</a></h3>
  <p>Створіть симуляцію Гри Життя, яка дозволить вам вручну налаштувати сітку, жорстко закодувавши початкові стани клітин або намалювавши їх безпосередньо на полотні. Використовуйте симуляцію, щоб дослідити деякі з відомих шаблонів Гри Життя.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-76"><a class="heading-link" href="#exercise-76">Вправа 7.6</a></h3>
  <p>Реалізуйте для дошки Гри Життя властивість переходу між її межами, щоб клітини по краях додатково вважали своїми сусідами й клітини з протилежних боків сітки.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-77"><a class="heading-link" href="#exercise-77">Вправа 7.7</a></h3>
  <p>Код у прикладі 7.2 є зручним, але не особливо ефективним для пам’яті. Він створює новий 2D-масив для кожного кадру анімації! Для програми p5.js це мало має значення, але якщо ви реалізовуєте Гру Життя на мікроконтролері чи мобільному пристрої, то варто бути обережнішими. Одне з рішень полягає в тому, щоб мати лише два масиви та постійно міняти їх місцями, записуючи наступний набір станів у той із них, який не є поточним масивом. Реалізуйте це конкретне рішення.</p>
</div>
<h2 id="object-oriented-cells"><a class="heading-link" href="#object-oriented-cells">Об’єктно-орієнтовані клітини</a></h2>
<p>Впродовж цієї книги я створював приклади систем <em>об’єктів</em>, які мають властивості та рухаються по полотну. Хоча в цьому розділі я говорив про клітину як про об’єкт, я не використовував об’єктно-орієнтовані принципи у коді. Це спрацювало, тому що клітина надзвичайно простий об’єкт і його єдиною властивістю є його єдиний стан: 0 або 1. Однак я міг би далі розвивати системи КА багатьма способами, окрім простих моделей, які тут обговорюються, і часто це може включати відстеження кількох властивостей для кожної клітини. Наприклад, що, якщо клітині потрібно запам’ятати свою історію станів? Або що, якщо ви хочете застосувати рух і фізику до КА, щоб клітини рухалися по полотну, динамічно змінюючи своїх сусідів від кадру до кадру?</p>
<p>Щоб реалізувати будь-яку з цих ідей (і багато іншого), було б корисно розглянути кожну клітину у вигляді об’єкта, а не як окремий 0 чи 1 у масиві. Наприклад, у симуляції Гри Життя я більше не хочу ініціалізувати кожну клітину таким чином:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">     board[i][j] = <span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>));    
</code></pre><div class="comment"><p></p></div></div></div>
<p>Натомість я хочу щось на зразок цього:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">     board[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(<span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>)));
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тут <code>Cell</code> — це новий клас, який я напишу. Які властивості потрібні для об’єкта <code>Cell</code>? У прикладі Гри Життя я міг би створити клітину в якій зберігається її позиція та розмір разом із її станом:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">state, x, y, w</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = state;
</code></pre><div class="comment"><p>Певний стан клітини.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = w;
</code></pre><div class="comment"><p>Розташування і розмір.</p></div></div></div>
</div>
<p>У версії без ООП я використовував окремі 2D-масиви для відстеження станів для поточного та наступного покоління. Однак, зробивш и клітину об’єктом, кожна клітина могла б відстежувати обидва стани, маючи для цього окрему змінну:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">previous</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
  }
</code></pre><div class="comment"><p>Який був попередній стан?</p></div></div></div>
</div>
<p>Несподівано з цими додатковими властивостями візуалізація клітини може включати більше інформації про стан. Наприклад, що, якщо кожну клітину фарбувати залежно від того, чи змінився її стан від одного кадру до іншого?</p>
<div data-type="example">
  <h3 id="example-73-object-oriented-game-of-life"><a class="heading-link" href="#example-73-object-oriented-game-of-life">Приклад 7.3: Об’єктно-орієнтована Гра Життя</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/07_ca/7_3_game_of_life_oop"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/13KF3ysx8" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">previous</span> === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-number">1</span>) {
      <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>);
</code></pre><div class="comment"><p>Якщо клітина народжується, розфарбуємо її у синій колір!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-number">1</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">previous</span> === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-number">0</span>) {
      <span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre><div class="comment"><p>Якщо клітина гине, пофарбуємо її у червоний колір!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">square</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Більше нічого у коді не потрібно змінювати (принаймні для моїх поточних цілей). Сусідів можна рахувати так само, різниця в тому, що їх стани беруться у властивості <code>previous</code>, а новий стан оновлюється у властивості <code>state</code>. Цю логіку можна інкапсулювати у методі <code>calculateState()</code>, який міг би приймати аргумент дошки <code>board</code>. Я залишу це для вас як вправу.
</p><p>Нижче наведено логіку Гри Життя, адаптовану для клітинних об’єктів, але без окремого методу <code>calculateState()</code>:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; x &lt; columns - <span class="hljs-number">1</span>; x++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = <span class="hljs-number">1</span>; y &lt; rows - <span class="hljs-number">1</span>; y++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> neighborSum = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = -<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1</span>; j++) {
</code></pre><div class="comment"><p></p></div></div><div class="bold pair split"><pre><code class="hljs code language-javascript">          neighborSum += board[x + i][y + j].<span class="hljs-property">previous</span>;
</code></pre><div class="comment"><p>Використання попереднього стану для підрахунку сусідів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      neighborSum -= board[x][y].<span class="hljs-property">previous</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">if</span> (board[x][y].<span class="hljs-property">state</span> === <span class="hljs-number">1</span> &amp;&amp; neighborSum &lt; <span class="hljs-number">2</span>) {
        board[x][y].<span class="hljs-property">state</span> = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[x][y].<span class="hljs-property">state</span> === <span class="hljs-number">1</span> &amp;&amp; neighborSum &gt; <span class="hljs-number">3</span>) {
        board[x][y].<span class="hljs-property">state</span> = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[x][y].<span class="hljs-property">state</span> === <span class="hljs-number">0</span> &amp;&amp; neighborSum === <span class="hljs-number">3</span>) {
        board[x][y].<span class="hljs-property">state</span> = <span class="hljs-number">1</span>;
      }
</code></pre><div class="comment"><p>Встановлення нового стану клітини на основі кількості сусідів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Перетворюючи клітини на об’єкти, з’являються численні можливості для покращення властивостей і поведінки клітин. Наприклад, що, якби кожна клітина мала властивість <code>lifespan</code>, яка збільшується з кожним циклом і впливає на її колір або форму з часом? Або уявіть, якби клітина мала властивість для рельєфу місцевості <code>terrain</code>, яка могла б бути землею <code>land</code>, водою <code>water</code>, горою <code>mountain</code> або лісом <code>forest</code>. Як двомірний КА можна інтегрувати у стратегічну гру на плитці чи іншому контексті?</p>
<h2 id="variations-on-traditional-ca"><a class="heading-link" href="#variations-on-traditional-ca">Варіації традиційного КА</a></h2>
<p>Тепер, коли я розглянув основні поняття, алгоритми й стратегії програмування, що лежать в основі найвідоміших одномірних та двомірних КА-тів, настав час подумати про те, як ви можете взяти цю основу коду та будувати на ній, розробляючи креативні програми КА у власних роботах. У цьому розділі я розповім про деякі ідеї щодо розширення можливостей КА. Приклади відповідей до цих вправ можна знайти на вебсайті книги.</p>
<h3 id="nonrectangular-grids"><a class="heading-link" href="#nonrectangular-grids">Варіант з непрямокутною сіткою</a></h3>
<p>Немає особливих причин обмежувати себе розміщенням клітин у прямокутній сітці. Що станеться, якщо ви розробите КА з іншим типом форми?</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-78"><a class="heading-link" href="#exercise-78">Вправа 7.8</a></h3>
  <p>Створіть КА за допомогою сітки з шестикутників (як показано тут), кожен із шістьма сусідами.</p>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/07_ca/exercise_7_9_hexagon_ca"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/_PMAwxPtZp" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
  <p>Підказка: щоб знайти шість вершин гексагона, ви можете використовувати перетворення полярних координат у декартові!</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">drawHexagon</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">push</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">translate</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">beginShape</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> angle = <span class="hljs-number">0</span>; angle &lt; <span class="hljs-variable constant_">TWO_PI</span>; angle += <span class="hljs-variable constant_">PI</span> / <span class="hljs-number">3</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> xoff = <span class="hljs-title function_">cos</span>(angle) * r;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> yoff = <span class="hljs-title function_">sin</span>(angle) * r;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">vertex</span>(xoff, yoff);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">endShape</span>(<span class="hljs-variable constant_">CLOSE</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<h3 id="probabilistic"><a class="heading-link" href="#probabilistic">Варіант з імовірностями</a></h3>
<p>Правила КА не обов’язково мають визначати точний результат.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-79"><a class="heading-link" href="#exercise-79">Вправа 7.9</a></h3>
  <p>Перепишіть правила Гри Життя наступним чином:</p>
  <ul>
    <li>Перенаселення: якщо клітина має чотири або більше живих сусідів, вона має 80-відсотковий шанс загинути.</li>
    <li>Самотність: якщо у клітини є один чи менше живих сусідів, вона має 60-відсотковий шанс загинути.</li>
  </ul>
  <p>Або складіть власні ймовірнісні правила!</p>
</div>
<h3 id="continuous"><a class="heading-link" href="#continuous">Варіант з безперервністю</a></h3>
<p>У цьому розділі ми зосередилися на прикладах із кінцевою кількістю дискретних станів клітини — 0 або 1. Що, якби стан клітини міг бути будь-яким числом із рухомою крапкою від 0 до 1?</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-710"><a class="heading-link" href="#exercise-710">Вправа 7.10</a></h3>
  <p>Адаптуйте елементарний КА Вольфрама, щоб він мав стан числа з рухомою крапкою. Ви можете визначити такі правила як “Якщо стан більше за 0.5” або “...менше ніж 0.2”.</p>
</div>
<h3 id="image-processing"><a class="heading-link" href="#image-processing">Варіант з обробкою зображення</a></h3>
<p>Я коротко торкався цього раніше, але багато алгоритмів обробки зображень працюють за правилами, подібними до КА. Наприклад, щоб розмити зображення, потрібно створити новий колір пікселя із середнім значенням кольорів сусідніх пікселів. Симуляції дисперсії чорнила на папері або брижі води на зображенні також можна досягти за допомогою правил КА.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-711"><a class="heading-link" href="#exercise-711">Вправа 7.11</a></h3>
  <p>Створіть КА, у якому кожен піксель — це клітина, а колір пікселя — її стан.</p>
</div>
<div class="avoid-break">
  <h3 id="historical"><a class="heading-link" href="#historical">Варіант з історією станів</a></h3>
  <p>У прикладі об’єктно-орієнтованої Гри Життя я використовував дві змінні, щоб відстежувати поточний і попередній стани клітини. Що, якщо ви будете використовувати масив для відстеження історії стану клітини протягом більш тривалого періоду? Це стосується ідеї <em>складної адаптивної системи</em>, яка має здатність змінювати свої правила з часом, вивчаючи свою історію. (Більше про цю концепцію буде у <a href="/genetic-algorithms#section-genetic-algorithms">Розділі 9</a> і <a href="/neural-networks#section-neural-networks">10</a>.)</p>
  <div data-type="exercise" class="callout">
    <h3 id="exercise-712"><a class="heading-link" href="#exercise-712">Вправа 7.12</a></h3>
    <p>Візуалізуйте Гру Життя, розфарбувавши кожну клітину відповідно до часу, протягом якого вона була живою чи мертвою. Чи можете ви також використовувати історію клітини, для роботи з правилами?</p>
  </div>
</div>
<h3 id="moving-cells"><a class="heading-link" href="#moving-cells">Варіант з рухомими клітинами</a></h3>
<p>У цих базових прикладах клітини мають фіксовану позицію на сітці, але ви можете побудувати КА з клітинами, які не мають фіксованої позиції й натомість рухаються по полотну.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-713"><a class="heading-link" href="#exercise-713">Вправа 7.13</a></h3>
  <p>Використовуйте  правила КА у системі флокування. Уявіть, що кожен боїд має стан (який можливо інформує його керувальну поведінку), а його околиці змінюються від кадру до кадру, коли він наближається до інших боїдів або віддаляється від них.</p>
</div>
<h3 id="nesting"><a class="heading-link" href="#nesting">Варіант із вкладеннями</a></h3>
<p>Як обговорювалося у <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a>, особливістю складних систем є те, що вони можуть бути вкладеними. Місто — це складна система людей, людина — це складна система органів, орган — це складна система клітин тощо. Подумайте як це можна застосувати до КА?</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-714"><a class="heading-link" href="#exercise-714">Вправа 7.14</a></h3>
  <p>Створіть КА у якому кожна клітина є меншим КА.</p>
</div>
<div data-type="project" class="callout">
  <h3 id="the-ecosystem-project-8"><a class="heading-link" href="#the-ecosystem-project-8">Проєкт “Екосистема”</a></h3>
  <p>Включіть у свою екосистему КА. Ось кілька можливостей:</p>
  <ul>
    <li>Надайте кожному створінню стан. Як цей стан може керувати своєю поведінкою? Беручи натхнення з КА, як цей стан може змінюватися з часом відповідно до станів його сусідів?</li>
    <li>Вважайте, що світ екосистеми є КА. Істоти переміщуються від комірки до комірки й кожна комірка має стан. Чи це буде земля? Вода? Їжа?</li>
    <li>Використовуйте КА, щоб створити патерн для дизайну створіння вашої екосистеми.</li>
  </ul>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1420&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#b8b8b8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/1237ee444411bc8e4a732016d3a4f514/be6fc/07_ca_33.webp 576w,./static/1237ee444411bc8e4a732016d3a4f514/7c4ba/07_ca_33.webp 1152w,./static/1237ee444411bc8e4a732016d3a4f514/2e9c6/07_ca_33.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/1237ee444411bc8e4a732016d3a4f514/43bff/07_ca_33.png" data-srcset="./static/1237ee444411bc8e4a732016d3a4f514/09264/07_ca_33.png 576w,./static/1237ee444411bc8e4a732016d3a4f514/8a8ae/07_ca_33.png 1152w,./static/1237ee444411bc8e4a732016d3a4f514/43bff/07_ca_33.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/1237ee444411bc8e4a732016d3a4f514/be6fc/07_ca_33.webp 576w,./static/1237ee444411bc8e4a732016d3a4f514/7c4ba/07_ca_33.webp 1152w,./static/1237ee444411bc8e4a732016d3a4f514/2e9c6/07_ca_33.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/1237ee444411bc8e4a732016d3a4f514/43bff/07_ca_33.png" srcSet="./static/1237ee444411bc8e4a732016d3a4f514/09264/07_ca_33.png 576w,./static/1237ee444411bc8e4a732016d3a4f514/8a8ae/07_ca_33.png 1152w,./static/1237ee444411bc8e4a732016d3a4f514/43bff/07_ca_33.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
</div>
</section>
<hr/><section class="not-prose flex w-full justify-between"><div><a class="group block" href="./physics-libraries.html"><p class="text-gray-500">Попередній розділ</p><span class="text-lg font-semibold group-hover:underline">← <!-- -->6. Фізичні бібліотеки</span></a></div><div><a class="group block text-right" href="./fractals.html"><p class="text-gray-500">Наступний розділм</p><span class="text-lg font-semibold group-hover:underline">8. Фрактали<!-- --> →</span></a></div></section></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script src="./assets/js/main.js"></script></body></html>