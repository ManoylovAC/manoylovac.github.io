<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta data-react-helmet="true" name="description" content="Подумайте про те, чого ви вже досягли з цією книгою: Ці дії призвели до набору симуляцій руху, які дозволяють вам творчо визначати фізику світів, які "/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:url" content="https://natureofcode.com"/><meta data-react-helmet="true" property="og:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/><meta data-react-helmet="true" property="og:title" content="6. Фізичні бібліотеки"/><meta data-react-helmet="true" property="og:description" content="Подумайте про те, чого ви вже досягли з цією книгою: Ці дії призвели до набору симуляцій руху, які дозволяють вам творчо визначати фізику світів, які "/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="6. Фізичні бібліотеки"/><meta data-react-helmet="true" name="twitter:description" content="Подумайте про те, чого ви вже досягли з цією книгою: Ці дії призвели до набору симуляцій руху, які дозволяють вам творчо визначати фізику світів, які "/><meta data-react-helmet="true" name="twitter:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/>

    <link rel="stylesheet" href="./assets/styles/global.css">

    <noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="./favicon-32x32.png" type="image/png"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title data-react-helmet="true">6. Фізичні бібліотеки / Nature of Code</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="fixed left-0 right-0 top-0 z-40 bg-white px-6 lg:px-8"><div class="mx-auto flex h-[5em] max-w-6xl items-center justify-between"><div class="flex flex-col gap-x-6 lg:flex-row lg:items-center"><a href="./"><span class="text-lg font-black tracking-widest text-noc-400"><span class="font-black">ПРИРОДА</span> КОДУ</span></a><span class="hidden text-sm tracking-widest text-noc-400 xl:block">ДАНІЕЛЬ ШИФФМАН</span></div><button class="flex h-9 w-11 cursor-pointer flex-col items-center justify-between p-2 lg:hidden" aria-label="Toggle menu" title="Toggle menu"><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-opacity" style="opacity:1"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span></button><div class="hidden items-center gap-6 lg:flex"><ul class="flex items-center gap-6"><li><a href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M458.4 64.3C400.6 15.7 311.3 23 256 79.3 200.7 23 111.4 15.6 53.6 64.3-21.6 127.6-10.6 230.8 43 285.5l175.4 178.7c10 10.2 23.4 15.9 37.6 15.9 14.3 0 27.6-5.6 37.6-15.8L469 285.6c53.5-54.7 64.7-157.9-10.6-221.3zm-23.6 187.5L259.4 430.5c-2.4 2.4-4.4 2.4-6.8 0L77.2 251.8c-36.5-37.2-43.9-107.6 7.3-150.7 38.9-32.7 98.9-27.8 136.5 10.5l35 35.7 35-35.7c37.8-38.5 97.8-43.2 136.5-10.6 51.1 43.1 43.5 113.9 7.3 150.8z"></path></svg>SUPPORT</a></li><li><a href="https://github.com/ManoylovAC/manoylovac.github.io/tree/master/noc2" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>GITHUB</a></li><li><a href="https://thecodingtrain.com/" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./static/codingtrain_logo-53b0a841be45c7eac7a12f88b7bea596.png" alt="Coding Train&#x27;s logo" class="-ml-2 w-8"/>CODING TRAIN</a></li></ul><div class="not-prose flex items-center gap-4 undefined"><div class="relative"><a href="https://natureofcode.com/" target="_blank" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./favicon-32x32.png" alt="The Nature Of Code logo" class="noc2-logo"/>THE NATURE OF CODE</a></div></div></div></div></header>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YD31R75NSS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YD31R75NSS');
    </script>
    <nav class="fixed bottom-0 left-0 right-0 top-[5em] z-20 overflow-y-auto bg-white px-6 lg:hidden mb-menu hidden">
        <ul class="my-7 space-y-2">
            <li><a class="text-lg text-gray-800" href="./dedication.html">Присвята</a></li>
            <li><a class="text-lg text-gray-800" href="./acknowledgements.html">Подяки</a></li>
            <li><a class="text-lg text-gray-800" href="./introduction.html">Вступ</a></li>
            <li>
                <button class="sub-menu-btn flex items-center gap-2 text-lg text-gray-800">
                    <span>Розділи</span>
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 transition-transform" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="transform: scaleY(1);"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <ul class="space-y-2 py-2 pl-4 sub-menu hidden">
                    <li><a class="flex items-center text-gray-600" href="./random.html"><span class="w-8">0</span><span>Випадковість</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./vectors.html"><span class="w-8">1</span><span>Вектори</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./forces.html"><span class="w-8">2</span><span>Сили</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./oscillation.html"><span class="w-8">3</span><span>Коливання</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./particles.html"><span class="w-8">4</span><span>Система частинок</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./autonomous-agents.html"><span class="w-8">5</span><span>Автономні агенти</span></a></li>
                    <li><a aria-current="page" class="flex items-center text-gray-600 font-bold" href="./physics-libraries.html"><span class="w-8">6</span><span>Фізичні бібліотеки</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./cellular-automata.html"><span class="w-8">7</span><span>Клітинні автомати</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./fractals.html"><span class="w-8">8</span><span>Фрактали</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./genetic-algorithms.html"><span class="w-8">9</span><span>Еволюційне моделювання</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./neural-networks.html"><span class="w-8">10</span><span>Нейронні мережі</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./neuroevolution.html"><span class="w-8">11</span><span>Нейроеволюція</span></a></li>
                </ul>
            </li>
            <li><a class="text-lg text-gray-800" href="./appendix-creature.html">Додаток: Дизайн створінь</a></li>
            <li><a class="text-lg text-gray-800" href="./resources.html">Додаткові ресурси</a></li>
            <li><a class="text-lg text-gray-800" href="./credits.html">Credits</a></li>
            <li><a class="text-lg text-gray-800" href="./translation.html">Про переклад</a></li>
            <li><a class="text-lg text-gray-800" href="./examples.html">Приклади</a></li>
        </ul>
        <ul class="my-7 space-y-2">
            <li><a target="_blank" href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1 text-lg text-gray-800">Support<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
            <li><a target="_blank" href="https://github.com/ManoylovAC/manoylovac.github.io/tree/master/noc2" class="flex items-center gap-1 text-lg text-gray-800">GitHub<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
            <li><a target="_blank" href="https://thecodingtrain.com/" class="flex items-center gap-1 text-lg text-gray-800">Coding Train<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>

            <li><a target="_blank" href="https://natureofcode.com/" class="flex items-center gap-1 text-lg text-gray-800">The Nature Of Code<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
        </ul>
    </nav>
    <div class="mt-[6em] px-6 lg:px-8"><div class="mx-auto max-w-6xl lg:flex lg:justify-between lg:gap-10 xl:gap-14"><aside class="sticky top-[6em] z-10 hidden max-h-[calc(100vh-6em)] min-w-[14em] overflow-y-auto pb-8 lg:block lg:flex-grow"><nav class="border-noc-200 rounded-3xl border"><ul class="divide-noc-200 divide-y"><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./dedication.html">Присвята</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./acknowledgements.html">Подяки</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./introduction.html">Вступ</a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./random.html"><span class="w-8">0</span><span class="group-hover:underline">Випадковість</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./vectors.html"><span class="w-8">1</span><span class="group-hover:underline">Вектори</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./forces.html"><span class="w-8">2</span><span class="group-hover:underline">Сили</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./oscillation.html"><span class="w-8">3</span><span class="group-hover:underline">Коливання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./particles.html"><span class="w-8">4</span><span class="group-hover:underline">Системи частинок</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./autonomous-agents.html"><span class="w-8">5</span><span class="group-hover:underline">Автономні агенти</span></a></li><li><a aria-current="page" class="group relative flex items-center px-3 py-2 text-sm font-bold" href="./physics-libraries.html"><span class="w-8">6</span><span class="group-hover:underline">Фізичні бібліотеки</span></a><ul class="space-y-1 pb-2"><li><a href="#why-use-a-physics-library" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Навіщо використовувати фізичну бібліотеку?</a></li><li><a href="#importing-the-matterjs-library" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Імпорт бібліотеки Matter.js</a></li><li><a href="#matterjs-overview" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Огляд Matter.js</a></li><li><a href="#matterjs-with-p5js" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Matter.js з p5.js</a></li><li><a href="#static-matterjs-bodies" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Статичні тіла Matter.js</a></li><li><a href="#polygons-and-groups-of-shapes" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Багатокутники та групи фігур</a></li><li><a href="#matterjs-constraints" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Обмежувачі Matter.js</a></li><li><a href="#adding-more-forces" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Додаємо більше сил</a></li><li><a href="#collision-events" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Події зіткнення</a></li><li><a href="#a-brief-interlude-integration-methods" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Коротка інтерлюдія: Методи інтегрування</a></li><li><a href="#verlet-physics-with-toxiclibsjs" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Фізика Верле з використанням Toxiclibs.js</a></li><li><a href="#soft-body-simulations" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Симуляції м’яких тіл</a></li><li><a href="#attraction-and-repulsion-behaviors" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Поведінки притягання і відштовхування</a></li></ul></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./cellular-automata.html"><span class="w-8">7</span><span class="group-hover:underline">Клітинні автомати</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./fractals.html"><span class="w-8">8</span><span class="group-hover:underline">Фрактали</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./genetic-algorithms.html"><span class="w-8">9</span><span class="group-hover:underline">Еволюційне моделювання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neural-networks.html"><span class="w-8">10</span><span class="group-hover:underline">Нейронні мережі</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neuroevolution.html"><span class="w-8">11</span><span class="group-hover:underline">Нейроеволюція</span></a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./appendix-creature.html">Додаток: Дизайн створінь </a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./resources.html">Додаткові ресурси</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./credits.html">Credits</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./translation.html">Про переклад</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./examples.html">Приклади</a></li></ul></nav></aside><main class="prose mx-auto max-w-[50em] pb-8"><section data-type="chapter" id="section-physics-libraries">
<h1 id="chapter-6-physics-libraries">Розділ 6. Фізичні бібліотеки</h1>
<div class="chapter-opening-quote">
  <blockquote data-type="epigraph">
    <p>Бібліотека означає віри акт</p>
    <p>В якому покоління, що і досі темрявою оповиті</p>
    <p>Засвідчують в пітьмі, що стануть свідками свого світанку.</p>
    <div class="chapter-opening-quote-source">
      <p>— Віктор Гюго</p>
    </div>
  </blockquote>
</div>
<div class="chapter-opening-figure">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1280px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;720&#x27; width=&#x27;1280&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#282818;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/7a1bdbb18685676cbab3c1bc8aeb5e37/c0bcc/06_libraries_1.webp 320w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/17574/06_libraries_1.webp 640w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/71d4d/06_libraries_1.webp 1280w" sizes="(min-width: 1280px) 1280px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1280px) 1280px, 100vw" decoding="async" loading="lazy" data-src="./static/7a1bdbb18685676cbab3c1bc8aeb5e37/87706/06_libraries_1.png" data-srcset="./static/7a1bdbb18685676cbab3c1bc8aeb5e37/f80f8/06_libraries_1.png 320w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/9a63f/06_libraries_1.png 640w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/87706/06_libraries_1.png 1280w" alt="Фото Аршії Урведжі Босе"/></picture><noscript><picture><source type="image/webp" srcSet="./static/7a1bdbb18685676cbab3c1bc8aeb5e37/c0bcc/06_libraries_1.webp 320w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/17574/06_libraries_1.webp 640w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/71d4d/06_libraries_1.webp 1280w" sizes="(min-width: 1280px) 1280px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1280px) 1280px, 100vw" decoding="async" loading="lazy" src="./static/7a1bdbb18685676cbab3c1bc8aeb5e37/87706/06_libraries_1.png" srcSet="./static/7a1bdbb18685676cbab3c1bc8aeb5e37/f80f8/06_libraries_1.png 320w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/9a63f/06_libraries_1.png 640w,./static/7a1bdbb18685676cbab3c1bc8aeb5e37/87706/06_libraries_1.png 1280w" alt="Фото Аршії Урведжі Босе"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
  <span id="living-root-bridges-photo-by-arshiya-urveeja-bose"><a class="heading-link" href="#living-root-bridges-photo-by-arshiya-urveeja-bose">Живі кореневі мости (фото Аршії Урведжі Босе)</a></span>
  <p>В індійському штаті Мегхалая, люди племен Кхасі й Джайнті живуть у місцевостях з одним із найбільших рівнів опадів серед усього світу. Під час сезону мусонів повені часто унеможливлюють подорож між селами. У результаті виникла давня традиція будування живих кореневих мостів. Ці мости створюють, направляючи та пророщуючи коріння дерев через бамбук, пальмові стовбури або сталеві риштування. Вони ростуть і міцніють у міру взаємодії коріння з навколишнім середовищем, утворюючи адаптовані та пружні з’єднання.</p>
<hr/></div>
<p></p>
<p>Подумайте про те, чого ви вже досягли з цією книгою:</p>
<ol>
  <li>Дізналися про концепції зі світу фізики (що таке вектор, сила, хвиля тощо)</li>
  <li>Зрозуміли математику й алгоритми, що стоять за цими концепціями</li>
  <li>Реалізували ці алгоритми в p5.js з об’єктно-орієнтованим підходом, що дозволило вам створювати симуляції автономних керованих агентів</li>
</ol>
<p>Ці дії призвели до набору симуляцій руху, які дозволяють вам творчо визначати фізику світів, які ви будуєте (реалістичних чи фантастичних). Але, звісно, ми з вами не перші й не єди ні люди, хто це робить. Світ комп’ютерної графіки й програмування сповнений вже написаних бібліотек коду для фізичних симуляцій.</p>
<p>Просто спробуйте пошукати <em>open-source physics engine</em> і ви можете провести решту свого дня, переглядаючи безліч складних та багатих бібліотек коду. Напрошується запитання: якщо готові бібліотеки коду вже дбають про фізичні симуляції, навіщо вам самостійно вчитися писати будь-які алгоритми? Ось тут проявляється філософія цієї книги. Попри те, що багато бібліотек надають готові рішення для експериментування з фізичними симуляціями, є кілька вагомих причин для вивчення основи з нуля перед зануренням у такі бібліотеки.</p>
<p>По-перше, без розуміння векторів, сил і тригонометрії легко загубитися, просто читаючи документацію бібліотеки, не кажучи вже про її використання. По-друге, навіть якщо бібліотека може подбати про математику під капотом, це не обов’язково спростить ваш код. Вивчення того, як працює бібліотека і що вона очікуватиме від вас при програмуванні, може накладати додаткові ускладнення. Нарешті, немає значення наскільки чудовим буде готовий фізичний рушій, адже глибоко у своєму серці ви, швидше за все, прагнете створювати світи та візуалізації, які розширюють межі уяви. Тож, хоча бібліотека може бути хорошою, вона надає лише обмежений набір функціональності. При роботі над творчим програмним проєктом важливо розуміти, коли можна працювати у межах цих рамок, а коли вони можуть бути обмежувальними.</p>
<p>Цей розділ присвячений дослідженню двох фізичних бібліотек JavaScript з відкритим кодом: <a href="https://brm.io/matter-js" target="_blank" rel="noopener">Matter.js</a> і <a href="http://haptic-data.com/toxiclibsjs" target="_blank" rel="noopener">Toxiclibs.js</a>. Я не маю на увазі, що для будь-яких творчих проєктів де корисним може бути фізичний рушій варто користуватись лише цими бібліотеками (щоб дізнатися про деякі альтернативи перегляньте секцію <a href="#other-physics-libraries" class="page-reference">“Інші фізичні бібліотеки”</a> і перевірте вебсайт книги щодо додаткових прикладів розділу, зроблених за допомогою інших бібліотек). Однак обидві вони чудово інтегруються з p5.js та дозволяють мені продемонструвати основні концепції, що лежать в основі фізичних рушіїв і те, як вони пов’язані й побудовані на основі матеріалу, який я вже розглянув до цього часу.</p>
<p>Зрештою, мета цього розділу полягає не у навчанні подробиць конкретної фізичної бібліотеки, а у наданні основи для роботи з <em>будь-якою</em> фізичною бібліотекою. Навички, які ви тут набудете, дозволять вам розбиратися і розуміти документацію, відкриваючи двері для розширення ваших можливостей з будь-якою обраною бібліотекою.</p>
<h2 id="why-use-a-physics-library"><a class="heading-link" href="#why-use-a-physics-library">Навіщо використовувати фізичну бібліотеку?</a></h2>
<p>Я вже виклав аргументи на користь написання власних фізичних симуляцій (які ви навчились робити в попередніх розділах), але які аргументи є на користь використання фізичної бібліотеки? Зрештою, щоразу, коли ви додаєте до проєкту ферймоворк чи бібліотеку, це вносить певне ускладнення і додатковий код. Чи ці додаткові ускладнення справді того варті? Наприклад, якщо вам просто потрібно змоделювати падіння кульки під дією сили тяжіння, чи справді вам потрібно імпортувати цілий фізичний рушій і вивчати його API? Сподіваюся, як показали перші розділи цієї книги, ймовірно, ні. Багато подібних сценаріїв, достатньо прості, щоб ви могли реалізувати їх самостійно.</p>
<p>Але розглянемо інший сценарій. Що, якщо ви хочете, щоб падало 100 кульок? І що, якщо замість кульок потрібні багатокутники неправильної форми? І що, якщо ви хочете, щоб ці багатокутники реалістично відштовхувались один від одного під час зіткнення?</p>
<p>Можливо, ви помітили, що хоча я докладно розглянув рух і сили, я поки що пропустив досить важливий аспект фізичного моделювання: <strong>зіткнення</strong>. Давайте на мить уявимо, що ви не читаєте розділ про фізичні бібліотеки і я вирішив прямо зараз пояснити, як справлятися із зіткненнями в системі частинок. Я мав би охопити два різних алгоритми, які відповідають на ці запитання:</p>
<ol>
  <li>Як визначити, що дві фігури стикаються (або перетинаються)? Тут потрібен алгоритм <strong>виявлення зіткнень</strong>.</li>
  <li>Як визначити швидкості фігур після зіткнення? Тут потрібен алгоритм <strong>розв’язання зіткнень</strong>.</li>
</ol>
<p>Якщо ви працюєте з простими геометричними фігурами, перше питання не дуже складне. Насправді ви стикалися з подібним раніше. Для двох кульок, наприклад, стан перетину відбувається, коли відстань між їх центрами менша за суму їхніх радіусів (див. малюнок 6.1).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;899&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/6b6cb557681d2df067780aa572bbe1c2/fc4f1/06_libraries_2.webp 576w,./static/6b6cb557681d2df067780aa572bbe1c2/1e137/06_libraries_2.webp 1152w,./static/6b6cb557681d2df067780aa572bbe1c2/ae25a/06_libraries_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/6b6cb557681d2df067780aa572bbe1c2/31c91/06_libraries_2.png" data-srcset="./static/6b6cb557681d2df067780aa572bbe1c2/c6a58/06_libraries_2.png 576w,./static/6b6cb557681d2df067780aa572bbe1c2/5598c/06_libraries_2.png 1152w,./static/6b6cb557681d2df067780aa572bbe1c2/31c91/06_libraries_2.png 2304w" alt="Малюнок 6.1: Два кола з радіусами r_1 і r_2 стикаються, якщо відстань між ними менша ніж r_1 + r_2"/></picture><noscript><picture><source type="image/webp" srcSet="./static/6b6cb557681d2df067780aa572bbe1c2/fc4f1/06_libraries_2.webp 576w,./static/6b6cb557681d2df067780aa572bbe1c2/1e137/06_libraries_2.webp 1152w,./static/6b6cb557681d2df067780aa572bbe1c2/ae25a/06_libraries_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/6b6cb557681d2df067780aa572bbe1c2/31c91/06_libraries_2.png" srcSet="./static/6b6cb557681d2df067780aa572bbe1c2/c6a58/06_libraries_2.png 576w,./static/6b6cb557681d2df067780aa572bbe1c2/5598c/06_libraries_2.png 1152w,./static/6b6cb557681d2df067780aa572bbe1c2/31c91/06_libraries_2.png 2304w" alt="Малюнок 6.1: Два кола з радіусами r_1 і r_2 стикаються, якщо відстань між ними менша ніж r_1 + r_2"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.1: Дві кульки з радіусами <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> стикаються, якщо відстань між ними менша ніж <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_1 + r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></figcaption>
</figure>
<p>Це досить легко, а як щодо обчислення швидкостей кульок після зіткнення? На цьому я збираюся завершити обговорення. Чому? Справа не в тому, що розуміння математики, яка стоїть за зіткненнями, не важлива або не цінна. (Насправді я включаю додаткові приклади на вебсайті, пов’язані із зіткненнями без використання фізичної бібліотеки.) Причина зупинки полягає в тому, що життя коротке! (Нехай це також буде причиною для вас, щоб вийти на вулицю і трохи прогулятися перш ніж сісти писати свою наступну програму.) Не слід очікувати, що ви опануєте кожний можливий аспект фізичного моделювання. І хоча ви можете насолоджуватися вивченням розв’язків зіткнень для кульок, це лише спонукатиме у вас бажання перейти далі до роботи з прямокутниками. А потім до багатокутників складнішої форми. А потім до фігур з криволінійними поверхнями. А потім до маятників, що стикаються з пружними пружинами. А потім, а потім, а потім...</p>
<p>Можливість включити у програму p5.js складніший функціонал, такий як зіткнення, і при цьому мати необхідний час на спілкування з друзями й родиною — ось для чого цей розділ. Люди витратили роки на розробку рішень такого роду проблем і чудові JavaScript-бібліотеки, такі як Matter.js та Toxiclibs.js є плодами цих зусиль. Тож немає потреби заново винаходити колесо, принаймні поки що.</p>
<p>На завершення, якщо ви описуєте ідею для програми p5.js і згадуєте слово <em>зіткнення</em>, то, ймовірно, настав час навчитися використовувати фізичний рушій.</p>
<div class="allow-break">
  <div data-type="note" class="callout">
    <h3 id="other-physics-libraries"><a class="heading-link" href="#other-physics-libraries">Інші фізичні бібліотеки</a></h3>
    <p>Існує безліч інших фізичних бібліотек, вартих дослідження поруч із тими двома, що будуть розглянуті у цьому розділі, кожна з унікальними перевагами, які можуть надати вигоди в певних типах проєктів. Насправді коли я тільки почав писати цю книгу, бібліотеки Matter.js не існувало, тому фізичним рушієм, який я спочатку використовував для демонстрації прикладів, був Box2D. Це був (і, ймовірно, залишається) найвідоміший фізичний рушій з усіх.</p>
    <p><a href="https://box2d.org/" target="_blank" rel="noopener">Box2D</a> розпочався як набір уроків з фізики, написаних Еріном Катто на C++ для конференції розробників ігор у 2006 році. З того часу Box2D перетворився на багатий і складний фізичний рушій з відкритим кодом. Його використовували у безлічі проєктах та іграх, особливо вдалими з яких є визнана нагородами <em>Crayon Physics</em> і неперевершений хіт <em>Angry Birds</em>.</p>
    <p>Однією з важливих особливостей Box2D є те, що це справжній фізичний рушій: він нічого не знає про комп’ютерну графіку і світ пікселів, а натомість виконує всі вимірювання та обчислення в реальних одиницях, таких як метри, кілограми та секунди. Просто його “світ” (ключовий термін у Box2D) — це 2D площина з верхнім, нижнім, лівим і правим краями. Ви говорите йому щось на кшталт: “Гравітація світу становить 9.81 ньютона на кілограм, а коло з радіусом 4 метри й масою 50 кілограмів розташоване на висоті 10 метрів від нижнього краю землі”. Box2D потім повідомить вам такі речі, як: “Через секунду коло знаходиться на відстані 8 метрів від нижнього краю, через дві секунди на відстані 5 метрів...” і так далі.</p>
    <p>Попри те, що це забезпечує надзвичайно точний і надійний фізичний рушій (дуже оптимізований і швидкий для проєктів на C++), він також вимагає багато складного коду для переведення взаємодії між фізичним світом і світом, який ви хочете намалювати — піксельним світом графічного полотна. Це створює величезне навантаження для кодера. Наскільки зможу, я продовжуватиму підтримувати для цієї книги набір прикладів, сумісних із Box2D (є кілька портів на JavaScript), але вважаю, що відносна простота роботи з бібліотеками типу Matter.js, яка є нативною для JavaScript і використовує пікселі як одиницю вимірювання, зробить мої приклади на p5.js більш інтуїтивно зрозумілими й дружніми.</p>
    <p>Іншою відомою бібліотекою є <a href="https://p5play.org/" target="_blank" rel="noopener">p5play</a> — проєкт ініційований Паоло Педерчіні та наразі очолюваний Квінтоном Ешлі, який був спеціально розроблений для розробки ігор. Бібліотека спрощує створення візуальних об’єктів, відомих як спрайти й керує їх взаємодією, зокрема зіткненнями та перекриттями. Як ви, можливо, здогадалися з назви, p5play створена для зручної роботи з p5.js. Для симуляції фізики вона під капотом викорис товує Box2D.</p>
  </div>
</div>
<h2 id="importing-the-matterjs-library"><a class="heading-link" href="#importing-the-matterjs-library">Імпорт бібліотеки Matter.js</a></h2>
<p>За мить я перейду до роботи з Matter.js, створеної Ліамом Броммітом у 2014 році. Але перш ніж ви зможете використовувати зовнішню бібліотеку JavaScript, вам потрібно імпортувати її у свій проєкт. Як ви вже добре знаєте, для розробки та поширення прикладів коду цієї книги, я використовую офіційний вебредактор p5.js. Найпростіший спосіб додати бібліотеку — відредагувати файл index.html, який є частиною кожної нової програми p5.js, створеної у редакторі.</p>
<p>Для цього спочатку розгорніть панель навігації файлів у лівій частині редактора і виберіть <em>index.html</em>, як показано на малюнку 6.2.</p>
<p>Файл містить послідовність тегів <code>&lt;script&gt;</code> усередині HTML тегів <code>&lt;head&gt;</code> і <code>&lt;/head&gt;</code>. Саме так в проєкті p5.js підключаються JavaScript-бібліотеки. Це практично нічим не відрізняється від підключення файлів <code>sketch.js</code> або <code>particle.js</code> у <code>&lt;body&gt;</code>, тільки тут, замість збереження і редагування копії самого JavaScript коду, на код бібліотеки відбувається посилання через URL-адресу <strong>мережі доправлення вмісту (CDN)</strong>. Це тип серве ра для розміщення файлів. Для JavaScript-бібліотек, які використовуються на сотнях тисяч вебсторінок, до яких мають доступ мільйони користувачів, CDN-сервери повинні дуже добре справлятися зі своєю роботою передачі цих файлів.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2218px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1590&#x27; width=&#x27;2218&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/2dd8d3f32b6a2dc537354070eb3dc3bb/4ea62/06_libraries_3.webp 555w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/f6d08/06_libraries_3.webp 1109w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/f7dad/06_libraries_3.webp 2218w" sizes="(min-width: 2218px) 2218px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2218px) 2218px, 100vw" decoding="async" loading="lazy" data-src="./static/2dd8d3f32b6a2dc537354070eb3dc3bb/d304b/06_libraries_3.png" data-srcset="./static/2dd8d3f32b6a2dc537354070eb3dc3bb/e39bc/06_libraries_3.png 555w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/3b6c2/06_libraries_3.png 1109w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/d304b/06_libraries_3.png 2218w" alt="Малюнок 6.2: Доступ до файлу index.html програми"/></picture><noscript><picture><source type="image/webp" srcSet="./static/2dd8d3f32b6a2dc537354070eb3dc3bb/4ea62/06_libraries_3.webp 555w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/f6d08/06_libraries_3.webp 1109w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/f7dad/06_libraries_3.webp 2218w" sizes="(min-width: 2218px) 2218px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2218px) 2218px, 100vw" decoding="async" loading="lazy" src="./static/2dd8d3f32b6a2dc537354070eb3dc3bb/d304b/06_libraries_3.png" srcSet="./static/2dd8d3f32b6a2dc537354070eb3dc3bb/e39bc/06_libraries_3.png 555w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/3b6c2/06_libraries_3.png 1109w,./static/2dd8d3f32b6a2dc537354070eb3dc3bb/d304b/06_libraries_3.png 2218w" alt="Малюнок 6.2: Доступ до файлу index.html програми"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.2: Доступ до файлу <em>index.html</em></figcaption>
</figure>
<p>Ви вже повинні були побачити тег <code>&lt;script&gt;</code> із посиланням на CDN для самого p5.js (на час вашого читання це може бути новіша версія):</p>
<div class="codesplit callout not-prose" data-code-language="html"><div class="pair"><pre><code class="hljs code language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><div class="comment"><p></p></div></div></div>
<p>Для підключення Matter.js додайте ще один тег <code>&lt;script&gt;</code> із посиланням на його CDN прямо під підключенням p5.js:</p>
<div class="codesplit callout not-prose" data-code-language="html"><div class="pair"><pre><code class="hljs code language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><div class="comment"><p></p></div></div></div>
<p>На момент написання цього тексту останньою версією Matter.js була <code>0.19.0</code>, саме та версія, яку я використав у наведеному вище фрагменті. При оновленнях Matter.js і випуску нових версій часто доцільною ідеєю є оновити бібліотеку проєкту, але посилаючись на конкретну версію про яку ви знаєте, що вона працює з вашим кодом, ви не повинні турбуватися, що нові функції бібліотеки порушать ваш поточну програму.</p>
<h2 id="matterjs-overview"><a class="heading-link" href="#matterjs-overview">Огляд Matter.js</a></h2>
<p>Коли ви використовуєте Matter.js (або будь-який інший фізичний рушій) у p5.js, ваш код виглядає дещо інакше. Ось узагальнений псевдокод усіх прикладів у розділах з 1-го по 5-й:</p>
<p><code><strong>setup()</strong></code></p>
<ol>
  <li>Створення всіх об’єктів світу.</li>
</ol>
<p><code><strong>draw()</strong></code></p>
<ol>
  <li>Розрахунок усіх сил світу.</li>
  <li>Застосування всіх сил до об’єктів (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>M</mi><mo>∗</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">F = M * A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">M</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span>).</li>
  <li>Оновлення положення всіх об’єктів на основі їх прискорення.</li>
  <li>Малювання всіх об’єктів.</li>
</ol>
<p>Для порівняння ось псевдокод для прикладу з Matter.js:</p>
<p><code><strong>setup()</strong></code></p>
<ol>
  <li>Створення всіх об’єктів світу.</li>
</ol>
<p><code><strong>draw()</strong></code></p>
<ol>
  <li>Малювання всіх об’єктів.</li>
</ol>
<p>Це, звісно, привабливість фізичного рушія. Я видалив усі ті болючі кроки обчислення того, як об’єкти рухаються відповідно до швидкості та прискорення. Matter.js подбає про це за мене!</p>
<p>Хоча буде ще багато деталей для розкриття, хороша новина полягає в тому, що простота цього псевдокоду точно відображає загальний процес. У цьому сенсі Matter.js трохи схожа на чарівну скриньку. У функції <code>setup()</code> я скажу до Matter: “Привіт! Ось усі речі, які я хочу у своєму світі”. А потім, у функції <code>draw()</code>, я ввічливо попрошу Matter: “О, привіт ще раз! Якщо це не дуже складно, я хотів би намалювати всі ці речі у своєму світі. Скажи мені, будь ласка, де вони знаходяться?”</p>
<p>Погана новина: це не так просто, як може здатися із псевдокоду. Насправді створення об’єктів, які потрапляють у світ Matter.js, включає кілька кроків, пов’язаних з тим, як будуються і налаштовуються різні типи фігур.</p>
<div class="avoid-break">
  <p>Також необхідно навчитися говорити мовою Matter.js щодо налаштувань різних сил та інших параметрів світу. Ось основні поняття:</p>
  <ul>
    <li><strong>Рушій (двигун):</strong> сутність, яка керує самою фізичною симуляцією. Рушій зберігає “світ” симуляції, а також різні властивості про те, як світ оновлюється з часом.</li>
  </ul>
</div>
<ul>
  <li><strong>Тіла:</strong> слугують основними елементами світу, які відповідають фізичним об’єктам, що моделюються. Тіла мають положення і швидкість. Звучить знайомо? По суті, це ще одна версія класу, який я будував протягом усіх розділів з 1-го по 5-й. Тіла також мають геометрію для визначення їх форми. Важливо зауважити, що <em>тіло</em> — це загальний термін, який фізичні рушії використовують для опису <em>речі</em> у світі (подібно до терміну <em>частинка</em>), і це не має відношення до антропоморфного тіла.</li>
  <li><strong>Композит:</strong> контейнер, який дозволяє створювати складні сутності, що складаються з кількох тіл. Сам світ є прикладом композиту і кожне створене тіло має бути додане до світу.</li>
  <li><strong>Обмежувачі (обмеження):</strong> діють як з’єднання між тілами.</li>
</ul>
<p>У наступних розділах я детально розгляну кожен з цих елементів, будуючи в процесі кілька прикладів. Але спочатку є ще один важливий елемент, який варто коротко обговорити:</p>
<ul>
  <li><strong>В ектор:</strong> описує об’єкт із магнітудою і напрямком за допомогою <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-компонентів, що визначають позиції, швидкості та сили у світі Matter.js.</li>
</ul>
<p>Це підводить нас до важливого роздоріжжя. Будь-яка фізична бібліотека фундаментально побудована довкола концепції векторів, і залежно від того, як ви це сприймаєте, це може бути як плюсом, так і мінусом. Позитивна сторона полягає в тому, що ви щойно провели кілька розділів, знайомлячись із тим, як описувати рух і сили за допомогою векторів, тому концептуально нічого нового вчити не потрібно. Негативна сторона, яка змушує мене зронити сльозу, полягає в тому, що як тільки ви переступите цей поріг у чудовий новий світ фізичних бібліотек, ви більше не зможете використовувати <code>p5.Vector</code>.</p>
<p>Чудово, що p5.js має вбудоване векторне представлення, але кожного разу, коли ви користуєте ся фізичною бібліотекою, ви, швидше за все, виявите, що вона включає власну реалізацію вектора, розроблену для особливої сумісності з рештою коду бібліотеки. Це має сенс. Зрештою, чому Matter.js повинен знати про об’єкти <code>p5.Vector</code>?</p>
<p>У підсумку все зводиться до того, що вам не доведеться вивчати нові концепції, але доведеться звикнути до деяких нових конвенцій іменування і синтаксису. Для ілюстрації я покажу деякі вже знайомі вам операції класу <code>p5.Vector</code> поруч з еквівалентним кодом для <code>Matter.Vector</code>. Для початку поглянемо, як створити вектор:</p>
<table><thead><tr><th>p5.js</th><th>Matter.js</th></tr></thead><tbody><tr><td>
        <pre><code>let v = createVector(1, -1);</code></pre>
      </td><td>
        <pre><code>let v = Matter.Vector.create(1, -1);</code></pre>
      </td></tr></tbody></table>
<p>А як додати два вектори?</p>
<table><thead><tr><th>p5.js</th><th>Matter.js</th></tr></thead><tbody><tr><td>
        <pre><code>let a = createVector(1, -1);
let b = createVector(3, 4);
a.add(b);</code></pre>
      </td><td>
        <pre><code>let a = Matter.Vector.create(1, -1);
let b = Matter.Vector.create(3, 4);
Matter.Vector.add(a, b, a);</code></pre>
      </td></tr></tbody></table>
<p>Попередній приклад перезаписує вектор <code>a</code> отриманим результатом. А ось приклад як помістити результат операції в окремий вектор:</p>
<table><thead><tr><th>p5.js</th><th>Matter.js</th></tr></thead><tbody><tr><td>
        <pre><code>let a = createVector(1, -1);
let b = createVector(3, 4);
let c = p5.Vector.add(a, b);</code></pre>
      </td><td>
        <pre><code>let a = Matter.Vector.create(1, -1);
let b = Matter.Vector.create(3, 4);
let c = Matter.Vector.add(a, b);</code></pre>
      </td></tr></tbody></table>
<p>Як щодо масштабування вектора (множення на скалярне значення)?</p>
<table><thead><tr><th>p5.js</th><th>Matter.js</th></tr></thead><tbody><tr><td>
        <pre><code>let v = createVector(1, -1);
v.mult(4);</code></pre>
      </td><td>
        <pre><code>let v = Matter.Vector.create(1, -1);
v = Matter.Vector.mult(v, 4);</code></pre>
      </td></tr></tbody></table>
<p>Як отримати магнітуду і нормалізацію?</p>
<table><thead><tr><th>p5.js</th><th>Matter.js</th></tr></thead><tbody><tr><td>
        <pre><code>let v = createVector(3, 4);
let m = v.mag();
v.normalize();</code></pre>
      </td><td>
        <pre><code>let v = Matter.Vector.create(3, 4);
let m = Matter.Vector.magnitude(v);
v = Matter.Vector.normalise(v);</code></pre>
      </td></tr></tbody></table>
<p>Як бачите, поняття ті самі, але специфіка коду відрізняється. По-перше, кожному імені методу тепер передує запис <code>Matter.Vector</code>, що визначає <strong>простір імен</strong> вихідного коду. Це типово для JavaScript-бібліотек на відміну від p5.js. Наприклад, щоб намалювати круг у p5.js, ви просто викликаєте функцію <code>circle()</code>, а не <code>p5.circle()</code>. Функція <code>circle()</code> знаходиться в глобальному просторі імен. Це, на мій погляд, одна з особливостей, яка робить p5.js особливим з точки зору простоти використання та зручності для по чатківців. Однак це також означає, що при роботі з p5.js, ви не можете використовувати для своїх змінних назви подібні до <code>circle</code>. Простір імен бібліотеки захищає від такого роду помилок і конфліктів імен, тому ви побачите, що у Matter.js все викликається з префіксом <code>Matter</code>.</p>
<p>Крім того, на відміну від статичних і нестатичних методів векторів p5.js, таких як <code>add()</code> і <code>mult()</code>, усі векторні методи в Matter.js статичні. Якщо під час використання <code>Matter.Vector</code> ви хочете змінити вектор з яким працюєте, то можете додати його як необов’язковий третій аргумент: <code>Matter.Vector.add(a, b, a)</code> додає <code>a</code> і <code>b</code> та поміщає результат у <code>a</code> (третій аргумент). Ви також можете присвоїти результат, отриманий у результаті обчислення, вже наявній змінній: <code>v = Matter.Vector.mult(v, 2)</code>. Однак це все одно створює новий вектор у пам’яті, а не оновлює старий.</p>
<p>У цьому розділі я розгляну деякі основні аспекти роботи з <code>Matter.Vector</code>, але для отримання більшої інформації, можна звернутися до <a href="https://brm.io/matter-js" target="_blank" rel="noopener">повної документації</a> на вебсайті Matter.js.</p>
<h3 id="engine"><a class="heading-link" href="#engine">Рушій</a></h3>
<p>Багато фізичних бібліотек включають особливий об’єкт для керування усією симуляцією, що називається <em>світом</em>. Світ, як правило, відповідає за координатний простір, веде список усіх тіл симуляції, контролює час тощо. У Matter.js <em>світ</em> створюється всередині об’єкта <code>Engine</code> — головному контролері симуляції вашого фізичного світу:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Engine</span> = <span class="hljs-title class_">Matter</span>.<span class="hljs-property">Engine</span>;
</code></pre><div class="comment"><p>Посилання на Matter.Engine.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> engine;
</code></pre><div class="comment"><p>Змінна для фізичного рушія Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">360</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  engine = <span class="hljs-title class_">Engine</span>.<span class="hljs-title function_">create</span>();
</code></pre><div class="comment"><p>Створення рушія Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зверніть увагу, що перший рядок коду створює змінну <code>Engine</code> і призначає їй значення <code>Matter.Engine</code>. Тут я вирішив використати назву <code>Engine</code>, що посилатиметься на відповідний клас <code>Engine</code> у просторі імен Matter.js, щоб зробити свій код менш багатослівним. Це нормально, оскільки я знаю, що не використовуватиму слово <code>Engine</code> для інших змінних і воно не конфліктує з чимось із p5.js. У прикладах я буду робити це і для класів <code>Vector</code>, <code>Bodies</code>, <code>Composite</code> та інших. (Але хоча прикріплений вихідний код завжди включатиме усі потрібні посилання, я не завжди показуватиму їх у тексті книги.)</p>
<p>Коли ви викликаєте метод <code>create()</code> через <code>Engine</code>, Matter.js повертає новий фізичний рушій і світ з типовою гравітацією — вектором <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>, що вказує вниз. Ви можете змінити це дефолтне значення, звернувшись до властивості <code>gravity</code> і змінивши її значення:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  engine.<span class="hljs-property">gravity</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;
  engine.<span class="hljs-property">gravity</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Зміна гравітації рушія у горизонтальному напрямку.</p></div></div></div>
<p>Звісно, гравітація не мусить бути фіксованою протягом усієї симуляції. Ви можете змінювати вектор гравітації під час роботи програми. Ви також можете зовсім вимкнути гравітацію, встановивши для її вектора значення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>.</p>
<div data-type="note" class="callout">
  <h3 id="object-destructuring"><a class="heading-link" href="#object-destructuring">Деструктуризація об’єкта</a></h3>
  <p><strong>Деструктуризація об’єкта</strong> у JavaScript — це спосіб отримання властивостей об’єкта і присвоєння їх в окремі змінні. У випадку з Matter.js об’єкт <code>Matter</code> містить властивість <code>Engine</code>. Зазвичай посилання для цієї властивості можна встановити за допомогою запису <code>let Engine = Matter.Engine</code>, але з деструктуруванням це можна зробити більш лаконічно:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Engine</span> } = <span class="hljs-title class_">Matter</span>;
</code></pre><div class="comment"><p></p></div></div></div>
  <p>Зачекайте. Чи ви помітили, що я використав тут <code>const</code>? Я знаю, що сказав ще у <a href="/random#section-random">Розділі 0</a>, що для оголошення змінних у цій книзі використовуватиму лише <code>let</code>. Однак робота із зовнішньою бібліотекою — це дійсно хороший момент, щоб використати <code>const</code>. У JavaScript, <code>const</code> використовується для оголошення змінних, значення яких більше не повинні перепризначатись  після ініціалізації. У цьому випадку я хочу захистити себе від випадкової можливості перезаписати змінну <code>Engine</code> пізніше у коді, що скоріш за все усе зламало б!</p>
  <p>Тепер подивимось, як цей синтаксис деструктуризації справді виблискує, коли вам потрібно створити посилання для кількох властивостей одного об’єкта:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Engine</span>, <span class="hljs-title class_">Vector</span> } = <span class="hljs-title class_">Matter</span>;
</code></pre><div class="comment"><p>Використання деструктуризації об’єкта при створенні окремих посилань на Engine і Vector.</p></div></div></div>
  <p>Це робить із змінних <code>Engine</code> і <code>Vector</code> посилання на <code>Matter.Engine</code> та <code>Matter.Vector</code> і все це в одному рядку. Я буду використовувати цей підхід і у подальших прикладах цього розділу.</p>
</div>
<p>Після ініціалізації світу в нього саме час щось додати — тіла!</p>
<h3 id="bodies"><a class="heading-link" href="#bodies">Тіла</a></h3>
<p><strong>Тіло</strong> є основним елементом у світі Matter.js. Це еквівалент класу <code>Vehicle</code>, розвинутому на базі класу <code>Particle</code>, що виник на основі класу <code>Mover</code>, який я побудував у попередніх розділа х — об’єкт, який рухається у просторі й відчуває силу. Тіло також може бути статичним (зафіксованим і нерухомим).</p>
<p>Тіла Matter.js створюються за допомогою фабричних методів класу <code>Matter.Bodies</code>, який має різні методи для створення різних типів тіл. <strong>Фабричний метод</strong> — це функція, яка створює об’єкт. Хоча ви, ймовірно, більше знайомі з викликом конструктора для створення об’єкта, наприклад з <code>new Particle()</code>, ви вже бачили фабричні методи раніше: <code>createVector()</code> це фабричний метод для створення об’єкта <code>p5.Vector</code>. Чи створюється об’єкт за допомогою конструктора, чи фабричного методу, залежить від стилю і вибору творця бібліотеки.</p>
<p>Усі фабричні методи для створення тіл можна знайти на <a href="https://brm.io/matter-js/docs/classes/Bodies.html" target="_blank" rel="noopener">сторінці документації</a> <code>Matter.Bodies</code>. Я розпочну з методу <code>rectangle()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> box = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h);
</code></pre><div class="comment"><p>Створення тіла Matter.js прямокутної форми.</p></div></div></div>
<p>Яка вдача! Сигнатура методу <code>rectangle()</code> точно така ж, як у функції <code>rect()</code> із p5.js. Однак у цьому випадку метод не <em>малює</em> прямокутник, а створює об’єкт геометрії класу <code>Body</code>. (Зауважте, що виклик <code>Bodies.rectangle()</code> спрацює лише якщо ви попередньо встановили посилання змінної <code>Bodies</code> на <code>Matter.Bodies</code>.)</p>
<p>Тепер маємо створене тіло з позицією і розміром, а посилання на нього зберігається у змінній <code>box</code>. Однак тіла мають і багато інших властивостей, які впливають на їхній рух. Наприклад, є щільність, яка зрештою визначає масу цього тіла. Тертя і реституція (віддача) впливають на взаємодію тіла при контакті з іншими тілами. Для більшості випадків достатньо значень за замовчуванням, але Matter.js дозволяє вам налаштувати ці властивості, передавши додатковий аргумент до фабричного методу у формі <strong>літерала об’єкта</strong> JavaScript, набору із пар ключ-значення, розділених комами й огорнутих фігурними дужками:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">friction</span>: <span class="hljs-number">0.5</span>,
  <span class="hljs-attr">restitution</span>: <span class="hljs-number">0.8</span>,
  <span class="hljs-attr">density</span>: <span class="hljs-number">0.002</span>,
};
</code></pre><div class="comment"><p>Налаштування властивостей для тіла у літералі об’єкта.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> box = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h, options);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Кожен ключ у літералі об’єкта (наприклад, <code>friction</code>) служить унікальним ідентифікатором, а його значення (<code>0.5</code>) є даними, пов’язаними з цим ключем. Літерал об’єкта можна розглядати як простий словник або пошукову таблицю, що у цьому випадку зберігає бажані налаштування для нового тіла Matter.js. Зауважте, що хоча аргумент <code>options</code> корисний для налаштування тіла, інші початкові значення, такі як лінійна або кутова швидкість, можна встановити за допомогою статичних методів класу <code>Matter.Body</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> v = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
<span class="hljs-title class_">Body</span>.<span class="hljs-title function_">setVelocity</span>(box, v);
<span class="hljs-title class_">Body</span>.<span class="hljs-title function_">setAngularVelocity</span>(box, <span class="hljs-number">0.1</span>);
</code></pre><div class="comment"><p>Встановлення дов ільних значень для лінійної та кутової швидкостей.</p></div></div></div>
<p>Створення тіла і збереження його у змінній недостатньо. Будь-яке тіло має бути явно додано до світу, щоб його можна було симулювати за допомогою фізики. Фізичний світ — це об’єкт класу <code>Composite</code>, який називається <code>world</code> і зберігається всередині об’єкту <code>engine</code>. Додати до цього світу тіло <code>box</code> можна за допомогою статичного методу <code>add()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, box);
</code></pre><div class="comment"><p>Додавання об’єкту box до світу рушія.</p></div></div></div>
<p>Цей додатковий крок легко забути — це помилка, яку я і сам неодноразово робив. Якщо ви коли-небудь будете гадати, чому один із ваших об’єктів не з’являється або не рухається разом із фізикою світу, завжди перевіряйте, що ви дійсно додали його до світу!</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-61"><a class="heading-link" href="#exercise-61">Вправа 6.1</a></h3>
  <p>Знаючи те, що ви вже знаєте про Matter.js, заповніть пропуск у наведеному нижче коді, який демонструє, як створити кругле тіло:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">friction</span>: <span class="hljs-number">0.5</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">restitution</span>: <span class="hljs-number">0.8</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> ball = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, radius, options);
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<h3 id="render"><a class="heading-link" href="#render">Рендер</a></h3>
<p>Щойно тіло додано у світ, Matter.js завжди знатиме про нього, перевірятиме його на зіткнення і відповідним чином оновлюватиме його положення згідно з будь-якими силами середовища. Він зробить усе це за вас, вам навіть пальцем не потрібно ворушити! Але як саме ви можете намалювати тіло?</p>
<p>У наступній секції я покажу вам, як дізнатися у Matter.js про положення різних тіл, щоб намалювати цей світ у межах програми p5.js. Ці знання дають змогу контролювати вигляд ваших анімацій. Це ваш зірковий час: ви можете бути дизайнером свого світу, використовуючи свої творчі здібності й навички p5.js для візуалізації тіл, одночасно ввічливо прохаючи Matter.js обчислити всю фізику у фоновому режимі.</p>
<p>Matter.js включає досить простий і зрозумілий клас <code>Render</code>, неймовірно корисний для швидкого перегляду та налагодження спроєктованого світу. Для цілей відладки його можна налаштувати під свій смак, але стандартних параметрів цілком достатньо для швидкої перевірки вашого світу.</p>
<p>Першим кроком потрібно викликами <code>Matter.Render.create()</code> (або <code>Render.create()</code> при наявності змінної-псевдоніма). Цей метод очікує об’єкт із бажаними налаштуваннями для рендерера, який я назвав <code>params</code>:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> canvas = <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">360</span>);
</code></pre><div class="comment"><p>Збереження у змінній посилання на полотно.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> params = {
  <span class="hljs-attr">canvas</span>: canvas.<span class="hljs-property">elt</span>,
  <span class="hljs-attr">engine</span>: engine,
  <span class="hljs-attr">options</span>: { <span class="hljs-attr">width</span>: width, <span class="hljs-attr">height</span>: height },
};
</code></pre><div class="comment"><p>Налаштування параметрів для рендереру.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> render = <span class="hljs-title class_">Render</span>.<span class="hljs-title function_">create</span>(params);
</code></pre><div class="comment"><p>Створення рендереру.</p></div></div></div>
</div>
<p>Зверніть увагу, що я зберігаю посилання на полотно p5.js у змінній <code>canvas</code>. Це необхідно, оскільки рендереру потрібно сказати на якому саме полотні йому потрібно малювати. Matter.js не знає про p5.js, але йому потрібно передати відповідне нативне HTML5-полотно, яке зберігається у властивості <code>elt</code> об’єкта полотна, створеного через p5.js. Рушій — це <code>engine</code>, який я створив раніше. Розміри полотна за замовчуванням у Matter.js становлять 800 на 600 пікселів, тому, якщо я віддаю перевагу іншому розміру, мені потрібно налаштувати властивість <code>options</code> з полями <code>width</code> і <code>height</code>.</p>
<p>Після створення об’єкта <code>render</code> мені потрібно запустити його:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Render</span>.<span class="hljs-title function_">run</span>(render);
</code></pre><div class="comment"><p>Запуск рендерера!</p></div></div></div>
<p>Є ще один важливий робочий момент: фізичним рушіям потрібно повідомляти коли робити крок у часі. Оскільки я використовую вбудований рендерер, я також можу використати вбудований бігунець, який запускатиме рушій із типовою частотою кадрів, що за замовчуванням складає 60 кадрів на секунду. Бігунець також можна налаштовувати, але ці деталі наразі не дуже важливі, оскільки мета полягає в тому, щоб перейти замість нього до використання циклу <code>draw()</code> із p5.js (про це ще буде розказано далі).</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Runner</span>.<span class="hljs-title function_">run</span>(engine);
</code></pre><div class="comment"><p>Запуск рушія!</p></div></div></div>
<p>Ось весь код Matter.js разом із доданим об’єктом <code>ground</code> — ще одним прямокутним тілом. Зверніть увагу на використання опції <code>{ isStatic: true }</code> для тіла <code>ground</code>, що забезпечує його фіксоване положення. Я розповім більше про статичні тіла пізніше у частині про <a href="#static-matterjs-bodies" class="page-reference">“Статичні тіла Matter.js”</a>.</p>
<div data-type="example">
  <h3 id="example-61-matterjs-default-render-and-runner"><a class="heading-link" href="#example-61-matterjs-default-render-and-runner">Приклад 6.1: Matter.js з дефолтним рендером і бігунцем</a></h3>
  <figure data-type="example">
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_1_default_matter_js"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/GXRa48IQO" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Engine</span>, <span class="hljs-title class_">Bodies</span>, <span class="hljs-title class_">Composite</span>, <span class="hljs-title class_">Body</span>, <span class="hljs-title class_">Vector</span>, <span class="hljs-title class_">Render</span> } = <span class="hljs-title class_">Matter</span>;
</code></pre><div class="comment"><p>Зверніть увагу на створення посилань на класи Matter.js, які необхідні для цієї програми.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> canvas = <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">360</span>);
</code></pre><div class="comment"><p>Збереження посилання на полотно.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> engine = <span class="hljs-title class_">Engine</span>.<span class="hljs-title function_">create</span>();
</code></pre><div class="comment"><p>Створення фізичного рушія.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> render = <span class="hljs-title class_">Render</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">canvas</span>: canvas.<span class="hljs-property">elt</span>, engine,
    <span class="hljs-attr">options</span>: { <span class="hljs-attr">width</span>: width, <span class="hljs-attr">height</span>: height },
  });
  <span class="hljs-title class_">Render</span>.<span class="hljs-title function_">run</span>(render);
</code></pre><div class="comment"><p>Створення рендерера і передача йому полотна p5.js.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> options = { <span class="hljs-attr">friction</span>: <span class="hljs-number">0.01</span>, <span class="hljs-attr">restitution</span>: <span class="hljs-number">0.75</span> };
  <span class="hljs-keyword">let</span> box = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, options);
</code></pre><div class="comment"><p>Створення прямокутного тіла із власними значеннями тертя і віддачі.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title class_">Body</span>.<span class="hljs-title function_">setVelocity</span>(box, <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));
  <span class="hljs-title class_">Body</span>.<span class="hljs-title function_">setAngularVelocity</span>(box, <span class="hljs-number">0.1</span>);
</code></pre><div class="comment"><p>Встановлення початкової швидкості для тіла.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, box);
</code></pre><div class="comment"><p>Додавання тіла до світу.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> ground = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(width / <span class="hljs-number">2</span>, height - <span class="hljs-number">5</span>,
                 width, <span class="hljs-number">10</span>, { <span class="hljs-attr">isStatic</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, ground);
</code></pre><div class="comment"><p>Створення статичного тіла грунту.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> runner = <span class="hljs-title class_">Matter</span>.<span class="hljs-property">Runner</span>.<span class="hljs-title function_">create</span>();
</code></pre><div class="comment"><p>Створення бігунця.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title class_">Matter</span>.<span class="hljs-property">Runner</span>.<span class="hljs-title function_">run</span>(runner, engine);
</code></pre><div class="comment"><p>Запуск рушія.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тут немає функції <code>draw()</code>, а всі змінні є локальними для <code>setup()</code>. Фактично я не використовую тут жодних можливостей p5.js (окрім додавання полотна на сторінку). Але саме цим я і збираюся зайнятися далі!</p>
<h2 id="matterjs-with-p5js"><a class="heading-link" href="#matterjs-with-p5js">Matter.js з p5.js</a></h2>
<p>Matter.js зберігає список усіх тіл, які існують у світі й, як ви щойно бачили, може малювати та анімувати їх за допомогою об’єктів <code>Render</code> і <code>Runner</code>. (Цей список тіл до речі зберігається в <code>engine.world.bodies</code>.) Однак зараз я хочу показати вам підхід зі збереження власного списку(ів) тіл Matter.js, щоб ви могли малювати їх за допомогою p5.js.</p>
<p>Так, цей підхід може додати надмірність і пожертвувати невеликою кількістю ефективності, але він з лишком компенсує це простотою використання і налаштування. За допомогою цієї методології ви зможете програмувати, як ви звикли в p5.js, відстежуючи потрібні тіла і малюючи їх відповідним чином. Розглянемо файлову структуру проєкту, показану на малюнку 6.3.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1113px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;679&#x27; width=&#x27;1113&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/3835249f1dd86ce9ab2baf8ede6a367a/f43df/06_libraries_4.webp 278w,./static/3835249f1dd86ce9ab2baf8ede6a367a/4a9bb/06_libraries_4.webp 557w,./static/3835249f1dd86ce9ab2baf8ede6a367a/9e546/06_libraries_4.webp 1113w" sizes="(min-width: 1113px) 1113px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1113px) 1113px, 100vw" decoding="async" loading="lazy" data-src="./static/3835249f1dd86ce9ab2baf8ede6a367a/8a85a/06_libraries_4.png" data-srcset="./static/3835249f1dd86ce9ab2baf8ede6a367a/4410a/06_libraries_4.png 278w,./static/3835249f1dd86ce9ab2baf8ede6a367a/58043/06_libraries_4.png 557w,./static/3835249f1dd86ce9ab2baf8ede6a367a/8a85a/06_libraries_4.png 1113w" alt="Малюнок 6.3: Файлова структура типового p5.js проєкту"/></picture><noscript><picture><source type="image/webp" srcSet="./static/3835249f1dd86ce9ab2baf8ede6a367a/f43df/06_libraries_4.webp 278w,./static/3835249f1dd86ce9ab2baf8ede6a367a/4a9bb/06_libraries_4.webp 557w,./static/3835249f1dd86ce9ab2baf8ede6a367a/9e546/06_libraries_4.webp 1113w" sizes="(min-width: 1113px) 1113px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1113px) 1113px, 100vw" decoding="async" loading="lazy" src="./static/3835249f1dd86ce9ab2baf8ede6a367a/8a85a/06_libraries_4.png" srcSet="./static/3835249f1dd86ce9ab2baf8ede6a367a/4410a/06_libraries_4.png 278w,./static/3835249f1dd86ce9ab2baf8ede6a367a/58043/06_libraries_4.png 557w,./static/3835249f1dd86ce9ab2baf8ede6a367a/8a85a/06_libraries_4.png 1113w" alt="Малюнок 6.3: Файлова структура типового p5.js проєкту"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.3: Файлова структура типового p5.js проєкту</figcaption>
</figure>
<p>Структурно проєкт виглядає як ще одна програма p5.js. Є основний файл <em>sketch.js</em>, а також <em>box.js</em>. У такому додатковому файлі я зазвичай оголошую клас, потрібний для програми — у цьому випадку клас <code>Box</code>, який описує прямокутне тіло:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = <span class="hljs-number">16</span>;
</code></pre><div class="comment"><p>Тіло має координати положення (x, y) і ширину.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rectMode</span>(<span class="hljs-variable constant_">CENTER</span>);
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
    <span class="hljs-title function_">square</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>);
</code></pre><div class="comment"><p>Тіло малюється як квадрат за допомоги функції square().</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер я напишу вміст файлу <em>sketch.js</em> який при клацанні мишки створюватиме новий об’єкт класу <code>Box</code> і зберігатиме всі об’єкти <code>Box</code> у масиві. (Це такий самий підхід, який я використовував у прикладах системи частинок із <a href="/particles#section-particles">Розділу 4</a>.)</p>
<div data-type="example">
  <h3 id="example-62-a-comfortable-and-cozy-p5js-sketch-that-needs-a-little-matterjs"><a class="heading-link" href="#example-62-a-comfortable-and-cozy-p5js-sketch-that-needs-a-little-matterjs">Приклад 6.2: Зручна і проста програма p5.js, яка потребує участі Matter.js</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_2_boxes_exercise"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/D26YvXr_S" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> boxes = [];
</code></pre><div class="comment"><p>Масив для зберігання всіх об’єктів Box.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">360</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (mouseIsPressed) {
    <span class="hljs-keyword">let</span> box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>(mouseX, mouseY);
    boxes.<span class="hljs-title function_">push</span>(box);
  }
</code></pre><div class="comment"><p>При клацанні мишки додаватиметься новий об’єкт Box.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> box <span class="hljs-keyword">of</span> boxes) {
    box.<span class="hljs-title function_">show</span>();
  }
</code></pre><div class="comment"><p>Відображення усіх об’єктів Box.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зараз ця програма малює на екрані фіксовані квадрати. Ось моє завдання: як мені намалювати тіла, на які впливатиме фізика (розрахована за допомогою Matter.js), щойно вони з’являються на екрані, при цьому мінімально змінюючи код?</p>
<p>Для досягнення цієї мети мені потрібно виконати три кроки.</p>
<h3 id="step-1-add-matterjs-to-the-p5js-sketch"><a class="heading-link" href="#step-1-add-matterjs-to-the-p5js-sketch">Крок 1: Додаємо Matter.js до програми p5.js</a></h3>
<p>Наразі у програмі не має посилання на Matter.js. Це явно потрібно змінити. На щастя, ця частина не дуже складна: я вже продемонстрував усі елементи, необхідні для створення світу Matter.js. (І не забудьте переконатися, що бібліотека імпортована в <em>index.html.</em>)</p>
<p>Спершу мені потрібн о додати посилання на необхідні класи Matter.js і створити у функції <code>setup()</code> об’єкт <code>Engine</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Engine</span>, <span class="hljs-title class_">Bodies</span>, <span class="hljs-title class_">Composite</span> } = <span class="hljs-title class_">Matter</span>;

</code></pre><div class="comment"><p>Посилання для Engine, Bodies і Composite.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> engine;
</code></pre><div class="comment"><p>Для рушія тепер використовується глобальна змінна!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  engine = <span class="hljs-title class_">Engine</span>.<span class="hljs-title function_">create</span>();
</code></pre><div class="comment"><p>Створення рушія.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Далі, у функції <code>draw()</code>, мені потрібно викликати один важливий метод з Matter.js — <code>Engine.update()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title class_">Engine</span>.<span class="hljs-title function_">update</span>(engine);
</code></pre><div class="comment"><p>Оновлення рушія з плином часу!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Метод <code>Engine.update()</code> рухає фізичний світ на один крок вперед у часі. Його виклик усередині функції <code>draw()</code> забезпечує оновлення фізики на кожному кадрі анімації. Цей механізм замінює вбудований об’єкт <code>Runner</code> з Matter.js, який я використовував у прикладі 6.1. Тепер роль бігунця виконує функція <code>draw()</code>!</p>
<p>Внутрішньо, коли викликається <code>Engine.update()</code>, Matter.js проходиться світом, переглядає всі його тіла і вирішує, що з ними робити. Звичайний виклик методу <code>Engine.update()</code> рухає світ уперед зі стандартними параметрами. Але, як і у випадку з <code>Render</code>, ці параметри можна налаштувати, як зазначено у <a href="https://brm.io/matter-js/docs/classes/Engine.html#method_update" target="_blank" rel="noopener">документації Matter.js</a>.</p>
<h3 id="step-2-link-every-box-object-with-a-matterjs-body"><a class="heading-link" href="#step-2-link-every-box-object-with-a-matterjs-body">Крок 2: Пов’яжемо кожен об’єкт Box із тілом Matter.js</a></h3>
<p>Я налаштував свій світ Matter.js і тепер мені потрібно зв’язати кожен об’єкт <code>Box</code> у моїй програмі p5.js із тілом у цьому світі. Оригінальний клас <code>Box</code> містить змінні для позиції та ширини. Тепер я хочу сказати: “Я відмовляюся від керування позицією цього об’єкта на користь Matter.js. Мені більше не потрібно відстежувати нічого, що пов’язано з положенням, швидкістю чи прискоренням. Натомість мені потрібно лише відстежувати існування тіла Matter.js і вірити, що фізичний рушій зробить решту”.</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = <span class="hljs-number">16</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>);
</code></pre><div class="comment"><p>Замість звичайних значень змінних, збережемо посилання на тіло.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
</code></pre><div class="comment"><p>Не забуваємо додати тіло до світу!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Мені більше не потрібні змінні <code>this.x</code> і <code>this.y</code> для відстеження позиції. Конструктор <code>Box</code> отримує початкові <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-координати, передає їх у <code>Bodies.rectangle()</code> для створення нового тіла Matter.js, а потім забуває про них. Як ви побачите, тіло саме стежитиме за своїм положенням. Технічно тіло також може відстежувати свої розміри, але оскільки Matter.js зберігає їх у вигляд і списку вершин, зручніше зберігати ширину квадрата у змінній <code>this.w</code> для використання її під час малювання тіла.</p>
<h3 id="step-3-draw-the-body"><a class="heading-link" href="#step-3-draw-the-body">Крок 3: Малюємо тіло об’єкта</a></h3>
<p>Майже готово. До того, як я додав у програму Matter.js, намалювати об’єкт <code>Box</code> було легко. Позиція об’єкта зберігалася у змінних <code>this.x</code> і <code>this.y</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">rectMode</span>(<span class="hljs-variable constant_">CENTER</span>);
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
    <span class="hljs-title function_">square</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>);
  }
</code></pre><div class="comment"><p>Малювання об’єкта за допомогою функції square().</p></div></div></div>
<p>Тепер, коли Matter.js керує положенням об’єкта, для малювання форми я вже не можу використовувати власні змінні <code>x</code> і <code>y</code>. Але не бійтеся! Об’єкт <code>Box</code> має посиланн я на пов’язане з ним тіло Matter.js і це тіло знає свою позицію. Мені потрібно лише ввічливо запитати тіло: “Вибачте, де ви розташовані?”:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Але просто знати положення тіла недостатньо. Поточне тіло — це квадрат, тому мені також потрібно знати і його кут оберту:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> angle = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">angle</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Отримавши позицію і кут, я можу намалювати об’єкт за допомогою вбудованих функцій p5.js: <code>translate()</code>, <code>rotate()</code> і <code>square()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>;
    <span class="hljs-keyword">let</span> angle = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">angle</span>;
</code></pre><div class="comment"><p>Нам потрібні положення і кут тіла.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rectMode</span>(<span class="hljs-variable constant_">CENTER</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">translate</span>(position.<span class="hljs-property">x</span>, position.<span class="hljs-property">y</span>);
    <span class="hljs-title function_">rotate</span>(angle);
</code></pre><div class="comment"><p>Використовуємо положення і кут, щоб перемістити та повернути квадрат.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">square</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Важливо зауважити, що якщо ви видаляєте об’єкти типу <code>Box</code> із масиву <code>boxes</code>, наприклад, коли вони виходять за межі полотна або завершують своє існування, як це було продемонстровано у <a href="/particles#section-particles">Розділі 4</a>, вам також потрібно явно видалити тіло, пов’язане з цим об’єктом <code>Box</code> зі світу Matter.js. Це можна зробити за допомогою методу <code>removeBody()</code> класу <code>Box</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">removeBody</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">remove</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
  }
</code></pre><div class="comment"><p>Ця функція видаляє тіло зі світу Matter.js.</p></div></div></div>
<p>У функції <code>draw()</code> вам потім потрібно перебрати масив у зворотному порядку, так само як у прикладах із системою частинок, і викликати як <code>removeBody()</code> так і <code>splice()</code>, щоб видалити об’єкт зі світу Matter.js і з вашого масиву <code>boxes</code>.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-62"><a class="heading-link" href="#exercise-62">Вправа 6.2</a></h3>
  <p>Розпочніть з коду прикладу 6.2 і, використовуючи методику описану у цьому розділі, додайте код для реалізації фізики Matter.js. Видаляйте тіла, які виходять за межі полотна. Результат має бути подібним до зображеного прикладу. Проявіть творчість у малюванні тіл!</p>
  <figure data-type="example">
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_2_boxes_solved"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/oIZSHFXXk" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption>Для додавання нових об’єктів затисніть і рухайте мишкою.</figcaption>
  </figure>
</div>
<h2 id="static-matterjs-bodies"><a class="heading-link" href="#static-matterjs-bodies">Статичні тіла Matter.js</a></h2>
<p>У прикладі, який я щойно створив, об’єкти <code>Box</code> з’являються у позиції курсора і падають вниз через вплив дефолтної гравітації. Що, якщо я хочу додати до світу нерухомі межі, які перекриватимуть шлях об’єктам <code>Box</code>? Matter.js дозволяє це легко зробити за допомогою властивості <code>isStatic</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = { <span class="hljs-attr">isStatic</span>: <span class="hljs-literal">true</span> };
<span class="hljs-keyword">let</span> boundary = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h, options);
</code></pre><div class="comment"><p>Створення фіксованого (статичного) тіла.</p></div></div></div>
<p>Я все ще створюю тіло за допомогою фабричного методу <code>Bodies.rectangle()</code>, але додана властивість <code>isStatic</code> гарантує, що тіло ніколи не буде рухатись. Я додам цей функціонал у програму на основі рішення вправи 6.2, створивши окремий клас <code>Boundary</code>, який пов’язує прямокутник p5.js зі статичним тілом Matter.js. Для різноманіття я також рандомізую розміри кожної квадратної коробки. (Перегляньте онлайн-код для ознайомлення зі змінами у класі <code>Box</code>.)</p>
<div data-type="example">
  <h3 id="example-63-falling-boxes-hitting-boundaries"><a class="heading-link" href="#example-63-falling-boxes-hitting-boundaries">Приклад 6.3: Коробки, що падають і стикаються з перешкодами</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_3_boxes_and_boundaries"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/WSoUy03ph" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boundary</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, w, h</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = w;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span> = h;
</code></pre><div class="comment"><p>Межа — це простий прямокутник з xy-координатами, шириною і висотою.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> options = { <span class="hljs-attr">isStatic</span>: <span class="hljs-literal">true</span> };
</code></pre><div class="comment"><p>Фіксація тіла через властивість isStatic зі значенням true!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span>, options);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">rectMode</span>(<span class="hljs-variable constant_">CENTER</span>);
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
    <span class="hljs-title function_">rect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span>);
</code></pre><div class="comment"><p>Оскільки тіло ніколи не рухатиметься, метод show()
може намалювати його стандартним способом, використовуючи
оригінальні змінні без отримання їх у Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Статичні тіла не включають властивостей матеріалу таких як <code>restitution</code> або <code>friction</code>. Переконайтеся, що ви встановили їх для динамічних тіл вашого світу.</p>
<h2 id="polygons-and-groups-of-shapes"><a class="heading-link" href="#polygons-and-groups-of-shapes">Багатокутники та групи фігур</a></h2>
<p>Тепер, коли я продемонстрував, наскільки легко з Matter.js використову вати примітивну форму, таку як прямокутник або круг, уявімо, що ви хочете використати цікавіше тіло, наприклад абстрактну фігуру як на малюнку 6.4.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;484&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/c5454d110953f31a394391813b390e5e/91b25/06_libraries_5.webp 576w,./static/c5454d110953f31a394391813b390e5e/a088c/06_libraries_5.webp 1152w,./static/c5454d110953f31a394391813b390e5e/d94c5/06_libraries_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/c5454d110953f31a394391813b390e5e/520d5/06_libraries_5.png" data-srcset="./static/c5454d110953f31a394391813b390e5e/c3555/06_libraries_5.png 576w,./static/c5454d110953f31a394391813b390e5e/a25ca/06_libraries_5.png 1152w,./static/c5454d110953f31a394391813b390e5e/520d5/06_libraries_5.png 2304w" alt="Малюнок 6.4: Складне тіло, складене з декількох форм"/></picture><noscript><picture><source type="image/webp" srcSet="./static/c5454d110953f31a394391813b390e5e/91b25/06_libraries_5.webp 576w,./static/c5454d110953f31a394391813b390e5e/a088c/06_libraries_5.webp 1152w,./static/c5454d110953f31a394391813b390e5e/d94c5/06_libraries_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/c5454d110953f31a394391813b390e5e/520d5/06_libraries_5.png" srcSet="./static/c5454d110953f31a394391813b390e5e/c3555/06_libraries_5.png 576w,./static/c5454d110953f31a394391813b390e5e/a25ca/06_libraries_5.png 1152w,./static/c5454d110953f31a394391813b390e5e/520d5/06_libraries_5.png 2304w" alt="Малюнок 6.4: Складне тіло, складене з декількох форм"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.4: Складне тіло, складене з декількох форм</figcaption>
</figure>
<p>Для створення таких складних форм можна використати дві стратегії. Загальний метод <code>Bodies.polygon()</code> може створити будь-який правильний багатокутник (п’ятикутник, шестикутник тощо). Також є метод <code>Bodies.trapezoid()</code> для створення трапеції — чотирикутника у якого одна пара сторін паралельна:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> hexagon = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">polygon</span>(x, y, <span class="hljs-number">6</span>, radius);
</code></pre><div class="comment"><p>Гексагон (рівносторонній шестикутник).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> trapezoid = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">trapezoid</span>(x, y, width, height, slope);
</code></pre><div class="comment"><p>Трапеція.</p></div></div></div>
<p>Більш універсальним методом є <code>Bodies.fromVertices()</code>. Він будує фігуру з масиву векторів, розглядаючи їх як послідовність з’єднаних вершин. Я інкапсулюю цю логіку у класі <code>CustomShape</code>.</p>
<div data-type="example">
  <h3 id="example-64-polygon-shapes"><a class="heading-link" href="#example-64-polygon-shapes">Приклад 6.4: Багатокутні фігури</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_4_polygon_shapes"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/o3-Qpqu2i" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomShape</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> vertices = [];
    vertices[<span class="hljs-number">0</span>] = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(-<span class="hljs-number">10</span>, -<span class="hljs-number">10</span>);
    vertices[<span class="hljs-number">1</span>] = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">20</span>, -<span class="hljs-number">15</span>);
    vertices[<span class="hljs-number">2</span>] = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>);
    vertices[<span class="hljs-number">3</span>] = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
    vertices[<span class="hljs-number">4</span>] = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(-<span class="hljs-number">20</span>, <span class="hljs-number">15</span>);
</code></pre><div class="comment"><p>Масив із 5 векторів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> options = { <span class="hljs-attr">restitution</span>: <span class="hljs-number">1</span> };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">fromVertices</span>(x, y, vertices, options);
</code></pre><div class="comment"><p>Створення тіла за допомогою вершин фігури.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Body</span>.<span class="hljs-title function_">setVelocity</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>, <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title function_">random</span>(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>));
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Body</span>.<span class="hljs-title function_">setAngularVelocity</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>, <span class="hljs-number">0.1</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Створюючи власний багатокутник у Matter.js, ви повинні пам’ятати про два важливих моменти. По-перше, вершини повинні бути вказані в годинниковому порядку. Наприклад, на малюнку 6.5 показано п’ять вершин, використаних для створення тіл у прикладі 6.4. Зверніть увагу, що у коді прикладу вони додані до масиву <code>vertices</code> у годинниковому напрямку, починаючи з верхнього лівого кута.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1623&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/cc0dfdf2934354c216e41668aa61f1ea/dc6ce/06_libraries_6.webp 576w,./static/cc0dfdf2934354c216e41668aa61f1ea/9f68a/06_libraries_6.webp 1152w,./static/cc0dfdf2934354c216e41668aa61f1ea/0f46f/06_libraries_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/cc0dfdf2934354c216e41668aa61f1ea/d957d/06_libraries_6.png" data-srcset="./static/cc0dfdf2934354c216e41668aa61f1ea/da30f/06_libraries_6.png 576w,./static/cc0dfdf2934354c216e41668aa61f1ea/47042/06_libraries_6.png 1152w,./static/cc0dfdf2934354c216e41668aa61f1ea/d957d/06_libraries_6.png 2304w" alt="Малюнок 6.5: Вершини багатокутника, спрямовані за годинниковою стрілкою"/></picture><noscript><picture><source type="image/webp" srcSet="./static/cc0dfdf2934354c216e41668aa61f1ea/dc6ce/06_libraries_6.webp 576w,./static/cc0dfdf2934354c216e41668aa61f1ea/9f68a/06_libraries_6.webp 1152w,./static/cc0dfdf2934354c216e41668aa61f1ea/0f46f/06_libraries_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/cc0dfdf2934354c216e41668aa61f1ea/d957d/06_libraries_6.png" srcSet="./static/cc0dfdf2934354c216e41668aa61f1ea/da30f/06_libraries_6.png 576w,./static/cc0dfdf2934354c216e41668aa61f1ea/47042/06_libraries_6.png 1152w,./static/cc0dfdf2934354c216e41668aa61f1ea/d957d/06_libraries_6.png 2304w" alt="Малюнок 6.5: Вершини багатокутника, спрямовані за годинниковою стрілкою"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.5: Вершини багатокутника, спрямовані за годинниковою стрілкою</figcaption>
</figure>
<p>По-друге, кожна форма повинна бути опуклою, а не увігнутою. Як показано на малюнку 6.6, <strong>увігнута</strong> форма має поверхню, що вигинається всередину, тоді як в <strong>опуклої</strong> це інакше. Кожен внутрішній кут в опуклій формі не перевищує 180 градусів. Насправді Matter.js може працювати з увігнутими формами, але вам потрібно скласти їх із кількох опуклих форм і скоро я покажу це на практиці.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2305px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;731&#x27; width=&#x27;2305&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/a665c13e3d4b69e64a1e7b16e5352d25/a6b47/06_libraries_7.webp 576w,./static/a665c13e3d4b69e64a1e7b16e5352d25/9b542/06_libraries_7.webp 1153w,./static/a665c13e3d4b69e64a1e7b16e5352d25/dab04/06_libraries_7.webp 2305w" sizes="(min-width: 2305px) 2305px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2305px) 2305px, 100vw" decoding="async" loading="lazy" data-src="./static/a665c13e3d4b69e64a1e7b16e5352d25/70364/06_libraries_7.png" data-srcset="./static/a665c13e3d4b69e64a1e7b16e5352d25/07e31/06_libraries_7.png 576w,./static/a665c13e3d4b69e64a1e7b16e5352d25/63e02/06_libraries_7.png 1153w,./static/a665c13e3d4b69e64a1e7b16e5352d25/70364/06_libraries_7.png 2305w" alt="Малюнок 6.6: Увігнуту фігуру можна намалювати кількома опуклими фігурам"/></picture><noscript><picture><source type="image/webp" srcSet="./static/a665c13e3d4b69e64a1e7b16e5352d25/a6b47/06_libraries_7.webp 576w,./static/a665c13e3d4b69e64a1e7b16e5352d25/9b542/06_libraries_7.webp 1153w,./static/a665c13e3d4b69e64a1e7b16e5352d25/dab04/06_libraries_7.webp 2305w" sizes="(min-width: 2305px) 2305px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2305px) 2305px, 100vw" decoding="async" loading="lazy" src="./static/a665c13e3d4b69e64a1e7b16e5352d25/70364/06_libraries_7.png" srcSet="./static/a665c13e3d4b69e64a1e7b16e5352d25/07e31/06_libraries_7.png 576w,./static/a665c13e3d4b69e64a1e7b16e5352d25/63e02/06_libraries_7.png 1153w,./static/a665c13e3d4b69e64a1e7b16e5352d25/70364/06_libraries_7.png 2305w" alt="Малюнок 6.6: Увігнуту фігуру можна намалювати кількома опуклими фігурам"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.6: Увігнуту фігуру можна намалювати, об’єднавши кілька опуклих фігур</figcaption>
</figure>
<p>Оскільки форма побудована з довільних вершин для малювання відповідного тіла ви зможете використовувати p5.js-функції <code>beginShape()</code>, <code>endShape()</code> і <code>vertex()</code>. Для цілей малювання клас <code>CustomShape</code> може містити масив для зберігання піксельних позицій вершин відносно до початкової точки <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>. Однак краще дізнав атися позиції вершин через Matter.js. Таким чином не потрібно використовувати функції  <code>translate()</code> чи <code>rotate()</code>, оскільки тіло Matter.js зберігає свої вершини як абсолютні позиції світу:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">beginShape</span>();
</code></pre><div class="comment"><p>Початок малювання фігури.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">vertices</span>) {
      <span class="hljs-title function_">vertex</span>(v.<span class="hljs-property">x</span>, v.<span class="hljs-property">y</span>);
    }
</code></pre><div class="comment"><p>Перебір усіх вершини тіла.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">endShape</span>(<span class="hljs-variable constant_">CLOSE</span>);
</code></pre><div class="comment"><p>Завершення фігури із замиканням форми.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Тіло Matter.js зберігає масив позицій вершин у властивості <code>vertices</code>. Зверніть увагу, що я можу використовувати цикл <code>for...of</code> для проходження вершин між функціями <code>beginShape()</code> і <code>endShape()</code>.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-63"><a class="heading-link" href="#exercise-63">Вправа 6.3</a></h3>
  <p>Використовуючи метод <code>Bodies.fromVertices()</code>, створіть власну форму багатокутника (пам’ятайте, що він має бути опуклим). Деякі можливі варіанти показані нижче.</p>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;721&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/266f0f7ab5a973280bf80dfa405ea62f/cb0f9/06_libraries_8.webp 576w,./static/266f0f7ab5a973280bf80dfa405ea62f/ed520/06_libraries_8.webp 1152w,./static/266f0f7ab5a973280bf80dfa405ea62f/b7c09/06_libraries_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/266f0f7ab5a973280bf80dfa405ea62f/04b85/06_libraries_8.png" data-srcset="./static/266f0f7ab5a973280bf80dfa405ea62f/e1fc0/06_libraries_8.png 576w,./static/266f0f7ab5a973280bf80dfa405ea62f/ff049/06_libraries_8.png 1152w,./static/266f0f7ab5a973280bf80dfa405ea62f/04b85/06_libraries_8.png 2304w" alt=" "/></picture><noscript><picture><source type="image/webp" srcSet="./static/266f0f7ab5a973280bf80dfa405ea62f/cb0f9/06_libraries_8.webp 576w,./static/266f0f7ab5a973280bf80dfa405ea62f/ed520/06_libraries_8.webp 1152w,./static/266f0f7ab5a973280bf80dfa405ea62f/b7c09/06_libraries_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/266f0f7ab5a973280bf80dfa405ea62f/04b85/06_libraries_8.png" srcSet="./static/266f0f7ab5a973280bf80dfa405ea62f/e1fc0/06_libraries_8.png 576w,./static/266f0f7ab5a973280bf80dfa405ea62f/ff049/06_libraries_8.png 1152w,./static/266f0f7ab5a973280bf80dfa405ea62f/04b85/06_libraries_8.png 2304w" alt=" "/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption> </figcaption>
  </figure>
</div>
<p>Власна форма, побудована з масиву вершин, дозволить вам зробити багато чого. Однак вимога щодо опуклої форми обмежує діапазон можливостей. Хороша новина в тому, що ви можете усунути це обмеження, створивши <strong>складене тіло</strong>, що збирається з кількох форм! Як щодо створення форми смачного льодяника з тонкого прямокутника і круга на його верхньому кінці?</p>
<p>Я почну зі створення двох окремих тіл: прямокутника і круга. Потім я можу об’єднати їх, помістивши у масив <code>parts</code> і передавши його до методу <code>Body.create()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> part1 = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h);
<span class="hljs-keyword">let</span> part2 = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, r);
</code></pre><div class="comment"><p>Створення тіл.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> body = <span class="hljs-title class_">Body</span>.<span class="hljs-title function_">create</span>({ <span class="hljs-attr">parts</span>: [part1, part2] });
</code></pre><div class="comment"><p>Об’єднання двох тіл у масиві.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, body);
</code></pre><div class="comment"><p>Додавання складеного тіла до об’єкту світу.</p></div></div></div>
<p>Хоча це і створює складене тіло через поєднання двох форм, код не зовсім правильний. Якщо ви запустите його, то побачите, що обидві фігури відцентровані на одній і тій самій позиції <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span></span></span></span></span>, як показано на малюнку 6.7.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;464&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/e393d1bb396343f191f68ccf9257a6fb/4a129/06_libraries_9.webp 576w,./static/e393d1bb396343f191f68ccf9257a6fb/ef188/06_libraries_9.webp 1152w,./static/e393d1bb396343f191f68ccf9257a6fb/7858c/06_libraries_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/e393d1bb396343f191f68ccf9257a6fb/84196/06_libraries_9.png" data-srcset="./static/e393d1bb396343f191f68ccf9257a6fb/72481/06_libraries_9.png 576w,./static/e393d1bb396343f191f68ccf9257a6fb/6e70c/06_libraries_9.png 1152w,./static/e393d1bb396343f191f68ccf9257a6fb/84196/06_libraries_9.png 2304w" alt="Малюнок 6.7: Прямокутник і круг з однаковою опорною точкою (x, y)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/e393d1bb396343f191f68ccf9257a6fb/4a129/06_libraries_9.webp 576w,./static/e393d1bb396343f191f68ccf9257a6fb/ef188/06_libraries_9.webp 1152w,./static/e393d1bb396343f191f68ccf9257a6fb/7858c/06_libraries_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/e393d1bb396343f191f68ccf9257a6fb/84196/06_libraries_9.png" srcSet="./static/e393d1bb396343f191f68ccf9257a6fb/72481/06_libraries_9.png 576w,./static/e393d1bb396343f191f68ccf9257a6fb/6e70c/06_libraries_9.png 1152w,./static/e393d1bb396343f191f68ccf9257a6fb/84196/06_libraries_9.png 2304w" alt="Малюнок 6.7: Прямокутник і круг з однаковою опорною точкою (x, y)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.7: Прямокутник і круг з однаковою опорною точкою <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span></span></span></span></span></figcaption>
</figure>
<p>Натомість мені потрібно змістити центр кола по горизонталі відносно центру прямокутника, як на малюнку 6.8.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;587&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/cf52a857a97e998863a54c7a5afc0d47/564c4/06_libraries_10.webp 576w,./static/cf52a857a97e998863a54c7a5afc0d47/ba170/06_libraries_10.webp 1152w,./static/cf52a857a97e998863a54c7a5afc0d47/8442e/06_libraries_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/cf52a857a97e998863a54c7a5afc0d47/2da9a/06_libraries_10.png" data-srcset="./static/cf52a857a97e998863a54c7a5afc0d47/294b0/06_libraries_10.png 576w,./static/cf52a857a97e998863a54c7a5afc0d47/45e57/06_libraries_10.png 1152w,./static/cf52a857a97e998863a54c7a5afc0d47/2da9a/06_libraries_10.png 2304w" alt="Малюнок 6.8: Круг, розміщений відносно прямокутника з горизонтальним зміщенням"/></picture><noscript><picture><source type="image/webp" srcSet="./static/cf52a857a97e998863a54c7a5afc0d47/564c4/06_libraries_10.webp 576w,./static/cf52a857a97e998863a54c7a5afc0d47/ba170/06_libraries_10.webp 1152w,./static/cf52a857a97e998863a54c7a5afc0d47/8442e/06_libraries_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/cf52a857a97e998863a54c7a5afc0d47/2da9a/06_libraries_10.png" srcSet="./static/cf52a857a97e998863a54c7a5afc0d47/294b0/06_libraries_10.png 576w,./static/cf52a857a97e998863a54c7a5afc0d47/45e57/06_libraries_10.png 1152w,./static/cf52a857a97e998863a54c7a5afc0d47/2da9a/06_libraries_10.png 2304w" alt="Малюнок 6.8: Круг, розміщений відносно прямокутника з горизонтальним зміщенням"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.8: Круг, розміщений відносно прямокутника з горизонтальним зміщенням</figcaption>
</figure>
<p>Для значення зсуву я використаю половину ширини прямокутника, щоб круг був вирівняний з краєм прямокутника:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> part1 = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> offset = w / <span class="hljs-number">2</span>;
<span class="hljs-keyword">let</span> part2 = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x + offset, y, r);
</code></pre><div class="comment"><p>Додавання зміщення від x-позиції палички льодяника.</p></div></div></div>
<p>Оскільки тіло льодяника складається з двох частин, його малювання трохи складніше. Я можу використати кілька варіантів. Наприклад, я  міг би використати масив вершин тіла <code>vertices</code> і намалювати льодяник як індивідуальну форму, подібно до прикладу 6.4. (Кожне тіло зберігає масив вершин, навіть якщо воно не створювалося методом <code>fromVertices()</code>. Але оскільки кожна частина льодяника є примітивною формою, я віддам перевагу окремому малюванню кожної частини через відносне переміщення їх у потрібне положення під потрібним кутом тіла.</p>
<div data-type="example">
  <h3 id="example-65-multiple-shapes-on-one-body"><a class="heading-link" href="#example-65-multiple-shapes-on-one-body">Приклад 6.5: Кілька фігур в одному тілі</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_5_compound_bodies"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/xxYF4I5bi" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> angle = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">angle</span>;
</code></pre><div class="comment"><p>Кут береться від складеного тіла.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> position1 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">part1</span>.<span class="hljs-property">position</span>;
    <span class="hljs-keyword">let</span> position2 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">part2</span>.<span class="hljs-property">position</span>;
</code></pre><div class="comment"><p>Отримання позиції для кожної частини.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">200</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
    <span class="hljs-title function_">translate</span>(position1.<span class="hljs-property">x</span>, position1.<span class="hljs-property">y</span>);
    <span class="hljs-title function_">rotate</span>(angle);
    <span class="hljs-title function_">rectMode</span>(<span class="hljs-variable constant_">CENTER</span>);
    <span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span>);
    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p>Переміщення і оберт прямокутника (перша частина тіла).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
    <span class="hljs-title function_">translate</span>(position2.<span class="hljs-property">x</span>, position2.<span class="hljs-property">y</span>);
    <span class="hljs-title function_">rotate</span>(angle);
    <span class="hljs-title function_">circle</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p>Переміщення і оберт круга (друга частина тіла).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Перш ніж рухатися далі, я хочу наголосити про дещо: елементи які ви малюєте на полотні не набувають магічним чином потрібної візуальної взаємодії бажаної фізики лише завдяки акту створення тіл Matter.js. Приклади цього розділу працювали, оскільки я ретельно зіставляв відповідність між тим, як малюється кожна фігура p5.js із тим, як визначено геометрію кожного тіла Matter.js. Якщо ви випадково намалюєте фігуру інакше, то не отримаєте повідомлення про помилку — ні від p5.js, ні від Matter.js. Однак ваша програма виглядатиме дивно і фізика працюватиме неправильно, оскільки світ, який ви будете бачити не відповідатиме світу, яким розуміє його Matter.js.</p>
<p>Щоб проілюструвати це, дозвольте мені повернутися до прикладу 6.5. Льодяник — складне тіло, що складається з двох частин — прямокутника (<code>this.part1</code>) і круга (<code>this.part2</code>). Я малюю кожен льодяник, отримуючи позиції для двох частин окремо: <code>this.part1.position</code> і <code>this.part2.position</code>. Однак загальне складене тіло також має позицію — <code>this.body.position</code>. Було б спокусливо використати його як положення для малювання прямокутника, а положення кола визначити вручну, використавши зміщення. Зрештою, саме так я уявляв складену форму спочатку (подивіться на малюнок 6.8):</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>;
</code></pre><div class="comment"><p>Отримання положення сукупного тіла.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> angle = <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">angle</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">translate</span>(position.<span class="hljs-property">x</span>, position.<span class="hljs-property">y</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rotate</span>(angle);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Малюнок 6.9 показує результат цієї зміни.</p>
<figure data-type="example">
  <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_5_compound_bodies_error"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/HWeBLcNuu" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
  <figcaption>Малюнок 6.9 Що станеться, якщо фігури намальовані не так, як вони налаштовані для Matter.js</figcaption>
</figure>
<p>На перший погляд, ця нова версія може виглядати нормально, але якщо придивитися уважніше, то немає правильних зіткнень і фігури накладаються дивним чином. Це не тому, що фізика порушена, а тому, що я неналежним чином поєднав відповідність між p5.js і Matter.js. Виявляється, що загальне положення тіла — це не центр прямокутника, а скоріше “центр маси” між прямокутником і колом. Matter.js обчислює фізику і керує зіткненнями, як і раніше, але я малюю кожне тіло не там, де потрібно! (В онлайн-версії ви можете перемикати правильний і неправильний рендеринг, клацаючи мишкою.)</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-64"><a class="heading-link" href="#exercise-64">Вправа 6.4</a></h3>
  <p>Створіть власного маленького інопланетянина, використовуючи кілька фігур, прикріплених до одного тіла. Пам’ятайте, що ви не обмежені використанням лише базових функцій малювання фігур у p5.js, а можете використовувати зображення і кольори, малювати волосся за допомогою ліній тощо. Думайте про форми Matter.js як про кістяки для вашого оригінального фантастичного дизайну!</p>
</div>
<h2 id="matterjs-constraints"><a class="heading-link" href="#matterjs-constraints">Обмежувачі Matter.js</a></h2>
<p><strong>Обмежувачі</strong> (обмеження) Matter.js — це механізм з’єднання одного тіла з іншим, що дозволяє моделювати коливальні маятники, пружні мости, м’які поверхні, об’єкти, які обертаються навколо вісі тощо. Існує три типи обмежувачів: обмежувач відстані й обмежувач обертання, які керуються класом <code>Constraint</code>, та обмежувач мишки, керований класом <code>MouseConstraint</code>.</p>
<h3 id="distance-constraints"><a class="heading-link" href="#distance-constraints"><strong>Обмежувач відстані</strong></a></h3>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1045&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/48167e3561fde027b58ec7b67dfc6734/9057b/06_libraries_11.webp 288w,./static/48167e3561fde027b58ec7b67dfc6734/4bcea/06_libraries_11.webp 576w,./static/48167e3561fde027b58ec7b67dfc6734/aa94e/06_libraries_11.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/48167e3561fde027b58ec7b67dfc6734/85afc/06_libraries_11.png" data-srcset="./static/48167e3561fde027b58ec7b67dfc6734/823a2/06_libraries_11.png 288w,./static/48167e3561fde027b58ec7b67dfc6734/91cfe/06_libraries_11.png 576w,./static/48167e3561fde027b58ec7b67dfc6734/85afc/06_libraries_11.png 1152w" alt="Малюнок 6.10: Обмежувач — це з’єднання між двома тілами у якірній точці для кожного тіла"/></picture><noscript><picture><source type="image/webp" srcSet="./static/48167e3561fde027b58ec7b67dfc6734/9057b/06_libraries_11.webp 288w,./static/48167e3561fde027b58ec7b67dfc6734/4bcea/06_libraries_11.webp 576w,./static/48167e3561fde027b58ec7b67dfc6734/aa94e/06_libraries_11.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/48167e3561fde027b58ec7b67dfc6734/85afc/06_libraries_11.png" srcSet="./static/48167e3561fde027b58ec7b67dfc6734/823a2/06_libraries_11.png 288w,./static/48167e3561fde027b58ec7b67dfc6734/91cfe/06_libraries_11.png 576w,./static/48167e3561fde027b58ec7b67dfc6734/85afc/06_libraries_11.png 1152w" alt="Малюнок 6.10: Обмежувач — це з’єднання між двома тілами у якірній точці для кожного тіла"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 6.10: Обмежувач — це з’єднання між двома тілами у певних точках обох тіл</figcaption>
  </figure>
</div>
<p><strong>Обмежувач відстані</strong> — це зв’язок фіксованої довжини між двома тілами, подібно до того, як сила пружини з’єднує дві фігури у <a href="/oscillation#section-oscillation">Розділі 3</a>. Обмеження прикріплюється до кожного тіла у певній <strong>якірній</strong> точці відносно центру тіла (див. малюнок 6.10). Залежно від жорсткості обмеження, “фіксована” довжина може змінюватися, подібно до того, як пружина може бути більш або менш жорсткою.</p>
<p>Додавання обмеження використовує подібний підхід, що і створення тіл, але тут необхідно вже мати готові тіла, які потрібно обмежити. Припустимо, що є два об’єкти <code>Particle</code>, кожен з яких зберігає посилання на тіло Matter.js у властивості під назвою <code>body</code>. Я назву їх <code>particleA</code> і <code>particleB</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particleA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particleB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>();
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я хочу створити обмеження між цими частинками. Для цього мені потрібно визначити ряд параметрів, які обумовлюють поведінку обмеження:</p>
<ul>
  <li><code>bodyA</code>: перше тіло, з яким з’єднується обмеження, формуючи один кінець обмеження.</li>
  <li><code>bodyB</code>: друге тіло, з яким з’єднується обмеження, утворюючи інший кінець.</li>
  <li><code>pointA</code>: позиція відносно <code>bodyA</code>, де обмеження прикріплюється до першого тіла.</li>
  <li><code>pointB</code>: позиція відносно <code>bodyB</code>, де обмеження прикріплюється до другого тіла.</li>
  <li><code>length</code>: цільова довжина обмеження або довжина у спокої. Під час симуляції обмеження намагатиметься підтримувати цю довжину.</li>
  <li><code>stiffness</code>: значення від 0 до 1, яке представляє жорсткість обмеження, де 1 означає повністю жорстке обмеження, а 0 — абсолютно м’яке.</li>
</ul>
<p>Усі ці налаштування упаковуються у літерал об’єкта:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">bodyA</span>: particleA.<span class="hljs-property">body</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">bodyB</span>: particleB.<span class="hljs-property">body</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">pointA</span>: <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">pointB</span>: <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">length</span>: <span class="hljs-number">100</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">stiffness</span>: <span class="hljs-number">0.5</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Технічно обов’язковими параметрами є тільки <code>bodyA</code> і <code>bodyB</code>, два тіла, з’єднані обмеженням. Якщо ви не вкажете ніякі інші параметри, Matter.js вибере для них значення за замовчуванням. Наприклад, для кожної відносної точки кріплення (центр тіла) він встановить <code>(0, 0)</code>, для <code>length</code> встановить значення поточної відстані між тілами, а для <code>stiffness</code> використає значення <code>0.7</code>. Ще два важливих параметри, які я не налаштував — це <code>damping</code> і <code>angularStiffness</code>. Опція <code>damping</code> впливає на опір обмеження руху, де вищі значення призводять обмеження до швидшої втрати енергії. Опція <code>angularStiffness</code> контролює жорсткість обмеження кутового руху, де вищі значення призводять до меншої кутової гнучкості між тілами.</p>
<p>Після налаштування параметрів можна створити саме обмеження. Як зазвичай, це передбачає створення нового скорочення де змінна <code>Constraint</code> посилається на <code>Matter.Constraint</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> constraint = <span class="hljs-title class_">Constraint</span>.<span class="hljs-title function_">create</span>(options);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, constraint);
</code></pre><div class="comment"><p>Не забуваємо додати обмеження до світу!</p></div></div></div>
<p>Я можу включити обмеження до класу для інкапсуляції та керування взаємозв’язком між кількома тілами. Ось приклад класу, який представляє маятник (подібний до прикладу 3.11 з <a href="/oscillation#section-oscillation">Розділу 3</a>).</p>
<div data-type="example">
  <h3 id="example-66-matterjs-pendulum"><a class="heading-link" href="#example-66-matterjs-pendulum">Приклад 6.6: Маятник Matter.js</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_6_matter_js_pendulum"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/YT6u0GqtH" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pendulum</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, len</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">12</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">len</span> = len;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, { <span class="hljs-attr">isStatic</span>: <span class="hljs-literal">true</span> });
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x + len, y, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, { <span class="hljs-attr">restitution</span>: <span class="hljs-number">0.6</span> });
</code></pre><div class="comment"><p>Створення двох тіл: одного для якоря (точки опори) та іншого для підвісу.
Якір буде статичним.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> options = {
      <span class="hljs-attr">bodyA</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>,
      <span class="hljs-attr">bodyB</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>,
      <span class="hljs-attr">length</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">len</span>,
    };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">arm</span> = <span class="hljs-title class_">Constraint</span>.<span class="hljs-title function_">create</span>(options);
</code></pre><div class="comment"><p>Створення обмеження, що з’єднує якір і підвіс.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>);
    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>);
    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">arm</span>);
</code></pre><div class="comment"><p>Додавання до світу обох тіл та обмеження.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">line</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>);
</code></pre><div class="comment"><p>Малювання лінії, що представляє плече маятника.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
    <span class="hljs-title function_">translate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>);
    <span class="hljs-title function_">rotate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">anchor</span>.<span class="hljs-property">angle</span>);
    <span class="hljs-title function_">circle</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
    <span class="hljs-title function_">line</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, <span class="hljs-number">0</span>);
    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p>Малювання опорної точки (якоря).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
    <span class="hljs-title function_">translate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>);
    <span class="hljs-title function_">rotate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bob</span>.<span class="hljs-property">angle</span>);
    <span class="hljs-title function_">circle</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
    <span class="hljs-title function_">line</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, <span class="hljs-number">0</span>);
    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p>Малювання підвісу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У прикладі 6.6 для параметру <code>stiffness</code> використовується значення за замовчуванням <code>0.7</code>. Якщо ви спробуєте знизити значення, маятник буде схожим на м’яку пружину.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-65"><a class="heading-link" href="#exercise-65">Вправа 6.5</a></h3>
  <p>Створіть симуляцію мосту, використовуючи обмеження відстані для з’єднання послідовності кругів (або прямокутників), як показано нижче. Для закріплення крайніх точок використовуйте властивість <code>isStatic</code>. Поекспериментуйте з різними значеннями, щоб зробити міст більш або менш пружним. Зауважте, що з’єднання не мають фізичної геометрії тому, щоб у вашого моста не було отворів або щоб отвори були не дуже великими, налаштування відстані між вузлами є важливим моментом.</p>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/exercise_6_5_bridge"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/7U7yrrbNz" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<h3 id="revolute-constraints"><a class="heading-link" href="#revolute-constraints">Обмежувач обертання</a></h3>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1152px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1000.0000000000001&#x27; width=&#x27;1152&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/e26285307ea1189037aa696a4d4acbd4/cf613/06_libraries_12.webp 288w,./static/e26285307ea1189037aa696a4d4acbd4/89823/06_libraries_12.webp 576w,./static/e26285307ea1189037aa696a4d4acbd4/4039d/06_libraries_12.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" data-src="./static/e26285307ea1189037aa696a4d4acbd4/a4fb2/06_libraries_12.png" data-srcset="./static/e26285307ea1189037aa696a4d4acbd4/c4179/06_libraries_12.png 288w,./static/e26285307ea1189037aa696a4d4acbd4/0a7a4/06_libraries_12.png 576w,./static/e26285307ea1189037aa696a4d4acbd4/a4fb2/06_libraries_12.png 1152w" alt="Малюнок 6.11: Обмеження обертання — це з’єднання між двома тілами в одній опорній точці або шарнірі"/></picture><noscript><picture><source type="image/webp" srcSet="./static/e26285307ea1189037aa696a4d4acbd4/cf613/06_libraries_12.webp 288w,./static/e26285307ea1189037aa696a4d4acbd4/89823/06_libraries_12.webp 576w,./static/e26285307ea1189037aa696a4d4acbd4/4039d/06_libraries_12.webp 1152w" sizes="(min-width: 1152px) 1152px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1152px) 1152px, 100vw" decoding="async" loading="lazy" src="./static/e26285307ea1189037aa696a4d4acbd4/a4fb2/06_libraries_12.png" srcSet="./static/e26285307ea1189037aa696a4d4acbd4/c4179/06_libraries_12.png 288w,./static/e26285307ea1189037aa696a4d4acbd4/0a7a4/06_libraries_12.png 576w,./static/e26285307ea1189037aa696a4d4acbd4/a4fb2/06_libraries_12.png 1152w" alt="Малюнок 6.11: Обмеження обертання — це з’єднання між двома тілами в одній опорній точці або шарнірі"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 6.11: Обмеження обертання — це з’єднання між двома тілами в одній опорній точці або шарнірі</figcaption>
  </figure>
</div>
<p>Інший поширений у фізичних рушіях вид зв’язку між тілами називається <strong>обертальним або шарнірним з’єднанням</strong>. Цей тип обмеження з’єднує два тіла у спільній опорній точці, яку також називають <strong>шарніром</strong> (див. малюнок 6.11). Хоча в Matter.js немає окремого обмежувача для обертання, ви можете створити його за допомогою звичайного <code>Constraint</code> з довжиною рівною нулю. Таким чином тіла можуть обертатися навколо спільної опорної точки.</p>
<p>Першим кроком є створення з’єднаних тіл. Для першого прикладу я хочу створити обертовий прямокутник (схожий на пропелер або вітряк) у фіксованому положенні. Для цього випадку мені потрібне лише одне тіло, з’єднане з точкою. Це спрощує речі, оскільки мені не потрібно турбуватися про зіткнення між двома тілами, з’єднаними шарніром:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> body = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h);
<span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, body);
</code></pre><div class="comment"><p>Створення тіла з наданими координатами, шириною і висотою.</p></div></div></div>
<p>Далі я можу створити потрібне обмеження. Властивість <code>length</code> буде дорівнювати <code>0</code>, а для властивості <code>stiffness</code> потрібно встановити значення <code>1</code>, інакше обмеження може бути недостатньо стабільним, щоб утримати тіло з’єднаним у точці прив’язки (якоря):</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">bodyA</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>,
  <span class="hljs-attr">pointB</span>: { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y },
  <span class="hljs-attr">length</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">stiffness</span>: <span class="hljs-number">1</span>,
};
</code></pre><div class="comment"><p>Обмеження з’єднує тіло з фіксованою xy-позицією, з довжиною рівною 0 і жорсткістю рівною 1.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> constraint = <span class="hljs-title class_">Matter</span>.<span class="hljs-property">Constraint</span>.<span class="hljs-title function_">create</span>(options);
<span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, constraint);
</code></pre><div class="comment"><p>Створення обмеження та додавання його до світу.</p></div></div></div>
<p>Зібравши код разом, я напишу програму із класом <code>Windmill</code>, який представляє тіло, що обертається. Програма також містить клас <code>Particle</code> для скидування на вітряк частинок.</p>
<div data-type="example">
  <h3 id="example-67-spinning-windmill"><a class="heading-link" href="#example-67-spinning-windmill">Приклад 6.7: Обертовий вітряк</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_7_windmill"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/D96JFWc3-" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Windmill</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, w, h</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = w;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span> = h;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">rectangle</span>(x, y, w, h);
    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
</code></pre><div class="comment"><p>Тіло для обертання.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> options = {
      <span class="hljs-attr">bodyA</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>,
      <span class="hljs-attr">pointB</span>: { <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y },
      <span class="hljs-attr">length</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">stiffness</span>: <span class="hljs-number">1</span>,
    };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">constraint</span> = <span class="hljs-title class_">Constraint</span>.<span class="hljs-title function_">create</span>(options);
    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">constraint</span>);
</code></pre><div class="comment"><p>Налаштування обертового обмеження.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rectMode</span>(<span class="hljs-variable constant_">CENTER</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">translate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">push</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rotate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">angle</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">h</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">line</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, height);
</code></pre><div class="comment"><p>Малювання стійки вітряка (не відноситься до фізичного світу).</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">pop</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зверніть увагу на лінію в цьому прикладі, яка представляє стійку вітряка. Вона не є частиною фізичного світу Matter.js і я ніде не створював для неї тіло. Це ілюструє важливий момент щодо роботи з фізичним рушієм разом із p5.js: ви можете додавати на полотно декоративні чи візуальні елементи, які не впливатимуть на фізичну симуляцію, якщо їх участь у цьому не потрібна.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-66"><a class="heading-link" href="#exercise-66">Вправа 6.6</a></h3>
  <p>Створіть подобу автівки, яка має поворотні шарніри для своїх коліс. Враховуйте розмір і розташування коліс. Як зміна властивості <code>stiffness</code> впливає на їх рух?</p>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;885.0000000000001&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d904958d65f74155f527c91872d91caa/c57ec/06_libraries_13.webp 576w,./static/d904958d65f74155f527c91872d91caa/ad484/06_libraries_13.webp 1152w,./static/d904958d65f74155f527c91872d91caa/3b1b3/06_libraries_13.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/d904958d65f74155f527c91872d91caa/56faf/06_libraries_13.png" data-srcset="./static/d904958d65f74155f527c91872d91caa/97d5b/06_libraries_13.png 576w,./static/d904958d65f74155f527c91872d91caa/46c7b/06_libraries_13.png 1152w,./static/d904958d65f74155f527c91872d91caa/56faf/06_libraries_13.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/d904958d65f74155f527c91872d91caa/c57ec/06_libraries_13.webp 576w,./static/d904958d65f74155f527c91872d91caa/ad484/06_libraries_13.webp 1152w,./static/d904958d65f74155f527c91872d91caa/3b1b3/06_libraries_13.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/d904958d65f74155f527c91872d91caa/56faf/06_libraries_13.png" srcSet="./static/d904958d65f74155f527c91872d91caa/97d5b/06_libraries_13.png 576w,./static/d904958d65f74155f527c91872d91caa/46c7b/06_libraries_13.png 1152w,./static/d904958d65f74155f527c91872d91caa/56faf/06_libraries_13.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
</div>
<h3 id="mouse-constraints"><a class="heading-link" href="#mouse-constraints">Обме жувач мишки</a></h3>
<p>Перш ніж я представлю клас <code>MouseConstraint</code>, подумайте про таке запитання: як встановити положення тіла Matter.js у позицію курсора миші? І навіщо вам для цього потрібен обмежувач? Зрештою, у вас є доступ і до позиції тіла і до положення курсора. Що поганого в тому, щоб призначити одне іншому?</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">body.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = mouseX;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">body.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = mouseY;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Хоча цей код дійсно рухатиме тіло, він також призведе до неприємного результату із порушенням фізики. Уявіть, що ви побудували машину для телепортації, яка дозволяє вам миттєво переміщатися зі спальні на кухню (дуже зручно для нічного перекусу). Це досить легко уявити, але тепер спробуйте переписати закони руху Ньютона, щоб врахувати можливість телепортації. Тепер все не так просто, чи не так?</p>
<p>Matter.js має таку саму проблему. Якщо ви вручну призначаєте позицію тіла, це все одно, що сказати “телепортуйте це тіло” і Matter.js більше не знає, як у такому випадку обчислювати фізику належним чином. Однак Matter.js <em>дозволяє</em> вам прив’язати мотузок навколо талії й отримати помічника, який стоятиме на кухні та тягнутиме вас туди. Замініть свого помічника на курсор і ось вам обмежувач мишки.</p>
<p>Уявіть, що коли ви клацаєте мишкою по фігурі, вона прикріплюється до цього тіла за допомогою мотузка. Тепер ви можете рухати мишкою довкола і вона тягтиме за собою тіло, доки ви не відпустите мишку. Це працює подібно до шарнірного з’єднання, оскільки ви можете встановити довжину цього “мотузка” у 0, ефективно переміщуючи фігуру за допомогою мишки.</p>
<p>Однак перед тим, як зробити прив’язку до мишки, вам потрібно створити об’єкт Matter.js <code>Mouse</code>, який слухатиме події мишки на полотні p5.js:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Mouse</span>, <span class="hljs-title class_">MouseConstraint</span> } = <span class="hljs-title class_">Matter</span>;
</code></pre><div class="comment"><p>Посилання на класи Mouse і MouseConstraint з Matter.js.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> canvas = <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p>Для прослуховування миші потрібне посилання на полотно p5.js.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> mouse = <span class="hljs-title class_">Mouse</span>.<span class="hljs-title function_">create</span>(canvas.<span class="hljs-property">elt</span>);
</code></pre><div class="comment"><p>Створення об’єкта Mouse, пов’язаного з нативним елементом canvas.</p></div></div></div>
<p>Далі використайте об’єкт <code>mouse</code> для створення <code>MouseConstraint</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> mouseConstraint = <span class="hljs-title class_">MouseConstraint</span>.<span class="hljs-title function_">create</span>(engine, { mouse });
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, mouseConstraint);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Це миттєво дозволить вам взаємодіяти з усіма тілами Matter.js за допомогою миші. Явно прикріплювати обмежувач до певного тіла тут не потрібно — будь-яке тіло, на яке ви клацнете, буде обмежено мишею автоматично.</p>
<p>Ви також можете налаштувати всі звичайні змінні обмеження, додавши властивість <code>constraint</code> до параметрів, які передаються у метод <code>MouseConstraint.create()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">mouse = <span class="hljs-title class_">Mouse</span>.<span class="hljs-title function_">create</span>(canvas.<span class="hljs-property">elt</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  mouse,
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">constraint</span>: { <span class="hljs-attr">stiffness</span>: <span class="hljs-number">0.7</span> }
</code></pre><div class="comment"><p>Налаштування обмеження з додатковою властивістю.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">mouseConstraint = <span class="hljs-title class_">MouseConstraint</span>.<span class="hljs-title function_">create</span>(engine, options);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, mouseConstraint);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ось приклад демонстрації <code>MouseConstraint</code> з двома об’єктами <code>Box</code>. Тут також налаштовні статичні тіла, що діють як стіни навколо периметру полотна.</p>
<div data-type="example">
  <h3 id="example-68-mouseconstraint-demonstration"><a class="heading-link" href="#example-68-mouseconstraint-demonstration">Приклад 6.8: Демонстрація MouseConstraint</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_8_mouse_constraint"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/mTRKgn44p" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<p>У цьому прикладі ви побачите, що властивість <code>stiffness</code> обмежувача встановлено на <code>0.7</code>, надаючи трохи еластичності уявному мотузку мишки. Інші властивості, такі як <code>angularStiffness</code> і <code>damping</code> також можуть впливати на взаємодію з мишею. Пограйте з цими значеннями й подивіться, що станеться?</p>
<h2 id="adding-more-forces"><a class="heading-link" href="#adding-more-forces">Додаємо більше сил</a></h2>
<p>У <a href="/forces#section-forces">Розділі 2</a> я розповів, як побудувати середовище у якому діє кілька сил. Об’єкт може реагувати на гравітаційне тяжіння, вітер, опір повітря тощо. Очевидно, що в Matter.js також діють сили, коли прямокутники та круги обертаються та літають по екрану! Але наразі я продемонстрував, як контролювати лише одну глобальну силу — гравітацію:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> engine = <span class="hljs-title class_">Engine</span>.<span class="hljs-title function_">create</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  engine.<span class="hljs-property">gravity</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;
  engine.<span class="hljs-property">gravity</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Налаштування сили тяжіння світу у горизонтальному напрямку.</p></div></div></div>
<p>Якщо я хочу використати будь-який підхід <a href="/forces#section-forces">Розділу 2</a> із Matter.js, мені знадобиться лише надійний метод <code>applyForce()</code>, який я написав як частину класу <code>Mover</code>. Він приймав вектор, ділив його на масу і накопичував у прискоренні об’єкта. У Matter.js працює той самий підхід, тому мені більше не потрібно самостійно писати всі деталі! Я можу викликати його як статичний метод <code>Body.applyForce()</code>. Ось як це виглядатиме у поточному класі <code>Box</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">applyForce</span>(<span class="hljs-params">force</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Body</span>.<span class="hljs-title function_">applyForce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>, force);
</code></pre><div class="comment"><p>Виклик методу applyForce() з класу Body.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тут метод <code>applyForce()</code> з класу <code>Box</code> отримує вектор сили й просто передає його методу <code>applyForce()</code> Matter.js для застосування його до відповідного тіла. Основна відмінність цього підходу в тому, що Matter.js має складніший механізм, ніж приклади з <a href="/forces#section-forces">Розділу 2</a>. У попередніх прикладах припускалося, що сила завжди застосовується у центрі рухомого об’єкта. Тут я вказав точне положення на тілі, де прикладається сила. У цьому випадку я просто застосував її до центру, як і раніше, вказавши положення тіла, але це можна було б налаштувати інакше. Наприклад, уявіть сценарій, де сила діє на край об’єкта, змушуючи його обертатися на полотні, подібно до перекочування кинутих гральних кубиків.</p>
<p>Як я можу ввести сили у програму, керовану за допомогою Matter.js? Скажімо, я хочу використати силу тяжіння. Пам’ятаєте код з прикладу 2.6 у класі <code>Attractor</code>?</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">attract</span>(<span class="hljs-params">mover</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> force = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, mover.<span class="hljs-property">position</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = force.<span class="hljs-title function_">mag</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    distance = <span class="hljs-title function_">constrain</span>(distance, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> strength = (G * <span class="hljs-variable language_">this</span>.<span class="hljs-property">mass</span> * mover.<span class="hljs-property">mass</span>) / (distance * distance);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    force.<span class="hljs-title function_">setMag</span>(strength);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> force;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я можу переписати такий самий метод, використовуючи <code>Matter.Vector</code> і включ ити його в новий клас <code>Attractor</code>.</p>
<div data-type="example">
  <h3 id="example-69-attraction-with-matterjs"><a class="heading-link" href="#example-69-attraction-with-matterjs">Приклад 6.9: Притягання з Matter.js</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_9_matter_js_attraction"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/16sblEvax" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Attractor</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = <span class="hljs-number">32</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>, { <span class="hljs-attr">isStatic</span>: <span class="hljs-literal">true</span> });
    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
</code></pre><div class="comment"><p>Атрактор — це статичне тіло Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">attract</span>(<span class="hljs-params">mover</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> force = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>, mover.<span class="hljs-property">body</span>.<span class="hljs-property">position</span>);
    <span class="hljs-keyword">let</span> distance = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">magnitude</span>(force);
</code></pre><div class="comment"><p>Метод attract() тепер використовує векторні методи Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    distance = <span class="hljs-title function_">constrain</span>(distance, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> G = <span class="hljs-number">0.02</span>;
</code></pre><div class="comment"><p>Використання невеликого значення для G утримує стабільність системи.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> strength = (G * mover.<span class="hljs-property">body</span>.<span class="hljs-property">mass</span>) / (distance * distance);
</code></pre><div class="comment"><p>Оскільки атрактор статичне тіло, його маса тут буде проігнорована.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    force = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">normalise</span>(force);
    force = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">mult</span>(force, strength);
</code></pre><div class="comment"><p>Інші векторні методи Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> force;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Окрім написання власного методу <code>attract()</code> для прикладу 6.9, є ще два ключові елементи, необхідні для програми, щоб поведінка була схожа на приклад з <a href="/forces#section-forces">Розділу 2</a>. По-перше, пам’ятайте, що Matter.js <code>Engine</code> має дефолтну гравітацію, спрямовану вниз. Мені потрібно відключити її у функції <code>setup()</code> за допомогою вектора <code>(0, 0)</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">engine = <span class="hljs-title class_">Engine</span>.<span class="hljs-title function_">create</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">engine.<span class="hljs-property">gravity</span> = <span class="hljs-title class_">Vector</span>.<span class="hljs-title function_">create</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre><div class="comment"><p>Вимкнення гравітації за замовчуванням.</p></div></div></div>
<p>По-друге, тіла в Matter.js створюються з дефолтним опором повітря, який сповільнює їх рух. Мені також потрібно встановити це значення на <code>0</code>, щоб імітувати для тіла подобу перебування у космічному вакуумі:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mover</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, radius</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> options = { <span class="hljs-attr">frictionAir</span>: <span class="hljs-number">0</span> };
</code></pre><div class="comment"><p>Вимкнення дефолтного опору повітря.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>, options);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Це також хороша нагода повернутися до поняття маси. Хоча я маю доступ до властивості <code>mass</code> тіла, пов’язаного з рухомим тілом у методі <code>attract()</code>, я ніколи не встановлював її явно. У Matter.js маса тіла автоматично розраховується на основі його розміру (площі) і щільності. Отже, більші тіла матимуть більшу масу. Щоб збільшити масу відносно розміру, ви можете спробувати встановити властивість <code>density</code> в об’єкті <code>options</code> (за замовчуванням <code>0.001</code>). Для статичних тіл, таких як атрактор, маса вважається нескінченною. Так атрактор залишається заблокованим на місці, попри постійні зіткнення з ним інших рухомих об’єктів.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-67"><a class="heading-link" href="#exercise-67">Вправа 6.7</a></h3>
  <p>Включіть <code>Body.applyForce()</code> у новий метод <code>spin()</code> класу <code>Windmill</code>, щоб вітряк постійно виконував оберти.</p>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/exercise_6_7_windmill_motor"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/cN6zF325F" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-68"><a class="heading-link" href="#exercise-68">Вправа 6.8</a></h3>
  <p>Переробіть будь-які приклади керувального руху з <a href="/autonomous-agents#section-autonomous-agents">Розділу 5</a> із використанням Matter.js. Як виглядатиме флокі нг із зіткненнями?</p>
</div>
<h2 id="collision-events"><a class="heading-link" href="#collision-events">Події зіткнення</a></h2>
<p>Ця книга не називається <em>Природа Matter.js</em>, тому я не збираюся охоплювати всі можливості бібліотеки Matter.js. На цьому етапі я розглянув основи створення тіл і обмежень та показав деякі з можливостей бібліотеки. Сподіваюся, коли прийде час використовувати аспекти Matter.js, які я не розглядав тут, ваш процес навчання буде набагато менш болісним, завдяки отриманим тут навичкам. Однак перед наступними кроками є ще одна особливість бібліотеки, яку, на мою думку, варто розглянути — це події зіткнення.</p>
<p>Ось питання, яким ви, ймовірно, задавалися: “А якщо мені потрібно, щоб під час зіткнення двох тіл сталося щось додаткове? Не зрозумійте мене неправильно — я в захваті від того, що Matter.js справляється з усіма зіткненнями замість мене. Але якщо Matter.js піклується про зіткнення за мене, як я маю дізнатися, коли саме вони відбуваються?”</p>
<p>Ваша перша думка, щоб відповісти на це запитання, може бути такою: “Ну, я знаю всі тіла в системі, і я знаю де вони всі розташовані. Я можу просто почати порівнювати положення тіл і побачити, які з них перетинаються. Тоді для тіл, що будуть у стані зіткнення, я можу зробити щось додаткове”.</p>
<p>Гарна думка, але агов? Суть використання фізичного рушія, такого як Matter.js, полягає в тому, що він виконує всю цю роботу за вас. Якщо ви збираєтеся реалізовувати алгоритми обчислення геометрії для перевірки перетину, тоді по суті, ви робите свій власний Matter.js!</p>
<p>Звісно, бажання знати, коли тіла стикаються, є досить поширеною проблемою, тому Matter.js це врахував. Він може сповіщати вас про моменти зіткнення за допомогою <strong>слухача подій</strong>. Якщо в межах p5.js ви вже працювали із взаємодією з мишкою чи клавіатурою, тоді у вас уже є досвід роботи зі слухачами подій. Розгляньте наступний код:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mousePressed</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;The mouse was pressed!&quot;</span>);
}
</code></pre><div class="comment"><p>Подія mousePressed, яку ви, напевно, вже писали багато разів раніше.</p></div></div></div>
<p>Глобальна функція <code>mousePressed()</code> у p5.js виконується кожного разу, коли відбувається клацання мишкою. Це називається <strong>callback</strong> (колбек або зворотний виклик) — функція, яка викликається у відповідь на певну подію. Події зіткнення Matter.js працюють подібним чином, але на відміну від функції <code>mousePressed()</code>, яку p5.js самостійно шукає, щоб виконати під час клацання, для події зіткнень Matter.js ви повинні явно створити та зареєструвати колбек функцію:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title class_">Matter</span>.<span class="hljs-property">Events</span>.<span class="hljs-title function_">on</span>(engine, <span class="hljs-string">&#x27;collisionStart&#x27;</span>, handleCollisions);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Цей код вказує, що функцію із назвою <code>handleCollisions</code> слід виконувати щоразу, коли починається зіткнення між двома тілами. Matter.js також має події для <code>&#x27;collisionActive&#x27;</code> (виконується знову і знову під час дії зіткнення) та <code>&#x27;collisionEnd&#x27;</code> (виконується, коли два тіла припиняють зіткнення), але для базової демонстрації, розуміння, коли починається зіткнення, більш ніж достатньо.</p>
<p>Подібно до того, як функція <code>mousePressed()</code> спрацьовує під час натискання мишки, функція <code>handleCollisions()</code> (або будь-яка інша, яку ви оберете для функції зворотного виклику), спрацьо вує, коли дві фігури зіткнулися. Цю функцію можна записати наступним чином:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCollisions</span>(<span class="hljs-params">event</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Зверніть увагу, що функція має параметр <code>event</code>. Це об’єкт, який містить усі дані, пов’язані із зіткненням тіл (або кількома зіткненнями, якщо одночасно відбулося більше одного зіткнення). Matter.js автоматично створює цей об’єкт і передає його як параметр у колбек <code>handleCollisions()</code> кожного разу, коли виникає колізія.</p>
<p>Скажімо, у мене є програма з об’єктами <code>Particle</code>. Кожен містить посилання на тіло Matter.js і я хочу, щоб при зіткненні між собою частинки змінювали свій колір. Щоб це сталося, слід виконати наступний процес:</p>
<p><strong>Крок 1. Подія, підкажи мені, які два тіла зіткнулися?</strong></p>
<p>Що тут зіткнулося? Matter.js виявляє зіткнення між парою тіл. Будь-яка пара тіл, що зіткнулися, буде в масиві пі д назвою <code>pairs</code> в об’єкті <code>event</code>. Усередині функції <code>handleCollisions()</code> я можу використовувати цикл <code>for...of</code>, щоб перебрати ці пари:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> event.<span class="hljs-property">pairs</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p><strong>Крок 2: Пара, підкажи мені, з яких двох тіл ти складаєшся?</strong></p>
<p>Кожна пара в масиві <code>pairs</code> є об’єктом із посиланнями на два тіла, що беруть участь у зіткненні: <code>bodyA</code> і <code>bodyB</code>. Я витягну ці тіла в окремі змінні:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> event.<span class="hljs-property">pairs</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> bodyA = pair.<span class="hljs-property">bodyA</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> bodyB = pair.<span class="hljs-property">bodyB</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p><strong>Крок 3. Тіла, підкажіть, які частинки ви представляєте?</strong></p>
<p>Знайти відповідні об’єкти <code>Particle</code>, що пов’язані з тілами Matter.js трохи складніше. Зрештою, Matter.js нічого не знає про мій код. Звісно, він робить усілякі речі для відстеження зв’язків між тілами й обмеженнями Matter.js, але керування зв’язками між моїми власними об’єктами p5.js та елементами Matter.js вже залежать від мене. Втім, кожне тіло Matter.js створюється з порожнім об’єктом <code>{ }</code>, що має назву <code>plugin</code> і готове для зберігання будь-яких додаткових користувацьких даних про це тіло. Я можу зв’язати тіло з власним об’єктом (у цьому випадку з <code>Particle</code>), зберігаючи посилання на цей об’єкт у властивості <code>plugin</code>.</p>
<p>Подивіться на оновлений конструктор у класі <code>Particle</code>, де створюється тіло. Зверніть увагу, що функція створення тіла була розширена на один рядок коду, щоб додати властивість <code>particle</code> усередину об’єкта <code>plugin</code>. Важливо переконатися, що ви додаєте нову властивість до об’єкта <code>plugin</code>, що вже існує (у цьому випадку, <code>plugin.particle = this</code>), а не перезаписуєте сам об’єкт <code>plugin</code> (наприклад, таким чином <code>plugin = this</code>). Останнє може видалити з об’єкту <code>plugin</code> інші додані функції або налаштування.</p>
<div class="snip-below avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, radius</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> = radius;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span>);
</code></pre><div class="comment"><p></p></div></div><div class="bold pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>.<span class="hljs-property">plugin</span>.<span class="hljs-property">particle</span> = <span class="hljs-variable language_">this</span>;
</code></pre><div class="comment"><p>Ключове слово this вказує на поточний об’єкт Particle, говорячи тілу Matter.js зберегти
посилання на цю частинку, щоб пізніше можна було отримати до неї доступ.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title class_">Composite</span>.<span class="hljs-title function_">add</span>(engine.<span class="hljs-property">world</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Пізніше, у функції зворотного виклику <code>handleCollision()</code>, до цього об’єкта <code>Particle</code> можна буде отримати доступ із самого тіла за допомогою об’єкта <code>plugin</code>.</p>
<div data-type="example">
  <h3 id="example-610-collision-events"><a class="heading-link" href="#example-610-collision-events">Приклад 6.10: Події зіткнень</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_10_collision_events"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/3cREe4udP" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCollisions</span>(<span class="hljs-params">event</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> event.<span class="hljs-property">pairs</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> bodyA = pair.<span class="hljs-property">bodyA</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> bodyB = pair.<span class="hljs-property">bodyB</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> particleA = bodyA.<span class="hljs-property">plugin</span>.<span class="hljs-property">particle</span>;
    <span class="hljs-keyword">let</span> particleB = bodyB.<span class="hljs-property">plugin</span>.<span class="hljs-property">particle</span>;
</code></pre><div class="comment"><p>Отримання частинок за допомогою об’єкта plugin, які пов’язані з тілами, що зіткнулися.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (particleA <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Particle</span> &amp;&amp; particleB <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Particle</span>) {
      particleA.<span class="hljs-title function_">change</span>();
      particleB.<span class="hljs-title function_">change</span>();
    }
</code></pre><div class="comment"><p>Якщо обидва об’єкта є частинками, змінимо їх колір!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>По замовчуванню ви не можете вважати, що об’єкти, які зіткнулися, будуть саме об’єктами <code>Particle</code>. Зрештою, частинка могла зіткнутися з об’єктом <code>Boundary</code> (або чимось іншим, залежно від того, що є у вашому світі). Ви можете перевірити тип об’єкта за допомогою JavaScript-оператора <code>instanceof</code>, як я зробив у цьому прикладі.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-69"><a class="heading-link" href="#exercise-69">Вправа 6.9</a></h3>
  <p>Створіть симуляцію в якій об’єкти <code>Particle</code> зникатимуть при зіткненні один з одним. Де і як слід видаляти частинки? Чи зможете ви зробити так, щоб вони розламувалися на менші частинки?</p>
</div>
<h2 id="a-brief-interlude-integration-methods"><a class="heading-link" href="#a-brief-interlude-integration-methods">Коротка інтерлюдія: Методи інтегрування</a></h2>
  <p>З вами колись таке траплялося? Ви на елегантній коктейльній вечірці, розповідаєте своїм друзям про неймовірні програми фізичних симуляцій. Раптом, як грім серед ясного неба, хтось запитує: “Чарівно! Але який метод інтегрування ви використовуєте?”</p>
<p><em>Що?!</em> думаєте ви собі. <em>Інтегрування?</em></p>
<p>Можливо, ви вже чули цей термін. Разом із диференціюванням, це одна з двох основних операцій числення.</p>
<p>Мені вдалося пройти більшу частину матеріалу в цій книзі, пов’язаного з моделюванням фізики, без необхідності занурюватися у числення. Однак, завершуючи першу половину цієї книги, варто приділити хвилину для розгляду числення, що лежить в основі того, що я продемонстрував, і як воно пов’язане з методологією певних фізичних бібліотек (наприклад, Box2D, Matter.js і Toxiclibs.js до якої ми підходимо). Таким чином, ви будете знати, що відповісти на наступній коктейльній вечірці, коли хтось запитає вас про інтегрування.</p>
<p>Я почну з питання: “Що спільного має інтегрування з положенням, швидкістю і прискоренням?” Щоб відповісти, я повинен спочатку визначити <strong>диференціювання</strong> — процес знаходження похідної. <strong>Похідна</strong> функції є мірою того, як функція змінюється з часом. Розглянемо положення та її похідну. Положення — це точка у просторі, тоді як швидкість — це зміна положення з часом. Тому швидкість можна описати як похідну положення. А що таке прискорення? Зміна швидкості з часом. Прискорення — це похідна швидкості.</p>
<p><strong>Інтегрування</strong> — це процес знаходження інтеграла — операція, яка є оберненою до диференціювання. Наприклад, <strong>інтеграл</strong> швидкості об’єкта з плином часу повідомляє нам нове положення об’єкта після закінчення цього періоду часу. Положення є інтегралом швидкості, а швидкість є ін тегралом прискорення.</p>
<p>Оскільки фізичні симуляції в цій книзі ґрунтуються на ідеї обчислення прискорення на основі сил, інтегрування потрібне для визначення місця розташування об’єкта через певний період часу (наприклад, через один цикл роботи функції <code>draw()</code>). Іншими словами, ви весь час вже займалися інтегруванням! Наступний код показує, як це виглядає:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">velocity.<span class="hljs-title function_">add</span>(acceleration);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">position.<span class="hljs-title function_">add</span>(velocity);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ця методика відома як <strong>Інтегрування Ейлера</strong> (названа на честь математика Леонарда Ейлера), або <strong>метод Ейлера</strong>. По суті, це найпростіша форма інтегрування і її дуже легко реалізувати в коді — всього два рядки! Проте, хоча це просто у плані обчислення, це аж ніяк не найточніший або стабільний вибір для певних типів симуляцій.</p>
<p>Чому метод Ейлера неточний? Подумайте про це так: коли ви підстрибуєте на пого-палиці, чи залишається вона в одній позиції протягом 1 секунди, а потім зникає та раптово з’являється в новій позиції на другій секунді й потім те саме на 3 секунді, 4, 5...? Ні, звичайно, ні. Пого-палиця рухається у часі безперервно.</p>
<p>Але що відбувається у програмі p5.js? На першому кадрі об’єкт знаходиться в одному положенні, на наступному кадрі в іншому і так далі. Звісно, при 30-60 кадрах на секунду ви бачите <em>ілюзію</em> руху. Але нове положення обчислюється лише кожні <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span>-одиниць часу, тоді як реальний світ абсолютно безперервний. Це призводить до деяких неточностей, як показано на малюнку 6.12.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;962&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/dd7e7d540d9b3cf2a831f01594f6ecc0/63cd2/06_libraries_14.webp 576w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/26cf5/06_libraries_14.webp 1152w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/85743/06_libraries_14.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/dd7e7d540d9b3cf2a831f01594f6ecc0/cba64/06_libraries_14.png" data-srcset="./static/dd7e7d540d9b3cf2a831f01594f6ecc0/26ee9/06_libraries_14.png 576w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/13c35/06_libraries_14.png 1152w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/cba64/06_libraries_14.png 2304w" alt="Figure 6.12: The Euler approximation of a curve"/></picture><noscript><picture><source type="image/webp" srcSet="./static/dd7e7d540d9b3cf2a831f01594f6ecc0/63cd2/06_libraries_14.webp 576w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/26cf5/06_libraries_14.webp 1152w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/85743/06_libraries_14.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/dd7e7d540d9b3cf2a831f01594f6ecc0/cba64/06_libraries_14.png" srcSet="./static/dd7e7d540d9b3cf2a831f01594f6ecc0/26ee9/06_libraries_14.png 576w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/13c35/06_libraries_14.png 1152w,./static/dd7e7d540d9b3cf2a831f01594f6ecc0/cba64/06_libraries_14.png 2304w" alt="Figure 6.12: The Euler approximation of a curve"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.12: Ейлерова апроксимація кривої</figcaption>
</figure>
<p>“Реальний світ” — це гладенька крива. Симуляція Ейлера — це послідовність прямих відрізків. Одним із варіантів покращення методу Ейлера є використання менших часових кроків — замість одного разу на кадр, ви можете перераховувати положення об’єкта 20 разів на кадр. Але це не практично, бо програма може почати працювати дуже повільно.</p>
<p>Я все ще вважаю, що метод Ейлера — це найкращий метод для вивчення основ і він також цілком підходить для більшості проєктів, які ви забажаєте зробити з p5.js. Усе, що втрачається в ефективності або неточності, компенсується простотою використання і зрозумілістю. Для покращення точності рушій Box2D, наприклад, використовує симплектичний або напів-експліцитний метод Ейлера, що є невеликою модифікацією метода Ейлера. Інші рушії використовують метод інтегрування, який називається методом Рунге-Кутти (названий на честь німецьких математиків Карла Рунге і Мартіна Кутти).</p>
<p>Іншим попу лярним методом інтегрування, який використовується у фізичних бібліотеках, включаючи Matter.js і Toxiclibs.js, є <strong>метод Верле</strong>. Простий спосіб описати метод Верле — це подумати про типовий алгоритм руху без явного зберігання швидкості. Зрештою, вам дійсно не потрібно зберігати швидкість оскільки, якщо ви завжди знаєте де об’єкт був у певний момент часу і де він знаходиться зараз, то зможете екстраполювати його швидкість. Метод Верле робить саме це, обчислюючи швидкість на льоту під час роботи програми, замість того, щоб зберігати окрему змінну для швидкості.</p>
<p>Метод Верле дуже добре підходить для систем із частинками, особливо з пружинними з’єднаннями між частинками. Фізичні бібліотеки приховують від вас деталі реалізації, тож вам не потрібно перейматися про те, як це все працює, але якщо ви зацікавлені у глибшому зануренні у фізику Верле, я пропоную прочитати основоположну статтю Томаса Якобсена, з якої походять майже всі симуляції Верле у комп’ютерній графіці: <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf" target="_blank" rel="noopener">“Advanced Character Physics”</a>.</p>
<h2 id="verlet-physics-with-toxiclibsjs"><a class="heading-link" href="#verlet-physics-with-toxiclibsjs">Фізика Верле з використанням Toxiclibs.js</a></h2>
<p>Приблизно у 2005 році Карстен Шмідт розпочав роботу над Toxiclibs, широкомасштабною та передовою бібліотекою з відкритим кодом для обчислювального проєктування, спеціально створеною для Java-версії програми Processing. Попри те, що бібліотека особливо не розвивалася понад 10 років, концепції й методи, які вона продемонструвала свого часу, сьогодні можна знайти у безлічі проєктів творчого програмування. Вебсайт бібліотеки описував її наступним чином:</p>
<blockquote data-type="epigraph">
  <p><em>Toxiclibs — це незалежна бібліотека з відкритим кодом, призначена для задач обчислювального проєктування на Java і Processing, розроблена Карстеном “toxi” Шмідтом. Класи бібліотеки цілеспрямовано зроблені досить загальними, щоб максимізувати можливість їх повторного використання у різних контекстах, включаючи генеративний дизайн, анімацію, інтерактивний дизайн, візуалізації даних для архітектурних та цифрових цілей, використання в якості навчального інструменту тощо.</em></p>
</blockquote>
<p>Шмідт і сьогодні продовжує робити свій внесок у сферу креативного кодування завдяки своєму проєкту <a href="https://thi.ng/umbrella" target="_blank" rel="noopener">thi.ng/umbrella</a>. Цю роботу можна вважати непрямим наступником Toxiclibs.js, але з набагато більшим обсягом і деталями. Якщо вам сподобалася ця книга, вам можливо особливо сподобається досліджувати <a href="https://thi.ng/vectors" target="_blank" rel="noopener">thi.ng/vectors</a>, який містить понад 800 функцій векторної алгебри, що використовують звичайні масиви JavaScript.</p>
<p>Хоча <a href="https://thi.ng/umbrella" target="_blank" rel="noopener">thi.ng/umbrella</a> може бути більш сучасним і витонченим підходом, Toxiclibs.js залишається універсальним інструментом і я досі продовжую використовувати версію сумісну з останньою версією Processing (4.3 на момент написання цього тексту). Ми маємо подякувати нашим зіркам удачі за існування Toxiclibs.js, адаптації цієї бібліотеки на JavaScript, створеної Кайлом Філліпсом (відомий під нікнеймом hapticdata). Я покажу лише кілька прикладів, пов’язаних з фізикою Верле, але бібліотека Toxiclibs.js також містить низку інших пакетів із функціональністю, пов’язаною з кольорами, геометрією, математикою тощо.</p>
<p>Приклади, які я збираюся продемонструвати, також можна створити з використанням Matter.js, але я вирішив перейти до Toxiclibs.js з кількох причин. Ця бібліотека займає особливе місце в моєму серці як особистий фаворит і має важливе історичне значення. Також я вважаю, що розгляд більш ніж одної фізичної бібліотеки важливо для ширшого розуміння доступних інструментів і підходів.</p>
<p>Цей перехід від Matter.js до Toxiclibs.js порушує важливе питання: як вирішити, яку саме бібліотеку краще використовувати для проєкту? Matter.js, Toxiclibs.js чи щось інше? Якщо ви належите до однієї з наступних двох категорій, ваш вибір буде трохи легшим:</p>
<ul>
  <li><strong>Ваш проєкт передбачає зіткнення. Ви маєте круги, квадрати й інші об’єкти певних форм, які вдаряються і відскакують один від одного.</strong> У цьому випадку вам захочеться використовувати Matter.js, оскільки Toxiclibs.js не обробляє зіткнення твердих тіл.</li>
  <li><strong>Ваш проєкт включає багато частинок, які рухаються по екрану. Іноді вони притягують одна одну. Іноді вони відштовхуються одна від одної. А іноді вони пов’язані пружинними з’єднаннями.</strong> У цьому випадку Toxiclibs.js, ймовірно, буде найкращим вибором. У деяких прикладах він простіший у використанні ніж Matter.js, і особливо добре підходить для з’єднаних систем частинок. Він також має високу продуктивність, оскільки ігнорує всю геометрію зіткнень.</li>
</ul>
<p>Ось невелика порівняльна таблиця, яка охоплює деякі функції даних бібліотек:</p>
<table><thead><tr><th>Особливість</th><th>Matter.js</th><th>Toxiclibs.js</th></tr></thead><tbody><tr><td>Зіткнення твердих тіл</td><td>Є</td><td>Нема</td></tr><tr><td>3D фізика</td><td>Нема</td><td>Є</td></tr><tr><td>Сили притягування і відштовхування частинок</td><td>Нема</td><td>Є</td></tr><tr><td>Пружинні з’єднання (на основі сили)</td><td>Є</td><td>Є</td></tr><tr><td>Обмеження (з’єднання загального призначення)</td><td>Є</td><td>Нема</td></tr></tbody></table>
<p>Усю документацію та файли бібліотеки можна знайти на <a href="http://haptic-data.com/toxiclibsjs" target="_blank" rel="noopener">вебсайті Toxiclibs.js</a>. Для прикладів у цій книзі я працюватиму з версією, яка зберігається на CDN і зроблю відповідне посилання на неї у файлі <em>index.html</em>, так само як я робив це для Matter.js. Нижче приклад з підключенням бібліотеки через тег <code>&lt;script&gt;</code>:</p>
<div class="codesplit callout not-prose" data-code-language="html"><div class="pair"><pre><code class="hljs code language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/hapticdata/toxiclibsjs@0.3.2/build/toxiclibs.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><div class="comment"><p></p></div></div></div>
<p>Мій огляд Matter.js зосереджувався  на кількох ключових функціональностях цієї бібліотеки: світ, вектор, тіло, обмеження. Це також дасть вам початкове розуміння Toxiclibs.js, оскільки він має схожу структуру. У наступній таблиці показано відповідний функціонал зі сторони Toxiclibs.js:</p>
<table><thead><tr><th>Matter.js</th><th>Toxiclibs.js</th></tr></thead><tbody><tr><td>
        <pre><code>World</code></pre>
      </td><td>
        <pre><code>VerletPhysics2D</code></pre>
      </td></tr><tr><td>
        <pre><code>Vector</code></pre>
      </td><td>
        <pre><code>Vec2D</code></pre>
      </td></tr><tr><td>
        <pre><code>Body</code></pre>
      </td><td>
        <pre><code>VerletParticle2D</code></pre>
      </td></tr><tr><td>
        <pre><code>Constraint</code></pre>
      </td><td>
        <pre><code>VerletSpring2D</code></pre>
      </td></tr></tbody></table>
<p>Спершу я розгляну як деякі з цих функціональностей перекладаються у Toxiclibs.js, а потім почну поєднувати їх для створення цікавих прикладів.</p>
<h3 id="vectors"><a class="heading-link" href="#vectors">Вектори</a></h3>
<p>І ось ми знову на початку. Пам’ятаєте весь той час, витрачений на вивчення усіх деталей класу <code>p5.Vector</code>? А пам’ятаєте, як потім вам довелося переглянути всі ці концепції з Matter.js і його класом <code>Matter.Vector</code>? Що ж, настав час зробити це знову, оскільки Toxiclibs.js також містить власні векторні класи. Він має один клас для двох вимірів і один для трьох: <code>Vec2D</code> та <code>Vec3D</code>. Обидва містяться в пакеті <code>toxi.geom</code> і можуть бути деструктуровані з нього як клас <code>Vector</code> з Matter.js:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Vec2D</span>, <span class="hljs-title class_">Vec3D</span> } = toxi.<span class="hljs-property">geom</span>;
</code></pre><div class="comment"><p></p></div></div></div>
<p>Знову ж таки, концептуально вектори Toxiclibs.js такі ж, що і вектори p5.js, які ми знаємо й любимо, але вони мають власний стиль та синтаксис. Ось огляд того, як деякі основні операції векторної математики з <code>p5.Vector</code> перекладаються на <code>Vec2D</code>. (Я використовую 2D, щоб відповідати решті цієї книги, але закликаю вас так само досліджувати 3D-вектори):</p>
<table><thead><tr><th>p5.Vector</th><th>Vec2D</th></tr></thead><tbody><tr><td>
        <pre><code>let a = createVector(1, -1);
let b = createVector(3, 4);
a.add(b);</code></pre>
      </td><td>
        <pre><code>let a = new Vec2D(1, -1);
let b = new Vec2D(3, 4);
a.addSelf(b);</code></pre>
      </td></tr><tr><td>
        <pre><code>let a = createVector(1, -1);
let b = createVector(3, 4);
let c = p5.Vector.add(a, b);</code></pre>
      </td><td>
        <pre><code>let a = new Vec2D(1, -1);
let b = new Vec2D(3, 4);
let c = a.add(b);</code></pre>
      </td></tr><tr><td>
        <pre><code>let a = createVector(1, -1);
let m = a.mag();
a.normalize();</code></pre>
      </td><td>
        <pre><code>let a = new Vec2D(1, -1);
let m = a.magnitude();
a.normalize();</code></pre>
      </td></tr></tbody></table>
<p>Зокрема зверніть увагу, що вектори Toxiclibs.js створюються шляхом виклику конструктора <code>Vec2D</code> з ключовим словом <code>new</code>, а не за допомогою фабричного методу, подібно до <code>Matter.Vector()</code> або <code>createVector()</code>.</p>
<h3 id="the-physics-world"><a class="heading-link" href="#the-physics-world">Світ фізики</a></h3>
<p>Класи для опису світу і його частинок й пружин у Toxiclibs.js містяться в <code>toxi.physics2d.</code> Я також збираюся використовувати об’єкт <code>Rect</code> для опису загальної межі прямокутника і <code>GravityBehavior</code> для застосування до світу глобальної сили тяжіння. Разом із <code>Vec2D</code> я створю для них наступні змінні-посилання:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Vec2D</span>, <span class="hljs-title class_">Rect</span> } = toxi.<span class="hljs-property">geom</span>;
</code></pre><div class="comment"><p>Необхідні класи геометрії для векторів і прямокутників.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">VerletPhysics2D</span>, <span class="hljs-title class_">VerletParticle2D</span>, <span class="hljs-title class_">VerletSpring2D</span> } = toxi.<span class="hljs-property">physics2d</span>;
</code></pre><div class="comment"><p>Змінні важливих класів з toxi.physics2d.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">GravityBehavior</span> } = toxi.<span class="hljs-property">physics2d</span>.<span class="hljs-property">behaviors</span>;
</code></pre><div class="comment"><p>Клас для гравітації.</p></div></div></div>
<p>Перший крок — створення світу:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> physics;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletPhysics2D</span>();
</code></pre><div class="comment"><p>Створення світу Toxiclibs.</p></div></div></div>
</div>
<p>Маючи створений світ <code>VerletPhysics</code>, я можу встановити глобальні властивості. Наприклад, якщо мені потрібні жорсткі кордони, за межі яких частинки не мають рухатися, я можу зробити це за допомогою прямокутника:</p>
<div class="snip-above snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">setWorldBounds</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height));
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Крім того, я можу додати гравітацію за допомогою об’єкта <code>GravityBehavior</code>. Для гравітації потрібно задати вектор, щоб вказати її силу та напрямок дії:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">addBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GravityBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vec2D</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>)));
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Нарешті, щоб обчислити фізику світу і переміщувати його об’єкти, потрібно викликати метод оновлення світу — <code>update()</code>. Зазвичай це відбувається один раз на кадр у функції <code>draw()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p>Це те ж саме, що і Engine.update() у Matter.js.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер залишається лише наповнити світ.</p>
<h3 id="particles"><a class="heading-link" href="#particles">Частинки</a></h3>
<p>Еквівалент тіла Matter.js у Toxiclibs.js — річ, яка існує у світі й піддається фізиці — це <strong>частинка</strong>, представлена класом <code>VerletParticle2D</code>. Однак, на відміну від тіл Matter.js, частинки Toxiclibs.js не зберігають геометрію — це просто точки в просторі.</p>
<p>Як мені інтегрувати частинки Toxiclibs.js у програму p5.js? Для прикладів Matter.js я створював власний клас (названий <code>Particle</code>) і включав у ньому посилання на тіло Matter.js:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">body</span> = <span class="hljs-title class_">Bodies</span>.<span class="hljs-title function_">circle</span>(x, y, r);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p> Цей підхід був дещо зайвим, оскільки Matter.js відстежує тіла свого світу. Однак це дозволило мені розуміти яке саме тіло до якої частинки відноситься (і знати, як кожне тіло має бути намальоване), не використовуючи ітерації внутрішніх масивів Matter.js. Я міг би піти таким же шляхом з Toxiclibs.js, створивши власний клас <code>Particle</code>, який зберігає посилання на об’єкт <code>VerletParticle2D</code>. Таким чином я зможу надати частинкам власні властивості та малювати їх, як захочу. Ймовірно, я б написав код наступним чином:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">particle</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletParticle2D</span>(x, y);
</code></pre><div class="comment"><p>VerletParticle потребує початкові координати (x, y), але не має геометрії, тому властивість r використовується лише для малювання.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">particle</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">particle</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p>При малюванні частинки використовуються координати (x, y), що зберігаються у this.particle.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Переглядаючи цей код, ви можете спочатку помітити, що намалювати частинку дуже просто, достатньо взяти координати <code>x</code> і <code>y</code> та використати їх у функції <code>circle()</code>. По-друге, ви можете помітити, що цей клас <code>Particle</code> не робить більше нічого корисного, окрім збереження посилання на об’єкт <code>VerletParticle2D</code>. Це натякає на щось важливе. Пригадайте обговорення про наслідування у <a href="/particles#section-particles">Розділі 4</a>, а потім запитайте себе: що таке об’єкт <code>Particle</code>, як не “доповнений” об’єкт <code>VerletParticle2D</code>? Навіщо створювати два об’єкти — <code>Particle</code> і <code>VerletParticle2D</code> — для кожної окремої частинки у світі, коли я можу просто розширити клас <code>VerletParticle2D</code>, щоб включити додатковий код для малювання частинки?</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">VerletParticle2D</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">super</span>(x, y);
</code></pre><div class="comment"><p>Викл ик методу super() з xy-значеннями для правильної ініціалізації об’єкта.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;
</code></pre><div class="comment"><p>Додавання змінної для збереження радіуса.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Доповнення класу за рахунок методу show().</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p>x і y з VerletParticle2D!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Крім того, насправді клас <code>VerletParticle2D</code> є підкласом <code>Vec2D</code>. Це означає, що крім успадкування всього від <code>VerletParticle2D</code>, клас <code>Particle</code> також успадкував і усі методи класу <code>Vec2D</code>!</p>
<p>Тепер я можу створювати нові частинки:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>, <span class="hljs-number">8</span>);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Однак просто створити частинку недостатньо. Подібно до Matter.js, нам потрібно явно додати нову частинку до світу. У Toxiclibs.js це робиться за допомогою методу <code>addParticle()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">physics.<span class="hljs-title function_">addParticle</span>(particle);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо ви подивитеся на документацію Toxiclibs.js, то побачите, що метод <code>addParticle()</code> очікує об’єкт <code>VerletParticle2D</code>. Але я передав йому об’єкт <code>Particle</code>. Чи це спрацює?</p>
<p>Так! Пригадайте один із принципів ООП, а саме поліморфізм. Оскільки тут клас <code>Particle</code> розширює клас <code>VerletParticle2D</code>, я можу розглядати частинку двома різними способами — як <code>Particle</code> або як <code>VerletParticle2D</code>. Це неймовірно потужна особливість ООП. Якщо ви створюєте власні класи, які наслідують класи Toxiclibs.js, то можете використовувати об’єкти цих класів у поєднанні з усіма методами, які пропонує Toxiclibs.js.</p>
<h3 id="springs"><a class="heading-link" href="#springs">Пружини</a></h3>
<p>Окрім класу <code>VerletParticle2D</code>, Toxiclibs.js має набір класів, які дозволяють з’єднувати частинки за допомогою пружинних сил. У Toxiclibs.js є три види пружин:</p>
<ul>
  <li><code>VerletSpring2D</code>: пружне з’єднання між двома частинками. Властивості пружини можна налаштувати таким чином, щоб створити жорстке палицеподібне або дуже еластичне з’єднання, що розтягується. Частинку також можна зафіксувати, щоб рухався лише один кінець пружини.</li>
  <li><code>VerletConstrainedSpring2D</code>: пружина, максимальна відстань якої може бути обмежена. Це може допомогти всій системі пружин досягти кращої стабільності.</li>
  <li><code>VerletMinDistanceSpring2D</code>: пружина, яка відновлює свою довжину спокою, лише якщо поточна відстань менша за її довжину спокою. Це зручно, якщо ви хочете забезпечити між об’єктами пев ну відстань, але вас не хвилює, якщо відстань перевищуватиме встановлений мінімум.</li>
</ul>
<p>Наслідування і поліморфізм знову виявилися корисними при створенні пружин. Конструктор пружини потребує два об’єкти типу <code>VerletParticle2D</code>, але як і раніше, тут підійдуть і два об’єкти <code>Particle</code>, оскільки вони є розширенням класу <strong><em> </em></strong><code>VerletParticle2D</code>.</p>
<p>Ось приклад коду для створення пружини. Цей фрагмент припускає існування двох частинок, <code>particle1</code> і <code>particle2</code>, та створює зв’язок між ними із заданою довжиною спокою та міцністю:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> length = <span class="hljs-number">80</span>;
</code></pre><div class="comment"><p>Довжина пружини у спокої.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> strength = <span class="hljs-number">0.01</span>;
</code></pre><div class="comment"><p>Міцність пружини. Чим вище значення, тим жорсткіша пружина.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> spring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletSpring2D</span>(particle1, particle2, length, strength);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Як і з частинками, щоб з’єднання було частиною світу фізики, його необхідно явно додати до цього світу:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">physics.<span class="hljs-title function_">addSpring</span>(spring);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я вже маю майже все, що мені потрібно для створення простого першого прикладу з Toxiclibs.js: дві частинки, з’єднані в пружинний маятник. Однак я хочу додати ще один елемент: взаємодію з курсором.</p>
<p>На прикладі з Matter.js я пояснив, що фізична симуляція ламається, якщо ви вручну переписуєте положення тіла, налаштовуючи його на положення курсора. З Toxiclibs.js такої проблеми немає. Якщо я хочу, я можу встановити положення частинки <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span></span></span></span></span> вручну. Однак перед тим, як це зробити, зазвичай гарною ідеєю буде викликати метод частинки <code>lock()</code>, який фіксує частинку на місці. Це ідентично встановленню властивості <code>isStatic</code> до значення <code>true</code> у Matter.js.</p>
<p>Ідея полягає в тому, щоб тимчасово заблокувати частинку, щоб вона припинила реагувати на фізику світу і змінила своє положення, а потім була розблокована за допомогою методу <code>unlock()</code> і могла знову рухатися з нового місця. Наприклад, розглянемо сценарій, коли я хочу змінювати положення частинки щоразу, коли натискаю кнопку мишки:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (mouseIsPressed) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    particle1.<span class="hljs-title function_">lock</span>();
    particle1.<span class="hljs-property">x</span> = mouseX;
    particle1.<span class="hljs-property">y</span> = mouseY;
    particle1.<span class="hljs-title function_">unlock</span>();
</code></pre><div class="comment"><p>Спершу заблокуємо частинку, потім встановимо нові значення для x і y та розблокуємо її методом unlock().</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>І з цими знаннями я готовий об’єднати всі потрібні елементи в просту програму із двома частинками, з’єднаними пружиною. Одна частинка буде перманентно зафіксована на місці, а іншу можна буде переміщувати, перетягуючи мишкою. Цей приклад практично ідентичний прикладу 3.11 із <a href="/oscillation#section-oscillation">Розділу 3</a>.</p>
<div data-type="example">
  <h3 id="example-611-simple-spring-with-toxiclibsjs"><a class="heading-link" href="#example-611-simple-spring-with-toxiclibsjs">Приклад 6.11: Проста пружина з Toxiclibs.js</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_11_simple_spring_with_toxiclibs"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/CSzXIfoWH" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Vec2D</span>, <span class="hljs-title class_">Rect</span> } = toxi.<span class="hljs-property">geom</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">VerletPhysics2D</span>, <span class="hljs-title class_">VerletParticle2D</span>, <span class="hljs-title class_">VerletSpring2D</span> } = toxi.<span class="hljs-property">physics2d</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">GravityBehavior</span> } = toxi.<span class="hljs-property">physics2d</span>.<span class="hljs-property">behaviors</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> physics;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particle1, particle2;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletPhysics2D</span>();
  physics.<span class="hljs-title function_">setWorldBounds</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height));
  physics.<span class="hljs-title function_">addBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GravityBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vec2D</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>)));
</code></pre><div class="comment"><p>Створення світу фізики з Toxiclibs.js.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> length = <span class="hljs-number">120</span>;
</code></pre><div class="comment"><p>Довжина пружини у спокої.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  particle1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);
  particle2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(width / <span class="hljs-number">2</span> + length, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);
</code></pre><div class="comment"><p>Створення двох частинок.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  particle1.<span class="hljs-title function_">lock</span>();
</code></pre><div class="comment"><p>Фіксація однієї частинки на місці.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> spring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletSpring2D</span>(particle1, particle2, length, <span class="hljs-number">0.01</span>);
</code></pre><div class="comment"><p>Створення однієї пружини.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">addParticle</span>(particle1);
  physics.<span class="hljs-title function_">addParticle</span>(particle2);
  physics.<span class="hljs-title function_">addSpring</span>(spring);
</code></pre><div class="comment"><p>Додавання всіх елементів до світу фізики.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p>Оновлення фізики.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">line</span>(particle1.<span class="hljs-property">x</span>, particle1.<span class="hljs-property">y</span>, particle2.<span class="hljs-property">x</span>, particle2.<span class="hljs-property">y</span>);
  particle1.<span class="hljs-title function_">show</span>();
  particle2.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Малювання усіх потрібних елементів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (mouseIsPressed) {
    particle2.<span class="hljs-title function_">lock</span>();
    particle2.<span class="hljs-property">x</span> = mouseX;
    particle2.<span class="hljs-property">y</span> = mouseY;
    particle2.<span class="hljs-title function_">unlock</span>();
  }
</code></pre><div class="comment"><p>Переміщення частинки за допомогою мишки.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">VerletParticle2D</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
    <span class="hljs-variable language_">super</span>(x, y);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;
  }
</code></pre><div class="comment"><p>Чи не гарно виглядає цей простий клас Particle?</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У цьому прикладі я продовжую зображати пружину, яка з’єднує частинки, у вигляді лінії. Однак майте на увазі, що пружин на поведінка існує незалежно від того чи ви малюєте її, чи ні. Це може відкрити певні творчі можливості. Наприклад, ви можете вирішити зробити пружину невидимою або зобразити її зовсім інакше, можливо, у вигляді послідовних точок або у вигляді якоїсь вашої власної форми.</p>
<h2 id="soft-body-simulations"><a class="heading-link" href="#soft-body-simulations">Симуляції м’яких тіл</a></h2>
<p>Фізика Верле особливо добре підходить для жанру комп’ютерної графіки, відомого як симуляція м’яких тіл. На відміну від симуляції <strong>твердих тіл</strong> у Matter.js, де об’єкти з жорсткими краями зіштовхуються один з одним і зберігають свою форму, симуляції <strong>м’яких тіл</strong> включають об’єкти, які можуть деформуватися та змінювати свою форму під впливом фізики. М’які тіла дозволяють більш гнучкі, плавні й органічні рухи. Вони можуть розтягуватися, стискатися та похитуватися у відповідь на різні сили й зіткнення і вони виглядають... м’якими.</p>
<p>Одним із перших популярних прикладів фізики м’яких тіл був у грі <em>SodaConstructor</em>, створеній на початку 2000-х років. Гравці могли конструювати й анімувати власні 2D створіння, побудовані із мас та пружин. Інші приклади за ці роки включали такі ігри як <em>LocoRoco</em>, <em>World of Goo</em>, і трохи новіша <em>JellyCar</em>.</p>
<p>Основними будівельними блоками симуляції м’яких тіл є частинки, з’єднані пружинами — так само як пара частинок у прикладі 6.11. На малюнку 6.13 показано, як налаштувати мережу з’єднань частинок-пружинок для створення різних форм.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1121.9999999999998&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/ca7cca384d1ff964e7f0516bb33f6dd3/09555/06_libraries_15.webp 576w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/56181/06_libraries_15.webp 1152w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/4ba7f/06_libraries_15.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/ca7cca384d1ff964e7f0516bb33f6dd3/3c48c/06_libraries_15.png" data-srcset="./static/ca7cca384d1ff964e7f0516bb33f6dd3/853c9/06_libraries_15.png 576w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/4f92b/06_libraries_15.png 1152w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/3c48c/06_libraries_15.png 2304w" alt="Малюнок 6.13: Моделювання м’якого тіла"/></picture><noscript><picture><source type="image/webp" srcSet="./static/ca7cca384d1ff964e7f0516bb33f6dd3/09555/06_libraries_15.webp 576w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/56181/06_libraries_15.webp 1152w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/4ba7f/06_libraries_15.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/ca7cca384d1ff964e7f0516bb33f6dd3/3c48c/06_libraries_15.png" srcSet="./static/ca7cca384d1ff964e7f0516bb33f6dd3/853c9/06_libraries_15.png 576w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/4f92b/06_libraries_15.png 1152w,./static/ca7cca384d1ff964e7f0516bb33f6dd3/3c48c/06_libraries_15.png 2304w" alt="Малюнок 6.13: Моделювання м’якого тіла"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.13: Моделювання м’якого тіла</figcaption>
</figure>
<div class="avoid-break">
  <p>Як показано на малюнку, ланцюжок можна імітувати, з’єднавши лінію частинок із пружинами. Ковдру можна імітувати, з’єднавши сітку частинок із пружинами. А милий, приємний, м’який мультяшний персонаж може бути імітований за до помогою власного розташування набору частинок, з’єднаних пружинами. Перехід від одного до іншого варіанту нескладна справа.</p>
</div>
<h3 id="a-string"><a class="heading-link" href="#a-string">Ланцюжок</a></h3>
<p>Я почну із симуляції <em>м’якого маятника</em> — підвісу, що висить на гнучкому ланцюжку замість жорсткого плеча. Toxiclibs.js має зручний клас <code>ParticleString2D</code>, який створює рядок частинок, з’єднаних пружинами. Однак для демонстрації я створю власний рядок частинок за допомогою масиву і циклу <code>for</code>. Таким чином ви отримаєте глибше розуміння системи, що дозволить вам у майбутньому створювати власні нестандартні конструкції, окрім одинарного рядка.</p>
<p>Спочатку мені потрібен масив частинок. Я буду використовувати той самий клас <code>Particle</code>, створений у прикладі 6.11:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particles = [];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер, припустимо, що я хочу отримати 20 частинок, розташованих одна від одної на відстані 10 пікселів, як на малюнку 6.14.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;350&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/3c9de7f4ef69f4d9940d893077fdf54f/a534c/06_libraries_16.webp 576w,./static/3c9de7f4ef69f4d9940d893077fdf54f/97e3a/06_libraries_16.webp 1152w,./static/3c9de7f4ef69f4d9940d893077fdf54f/b1b96/06_libraries_16.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/3c9de7f4ef69f4d9940d893077fdf54f/48471/06_libraries_16.png" data-srcset="./static/3c9de7f4ef69f4d9940d893077fdf54f/9e251/06_libraries_16.png 576w,./static/3c9de7f4ef69f4d9940d893077fdf54f/a6342/06_libraries_16.png 1152w,./static/3c9de7f4ef69f4d9940d893077fdf54f/48471/06_libraries_16.png 2304w" alt="Малюнок 6.14: Двадцять частинок, розташованих одна від одної на відстані 10 пікселів"/></picture><noscript><picture><source type="image/webp" srcSet="./static/3c9de7f4ef69f4d9940d893077fdf54f/a534c/06_libraries_16.webp 576w,./static/3c9de7f4ef69f4d9940d893077fdf54f/97e3a/06_libraries_16.webp 1152w,./static/3c9de7f4ef69f4d9940d893077fdf54f/b1b96/06_libraries_16.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/3c9de7f4ef69f4d9940d893077fdf54f/48471/06_libraries_16.png" srcSet="./static/3c9de7f4ef69f4d9940d893077fdf54f/9e251/06_libraries_16.png 576w,./static/3c9de7f4ef69f4d9940d893077fdf54f/a6342/06_libraries_16.png 1152w,./static/3c9de7f4ef69f4d9940d893077fdf54f/48471/06_libraries_16.png 2304w" alt="Малюнок 6.14: Двадцять частинок, розташованих одна від одної на відстані 10 пікселів"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.14: Двадцять частинок, розташованих одна від одної на відстані 10 пікселів</figcaption>
</figure>
<p>Я можу пройтися циклом від <code>i</code>, що початково дорівнює <code>0</code>, до значення <code>total</code>, створюючи нові частинки й встановлюючи для кожної позицію <code>y</code> рівну значенню <code>i * 10</code>. Таким чином перша частинка буде знаходитися на позиції <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></span>, друга матиме координати <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,20)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">20</span><span class="mclose">)</span></span></span></span></span>, третя — <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>30</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,30)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">30</span><span class="mclose">)</span></span></span></span></span> і так далі:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> particle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(i * length, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>);
</code></pre><div class="comment"><p>Розташуємо частинки вздовж x-вісі.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">addParticle</span>(particle);
</code></pre><div class="comment"><p>Додамо частинку до світу фізики.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  particles.<span class="hljs-title function_">push</span>(particle);
</code></pre><div class="comment"><p>Додамо частинку до масиву.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Попри те, що це зайве, я додаю частинки як до світу Toxiclibs.js <code>physics</code>, так і до масиву <code>particles</code>. Це допоможе мені керувати програмою (особливо у випадку, коли може бути більше одного ланцюжка частинок).</p>
<p>Тепер найцікавіше: час з’єднати всі частинки. Частинка з індексом 0 повинна бути з’єднана з частинкою під індексом 1, частинка з індексом 1 — з частинкою під індексом 2, 2 з 3, 3 з 4 і так далі (див. малюнок 6.15).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;293&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/e74dadfa1aa5ae47208b492178ebf11f/c7872/06_libraries_17.webp 576w,./static/e74dadfa1aa5ae47208b492178ebf11f/c44f7/06_libraries_17.webp 1152w,./static/e74dadfa1aa5ae47208b492178ebf11f/508c4/06_libraries_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/e74dadfa1aa5ae47208b492178ebf11f/f5cb7/06_libraries_17.png" data-srcset="./static/e74dadfa1aa5ae47208b492178ebf11f/c8337/06_libraries_17.png 576w,./static/e74dadfa1aa5ae47208b492178ebf11f/601dd/06_libraries_17.png 1152w,./static/e74dadfa1aa5ae47208b492178ebf11f/f5cb7/06_libraries_17.png 2304w" alt="Малюнок 6.15: Кожна частинка з’єднана з наступною частинкою масиву"/></picture><noscript><picture><source type="image/webp" srcSet="./static/e74dadfa1aa5ae47208b492178ebf11f/c7872/06_libraries_17.webp 576w,./static/e74dadfa1aa5ae47208b492178ebf11f/c44f7/06_libraries_17.webp 1152w,./static/e74dadfa1aa5ae47208b492178ebf11f/508c4/06_libraries_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/e74dadfa1aa5ae47208b492178ebf11f/f5cb7/06_libraries_17.png" srcSet="./static/e74dadfa1aa5ae47208b492178ebf11f/c8337/06_libraries_17.png 576w,./static/e74dadfa1aa5ae47208b492178ebf11f/601dd/06_libraries_17.png 1152w,./static/e74dadfa1aa5ae47208b492178ebf11f/f5cb7/06_libraries_17.png 2304w" alt="Малюнок 6.15: Кожна час тинка з’єднана з наступною частинкою масиву"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.15: Кожна частинка з’єднана з наступною частинкою масиву</figcaption>
</figure>
<p>Іншими словами, частинку <code>i</code> потрібно з’єднати з частинкою <code>i+1</code> (окрім випадку, коли <code>i</code> представляє останній елемент масиву):</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total - <span class="hljs-number">1</span>; i++) {
</code></pre><div class="comment"><p>Цикл зупиняється перед останнім елементом (total – 1).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> spring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletSpring2D</span>(particles[i], particles[i + <span class="hljs-number">1</span>], spacing, <span class="hljs-number">0.01</span>);
</code></pre><div class="comment"><p>Пружина з’єднує частинку i з частинкою i + 1.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">addSpring</span>(spring);
</code></pre><div class="comment"><p>Пружину також потрібно додати до світу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>А що, якщо я хочу, щоб ланцюжок звисав із фіксованої точки? Я можу зафіксувати одну з частинок, можливо першу, останню чи середню. Я виберу першу:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">particles[<span class="hljs-number">0</span>].<span class="hljs-title function_">lock</span>();
</code></pre><div class="comment"><p></p></div></div></div>
<p>Нарешті, мені потрібно намалювати частинки. Однак, замість того, щоб малювати їх як кружечки, я хочу розглядати їх як точки на лінії. Для цього я можу використати функції <code>beginShape()</code>, <code>endShape()</code> і <code>vertex()</code>, отримуючи доступ до окремих позицій частинок із масиву. Я використаю метод <code>show()</code> лише для малювання останньої частинки у вигляді кола, створюючи підвіс на кінці ланцюжка.</p>
<div data-type="example">
  <h3 id="example-612-soft-swinging-pendulum"><a class="heading-link" href="#example-612-soft-swinging-pendulum">Приклад 6.12: М’який коливальний маятник</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_12_soft_string"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/cIygo3QeX" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">noFill</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">beginShape</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> particle <span class="hljs-keyword">of</span> particles) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">vertex</span>(particle.<span class="hljs-property">x</span>, particle.<span class="hljs-property">y</span>);
</code></pre><div class="comment"><p>Кожна частинка представляє одну вершину ланцюжка.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">endShape</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  particles[particles.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Остання частинка малюється як круг.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Повний код доступний на вебсайті книги й також демонструє, як перетягувати частинку тягарця за допомогою мишки.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-610"><a class="heading-link" href="#exercise-610">Вправа 6.10</a></h3>
  <p>Створіть симуляцію висячої тканини з використанням частинок і пружин. Вам потрібно з’єднати кожну частинку з її вертикальними й горизонтальними сусідами.</p>
  <figure data-type="example">
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/exercise_6_13_cloth_simulation"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/x3FXo0wNZ" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<h3 id="a-soft-body-character"><a class="heading-link" href="#a-soft-body-character">Персонаж із м’яким тілом</a></h3>
<p>Тепер, коли я побудував просту зв’язану систему — ланцюжок частинок — я розширю цю ідею, щоб створити у p5.js м’якого, милого персонажа, інакше кажучи, <strong>персонажа із м’яки м тілом</strong>. Першим кроком буде створення “скелету” з’єднаних частинок. Я почну з дуже простого дизайну лише з шістьма вершинами, як показано на малюнку 6.16. Кожна вершина (намальована як крапка) представляє об’єкт <code>Particle</code>, а кожне з’єднання (намальоване як лінія) представляє об’єкт <code>Spring</code>.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2302px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;821&#x27; width=&#x27;2302&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/fd690cf3242a6030e14a18b6fd4a42dc/ae922/06_libraries_18.webp 576w,./static/fd690cf3242a6030e14a18b6fd4a42dc/54fa8/06_libraries_18.webp 1151w,./static/fd690cf3242a6030e14a18b6fd4a42dc/3f656/06_libraries_18.webp 2302w" sizes="(min-width: 2302px) 2302px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2302px) 2302px, 100vw" decoding="async" loading="lazy" data-src="./static/fd690cf3242a6030e14a18b6fd4a42dc/e212f/06_libraries_18.png" data-srcset="./static/fd690cf3242a6030e14a18b6fd4a42dc/0c33b/06_libraries_18.png 576w,./static/fd690cf3242a6030e14a18b6fd4a42dc/203c1/06_libraries_18.png 1151w,./static/fd690cf3242a6030e14a18b6fd4a42dc/e212f/06_libraries_18.png 2302w" alt="Малюнок 6.16: Скелет персонажа з м’яким тілом. Вершини прону меровані відповідно до їх позицій у масиві"/></picture><noscript><picture><source type="image/webp" srcSet="./static/fd690cf3242a6030e14a18b6fd4a42dc/ae922/06_libraries_18.webp 576w,./static/fd690cf3242a6030e14a18b6fd4a42dc/54fa8/06_libraries_18.webp 1151w,./static/fd690cf3242a6030e14a18b6fd4a42dc/3f656/06_libraries_18.webp 2302w" sizes="(min-width: 2302px) 2302px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2302px) 2302px, 100vw" decoding="async" loading="lazy" src="./static/fd690cf3242a6030e14a18b6fd4a42dc/e212f/06_libraries_18.png" srcSet="./static/fd690cf3242a6030e14a18b6fd4a42dc/0c33b/06_libraries_18.png 576w,./static/fd690cf3242a6030e14a18b6fd4a42dc/203c1/06_libraries_18.png 1151w,./static/fd690cf3242a6030e14a18b6fd4a42dc/e212f/06_libraries_18.png 2302w" alt="Малюнок 6.16: Скелет персонажа з м’яким тілом. Вершини пронумеровані відповідно до їх позицій у масиві"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.16: Скелет персонажа з м’яким тілом. Вершини пронумеровані відповідно до їх позицій у масиві</figcaption>
</figure>
<p>Створення частинок — це легка частина і виконується точно т ак само, як і раніше! Однак я хочу внести одну зміну. Замість того, щоб функція <code>setup()</code> додавала частинки й пружини до світу фізики, я віднесу цю відповідальність до конструктора <code>Particle</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">VerletParticle2D</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">super</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    physics.<span class="hljs-title function_">addParticle</span>(<span class="hljs-variable language_">this</span>);
</code></pre><div class="comment"><p>Додавання об’єкта до глобального світу фізики. Всередині класу посилання на поточний об’єкт відбувається через ключове слово this.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Хоча це не обов’язково, я також хочу створити клас <code>Spring</code>, який успадкує свою функціональність від <code>VerletSpring2D</code>. Для цього прикладу я хочу, щоб довжина пружини у спокої завжди дорівнювала відстані між частинками скелета на момент їх створення. Крім того, для простоти, я захардкодив у конструкторі <code>Spring</code> значення для міцності рівне <code>0.01</code> . Можливо ви захочете покращити приклад за допомогою складнішого дизайну, де різні частини м’якого тіла матимуть різний ступінь пружності:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spring</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">VerletSpring2D</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a, b</span>) {
</code></pre><div class="comment"><p>У якості аргументів конструктор отримує дві частинки.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> length = <span class="hljs-title function_">dist</span>(a.<span class="hljs-property">x</span>, a.<span class="hljs-property">y</span>, b.<span class="hljs-property">x</span>, b.<span class="hljs-property">y</span>);
</code></pre><div class="comment"><p>Обчислення довжини спокою, що рівна відстані між частинками.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">super</span>(a, b, length, <span class="hljs-number">0.01</span>);
</code></pre><div class="comment"><p>Жорстке кодування пружності пружини.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    physics.<span class="hljs-title function_">addSpring</span>(<span class="hljs-variable language_">this</span>);
</code></pre><div class="comment"><p>Ще одне покращення полягає в тому, що об’єкт самостійно додається у загальний світ!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер, коли у мене є класи <code>Particle</code> і <code>Spring</code>, я можу зібрати персонажа, додавши серію частинок із жорстко закодованими початковими позиціями до масиву <code>particles</code> і серію пружинних з’єднань до масиву <code>springs</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particles = [];
<span class="hljs-keyword">let</span> springs = [];
</code></pre><div class="comment"><p>Збереження всіх частинок і пружин у масивах.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletPhysics2D</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">200</span>, <span class="hljs-number">25</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">400</span>, <span class="hljs-number">25</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">350</span>, <span class="hljs-number">125</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">400</span>, <span class="hljs-number">225</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">200</span>, <span class="hljs-number">225</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">250</span>, <span class="hljs-number">125</span>));
</code></pre><div class="comment"><p>Створення положень вершин персонажа, використовуючи частинки.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">0</span>], particles[<span class="hljs-number">1</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">1</span>], particles[<span class="hljs-number">2</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">2</span>], particles[<span class="hljs-number">3</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">3</span>], particles[<span class="hljs-number">4</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">4</span>], particles[<span class="hljs-number">5</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">5</span>], particles[<span class="hljs-number">0</span>]));
</code></pre><div class="comment"><p>З’єднання вершин за допомогою пружин.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Краса цієї системи полягає в тому, що ви можете легко її розширити, щоб створити власний дизайн, додавши більше частинок і пружин! Однак тут є одна серйозна проблема: я встановив зв’язки лише по периметру персонажа. Якби я застосував силу (наприклад, гравітацію) до тіла, воно б миттєво обвалилося. Саме тут у гру вступають додаткові внутрішні пружини, як показано на малюнку 6.17. Вони утримують структуру персонажа стабільною, дозволяюч и йому водночас рухатися і похитуватися реалістичним чином.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2302px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;821&#x27; width=&#x27;2302&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4fc5386ea0368a6658737f7cd553f548/ae922/06_libraries_19.webp 576w,./static/4fc5386ea0368a6658737f7cd553f548/54fa8/06_libraries_19.webp 1151w,./static/4fc5386ea0368a6658737f7cd553f548/3f656/06_libraries_19.webp 2302w" sizes="(min-width: 2302px) 2302px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2302px) 2302px, 100vw" decoding="async" loading="lazy" data-src="./static/4fc5386ea0368a6658737f7cd553f548/e212f/06_libraries_19.png" data-srcset="./static/4fc5386ea0368a6658737f7cd553f548/0c33b/06_libraries_19.png 576w,./static/4fc5386ea0368a6658737f7cd553f548/203c1/06_libraries_19.png 1151w,./static/4fc5386ea0368a6658737f7cd553f548/e212f/06_libraries_19.png 2302w" alt="Малюнок 6.17: Внутрішні пружини утримують конструкцію від колапсу. Це лише один із можливих дизайнів"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4fc5386ea0368a6658737f7cd553f548/ae922/06_libraries_19.webp 576w,./static/4fc5386ea0368a6658737f7cd553f548/54fa8/06_libraries_19.webp 1151w,./static/4fc5386ea0368a6658737f7cd553f548/3f656/06_libraries_19.webp 2302w" sizes="(min-width: 2302px) 2302px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2302px) 2302px, 100vw" decoding="async" loading="lazy" src="./static/4fc5386ea0368a6658737f7cd553f548/e212f/06_libraries_19.png" srcSet="./static/4fc5386ea0368a6658737f7cd553f548/0c33b/06_libraries_19.png 576w,./static/4fc5386ea0368a6658737f7cd553f548/203c1/06_libraries_19.png 1151w,./static/4fc5386ea0368a6658737f7cd553f548/e212f/06_libraries_19.png 2302w" alt="Малюнок 6.17: Внутрішні пружини утримують конструкцію від колапсу. Це лише один із можливих дизайнів"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.17: Внутрішні пружини утримують конструкцію від колапсу. Це лише один із можливих дизайнів. Спробуйте інші!</figcaption>
</figure>
<p>Останній приклад включає додаткові пружини з малюнку 6.17, силу гравітації та взаємодію з мишкою.</p>
<div data-type="example">
  <h3 id="example-613-soft-body-character"><a class="heading-link" href="#example-613-soft-body-character">Приклад 6.13: Персонаж із м’яким тілом</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/soft_body_character_copy"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/-1beeiwUK" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> physics;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particles = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> springs = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletPhysics2D</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">setWorldBounds</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height));
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">addBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GravityBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vec2D</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>)));
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">200</span>, <span class="hljs-number">25</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">400</span>, <span class="hljs-number">25</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">350</span>, <span class="hljs-number">125</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">400</span>, <span class="hljs-number">225</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">200</span>, <span class="hljs-number">225</span>));
  particles.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">250</span>, <span class="hljs-number">125</span>));
</code></pre><div class="comment"><p>Частинки-вершини персонажа.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">0</span>], particles[<span class="hljs-number">1</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">1</span>], particles[<span class="hljs-number">2</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">2</span>], particles[<span class="hljs-number">3</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">3</span>], particles[<span class="hljs-number">4</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">4</span>], particles[<span class="hljs-number">5</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">5</span>], particles[<span class="hljs-number">0</span>]));
</code></pre><div class="comment"><p>Пружини, що з’єднують вершини персонажа.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">5</span>], particles[<span class="hljs-number">2</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">0</span>], particles[<span class="hljs-number">3</span>]));
  springs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Spring</span>(particles[<span class="hljs-number">1</span>], particles[<span class="hljs-number">4</span>]));
</code></pre><div class="comment"><p>Три внутрішні пружини!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
  <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">beginShape</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> particle <span class="hljs-keyword">of</span> particles) {
    <span class="hljs-title function_">vertex</span>(particle.<span class="hljs-property">x</span>, particle.<span class="hljs-property">y</span>);
  }
  <span class="hljs-title function_">endShape</span>(<span class="hljs-variable constant_">CLOSE</span>);
</code></pre><div class="comment"><p>Малювання персонажа у вигляді однієї форми.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (mouseIsPressed) {
    particles[<span class="hljs-number">0</span>].<span class="hljs-title function_">lock</span>();
    particles[<span class="hljs-number">0</span>].<span class="hljs-property">x</span> = mouseX;
    particles[<span class="hljs-number">0</span>].<span class="hljs-property">y</span> = mouseY;
    particles[<span class="hljs-number">0</span>].<span class="hljs-title function_">unlock</span>();
  }
</code></pre><div class="comment"><p>Взаємодія з мишкою.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У прикладі персонажа з м’яким тілом ви помітите, що я більше не малюю на полотні всі елементи фізичної симуляції! Метод частинок <code>show()</code> не викликається, а внутрішні пружини, які надають персонажу структуру, не відображаються лініями. Насправді самі пружини більше не використовуються після функції <code>setup()</code>, оскільки форма персонажа побудована на основі позицій його частинок. Таким чином, у цьому прикладі масив пружин не є обов’язковим, хоча я вважаю його корисним, оскільки він може знадобитися для покращення програми в майбутньому.</p>
<p>Розглядаючи малювання як окрему задачу, відокремлену від структури скелета персонажа, ви також відкриваєте можливості для додавання інших елементів дизайну, таких як очі чи вусики. Подібні творчі вдосконалення не обов’язково мають бути пов’язані з фізикою персонажа, хоча вони можуть бути такими, якщо ви вирішите це зробити!</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-611"><a class="heading-link" href="#exercise-611">Вправа 6.11</a></h3>
  <p>Розробіть власного персонажа із м’яким тілом, додатковими вершинами та зв’язками. Які ще елементи дизайну можна додати? Які інші сили та взаємодії ви можете включити?</p>
  <figure data-type="example">
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/exercise_6_11_soft_body_character_enhanced"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/hQw1Ih97c" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<h3 id="a-force-directed-graph"><a class="heading-link" href="#a-force-directed-graph">Силові алгоритми візуалізації графів</a></h3>
<p>Вам коли-небудь спадала наступна думка: “У мене є ціла купа речей, які я хочу намалювати і я хочу, щоб усі ці речі були рівномірно розподілені гарним, акуратним, організованим способом. Або інакше я вночі не зможу спокійно спати”?</p>
<p>Ця проблема досить поширена в обчислювальному дизайні. Одним з рішень є <strong>силові алгоритми візуалізації графів</strong> — візуалізація елементів, назвемо їх <em>нодами</em> (вузлами), де їх положення не призначаються вручну. Натомість вони розташовуються відповідно до набору сил. Хоча можна використовувати будь-які сили, класичний підхід включає пружинні сили: кожен вузол з’єднаний з кожним іншим вузлом за допомогою пружини, так що коли вони досягають рівноваги, то вузли розташовуються рівномірно і ребра мають більш-менш однакову довжину (див. малюнок 6.18). Звучить як робота для Toxiclibs.js!</p>
<figure data-type="example">
  <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/figure_6_18"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/0RqAtTXwI" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
  <figcaption>Малюнок 6.18: Приклад візуалізації, де кластери частинок з’єднані пружинними силами</figcaption>
</figure>
<p>Щоб створити приклад силового алгоритму візуалізації графу, мені спочатку знадобиться клас для опису окремого вузла в системі. Оскільки термін <em>нода</em> асоціюється із JavaScript-платформою Node.js, я продовжу з терміном <em>частинка</em>, щоб уникнути будь-якої плутанини й продовжу використовувати свій клас <code>Particle</code> із попередніх прикладів м’яких тіл.</p>
<p>Далі я інкапсулюю список з <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> частинок у новий клас під назвою <code>Cluster</code>, який представлятиме граф у цілому. Усі частинки спочатку будуть розташовані біля центру полотна:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cluster</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">n, length</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">particles</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</code></pre><div class="comment"><p>Кластер ініціалізується N вузлами.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> x = width / <span class="hljs-number">2</span> + <span class="hljs-title function_">random</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">let</span> y = height / <span class="hljs-number">2</span> + <span class="hljs-title function_">random</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">particles</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(x, y, <span class="hljs-number">4</span>));
</code></pre><div class="comment"><p>Цікавий нюанс. Фізика буде поводитись неправильно,
якщо всі частинки будуть створені в абсолютно однаковому положенні.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Припустімо, що у класі <code>Cluster</code> також є метод <code>show()</code> для малювання всіх частинок кластера і що я створю новий об’єкт <code>Cluster</code> у фу нкції <code>setup()</code> та відображу його у функції <code>draw()</code>. Якщо запустити програму в поточному стані нічого не відбудеться. Чому? Тому що мені ще належить реалізувати всю частину силового алгоритму графа! Мені потрібно з’єднати кожен вузол з кожним іншим вузлом за допомогою пружини. Це дещо схоже на створення персонажа із м’яким тілом, але замість того, щоб створювати скелет вручну, я хочу написати алгоритм для автоматичного створення всіх зв’язків.</p>
<p>Що саме я маю на увазі? Скажімо, є п’ять об’єктів <code>Particle</code>: 0, 1, 2, 3 і 4. На малюнку 6.19 показано їх зв’язки.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1061&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d0e8f9a1e2d0bd5160f2229b5495c34c/b780d/06_libraries_20.webp 576w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/34363/06_libraries_20.webp 1152w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/5feca/06_libraries_20.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/d0e8f9a1e2d0bd5160f2229b5495c34c/98e62/06_libraries_20.png" data-srcset="./static/d0e8f9a1e2d0bd5160f2229b5495c34c/c0a7c/06_libraries_20.png 576w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/2ddf9/06_libraries_20.png 1152w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/98e62/06_libraries_20.png 2304w" alt="Малюнок 6.19: зв’язний граф, що показує кожен із п’яти вузлів, з’єднаних з кожним іншим вузлом"/></picture><noscript><picture><source type="image/webp" srcSet="./static/d0e8f9a1e2d0bd5160f2229b5495c34c/b780d/06_libraries_20.webp 576w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/34363/06_libraries_20.webp 1152w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/5feca/06_libraries_20.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/d0e8f9a1e2d0bd5160f2229b5495c34c/98e62/06_libraries_20.png" srcSet="./static/d0e8f9a1e2d0bd5160f2229b5495c34c/c0a7c/06_libraries_20.png 576w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/2ddf9/06_libraries_20.png 1152w,./static/d0e8f9a1e2d0bd5160f2229b5495c34c/98e62/06_libraries_20.png 2304w" alt="Малюнок 6.19: зв’язний граф, що показує кожен із п’яти вузлів, з’єднаних з кожним іншим вузлом"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 6.19: Зв’язний граф, що показує кожен із п’яти вузлів, з’єднаних з кожним іншим вузлом</figcaption>
</figure>
<p>Зверніть увагу на дві важливі деталі щодо списку зв’язків:</p>
<ul>
  <li><strong>Жодна частинка не пов’язана сама із собою.</strong> Тобто 0 не пов’язаний з 0, 1 не пов’язаний з 1 і так далі.</li>
  <li><strong>З’єднання не повторюються у зворотному порядку.</strong> Наприклад, якщо 0 пов’язано з 1, мені не потрібно явно говорити, що 1 також пов’язано з 0.</li>
</ul>
<p>Як написати код для створення таких з’єднань для <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span> частинок? Подивіться на чотири стовпці, зображені на малюнку 6.19. Вони повторюють усі з’єднання, починаючи з частинки 0 до 4. Це означає, що мені потрібно отримати доступ до кожної частинки у списку від <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span> до <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>:</p>
<div class="snip-below avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">particles</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> particle_i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">particles</span>[i];
</code></pre><div class="comment"><p>Використання змінної particle_i для збереження посилання на частинку.</p></div></div></div>
</div>
<p>Тепер подивіться на з’єднання, зображені на малюнку 6.19. Мені потрібно з’єднати вузол 0 із вузлами 1, 2, 3 і 4. Вузол 1 із вузлами 2, 3 і 4. Вузол 2 із вузлами 3 і 4. Вузол 3 тільки із вузлом 4. Загалом, для кожного вузла <code>i</code> мені потрібно пройтися від <code>i + 1</code> до кінця масиву. Для цього я буду використовувати змінну лічильника <code>j</code>:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">particles</span>.<span class="hljs-property">length</span>; j++) {
</code></pre><div class="comment"><p>Зверніть увагу, що j починається зі значення i + 1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-keyword">let</span> particle_j = <span class="hljs-variable language_">this</span>.<span class="hljs-property">particles</span>[j];
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Для кожної пари частинок <code>i</code> та <code>j</code> я можу створити пружину. Я повернуся до безпосереднього використання <code>VerletSpring2D</code>, але ви також можете включити власний клас <code>Spring</code>:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">        physics.<span class="hljs-title function_">addSpring</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletSpring2D</span>(particle_i, particle_j, length, <span class="hljs-number">0.01</span>));
</code></pre><div class="comment"><p>Пружина з’єднує частинки i та j.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Припускаючи, що ці з’єднання створюються в конструкторі <code>Cluster</code>, все, що залишилося, це створити кластер усередині <code>setup()</code> і викликати метод <code>show()</code> у функції <code>draw()</code>!</p>
<div data-type="example">
  <h3 id="example-614-cluster"><a class="heading-link" href="#example-614-cluster">Приклад 6.14: Кластер</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_13_force_directed_graph"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/_tbPaFqVX" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">VerletPhysics2D</span>, <span class="hljs-title class_">VerletParticle2D</span>, <span class="hljs-title class_">VerletSpring2D</span> } = toxi.<span class="hljs-property">physics2d</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> physics;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> cluster;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerletPhysics2D</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  cluster = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cluster</span>(<span class="hljs-title function_">floor</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>)), <span class="hljs-title function_">random</span>(<span class="hljs-number">10</span>, height / <span class="hljs-number">2</span>));
</code></pre><div class="comment"><p>Створення випадкового кластеру.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  physics.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  cluster.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Малювання кластеру.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Цей приклад демонструє концепцію силового алгоритму візуалізації графа, але він не містить жодних реальних даних! Тут кількість вузлів у кожному кластері й рівноважна відстань між вузлами задається випадковим чином, а сила пружини має постійне значення <code>0.01</code>. У реальній програмі ці значення можуть бути визначені на основі ваших конкретних даних, що сподіваюся призведе до виразної візуалізації їх зв’язків.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-612"><a class="heading-link" href="#exercise-612">Вправа 6.12</a></h3>
  <p>Створіть структуру, схожу на кластер, як скелет для милого, приємного, м’якого створіння. Додайте гравітацію та взаємодію з мишкою.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-613"><a class="heading-link" href="#exercise-613">Вправа 6.13</a></h3>
  <p>Розширте граф на основі силового алгоритму, щоб він включав більше одного об’єкта <code>Cluster</code>. Використовуйте об’єкт <code>VerletMinDistanceSpring2D</code> для з’єднання кластерів між собою. Які дані можна візуалізувати за допомогою цього підходу?</p>
  <figure data-type="example">
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/exercise_6_13_force_directed_graph"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/WexUSx7dN" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<h2 id="attraction-and-repulsion-behaviors"><a class="heading-link" href="#attraction-and-repulsion-behaviors">Поведінки притягання і відштовхування</a></h2>
<p>Коли прийшов час створити приклад притягання для Matter.js, я показав як клас <code>Matter.Body</code> включає метод <code>applyForce()</code>. Все, що мені потім потрібно було зробити, це обчислити силу притягання <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>g</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>G</mi><mo>×</mo><msub><mi>m</mi><mn>1</mn></msub><mo>×</mo><msub><mi>m</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>÷</mo><msup><mi>d</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">F_g = (G \times m_1 \times m_2) \div d^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> у вигляді вектора і застосувати його до тіла. Так само клас <code>VerletParticle2D</code> з бібліотеки Toxiclibs.js також включає метод під назвою <code>addForce()</code>, який може застосувати будь-яку розраховану силу до частинки.</p>
<p>Однак Toxiclibs.js також просуває цю ідею на крок далі, пропонуючи вбудовану функціональність для загальних сил (названих поведінками), таких як притягування! Наприклад, якщо додати об’єкт <code>AttractionBehavior</code> до певного об’єкта <code>VerletParticle2D</code>, усі інші частинки у світі фізики відчуватимуть силу притягання до цієї частинки.</p>
<p>Скажімо, я створюю екземпляр свого класу <code>Particle</code> (який розширює клас <code>VerletParticle2D</code>):</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> particle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Particle</span>(<span class="hljs-number">320</span>, <span class="hljs-number">120</span>);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер я можу створити поведінку <code>AttractionBehavior</code>, пов’язану з цією частинкою:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> distance = <span class="hljs-number">20</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> strength = <span class="hljs-number">0.1</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> behavior = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttractionBehavior</span>(particle, distance, strength);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зверніть увагу, що поведінка створюється за допомогою трьох аргументів: частинки, якій її призначають, відстані та потужності. Відстань визначає діапазон, в межах якого буде застосовуватися поведінка. У цьому випадку силу притягання відчуватимуть лише частинки у межах найближчих 20 пікселів. Потужність визначає наскільки сильною буде дія поведінки.</p>
<p>Зрештою, щоб сила активувалася, поведінку потрібно додати до світу фізики:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">physics.<span class="hljs-title function_">addBehavior</span>(behavior);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер усе, що існує у фізичній симуляції, завжди притягуватиметься до цієї частинки, доки вона знаходиться в межах порогової відстані.</p>
<div class="avoid-break">
  <p>Клас <code>AttractionBehavior</code> — це дуже потужний інструмент. Наприклад, навіть попри те, що Toxiclibs.js не обробляє зіткнення автоматично, як це робить Matter.js, ви можете створити симуляцію подібну до зіткнень, додавши до кожної частинки поведінку <code>AttractionBehavior</code> із від’ємною силою, що призведе до відштовхувальної поведінки. Якщо сила велика й активується лише в короткому діапазоні (у масштабі радіуса самої частинки), результат схожий на зіткнення твердих тіл. Ось як для цього можна змінити клас <code>Particle</code>:</p>
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">VerletParticle2D</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">super</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    physics.<span class="hljs-title function_">addBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AttractionBehavior</span>(<span class="hljs-variable language_">this</span>, r * <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>));
</code></pre><div class="comment"><p>Кожного разу, коли створюється частинка, генерується
AttractionBehavior і додається до світу фізики.
Зауважте, що коли значення сили від’ємне, воно діятиме як
сила відштовхування!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Тепер я можу переробити приклад притягування із <a href="/forces#section-forces">Розділу 2</a> за допомогою одного об’єкта <code>Attractor</code>, який використовує поведінку притягування. Навіть якщо атрактор знаходиться в центрі, я використовую поріг відстані рівний ширині полотна, щоб врахувати інші можливі його положення та рух частинок, розташованих поза межами полотна.</p>
<div data-type="example">
  <h3 id="example-615-attraction-and-repulsion-behaviors"><a class="heading-link" href="#example-615-attraction-and-repulsion-behaviors">Приклад 6.15: Поведінка притягання і відштовхування</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/06_libraries/6_14_attraction_behaviors"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/tjIs8XaXP" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Attractor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">VerletParticle2D</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, r</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">super</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = r;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    physics.<span class="hljs-title function_">addBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AttractionBehavior</span>(<span class="hljs-variable language_">this</span>, width, <span class="hljs-number">0.1</span>));
</code></pre><div class="comment"><p>Постійне притягування всіх частинок.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    physics.<span class="hljs-title function_">addBehavior</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AttractionBehavior</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span>, -<span class="hljs-number">10</span>));
</code></pre><div class="comment"><p>Відштовхування частинок, які потрапляють у визначений радіус.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    physics.<span class="hljs-title function_">addParticle</span>(<span class="hljs-variable language_">this</span>);
</code></pre><div class="comment"><p>Додавання атрактора до світу фізики.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Так само як обговорювалося у розділі про <a href="/autonomous-agents#spatial-subdivisions" class="page-reference">“Просторовий поділ”</a>, проєкти Toxiclibs.js із великою кількістю частинок, які взаємодіють одна з одною, можуть працювати дуже повільно через <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> природу алгоритму (кожна частинка перевіряє кожну іншу частинку). Щоб прискорити симуляцію, ви можете використовувати метод <code>addForce()</code> вручну у поєднанні з алгоритмом бінінгу. Майте на увазі, що для цього вам також знадобиться розрахувати силу притягання вручну, оскільки вбудована поведінка <code>AttractionBehavior</code> більше не застосовуватиметься.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-614"><a class="heading-link" href="#exercise-614">Вправа 6.14</a></h3>
  <p>Використайте клас <code>AttractionBehavior</code> у поєднанні з пружинними силами.</p>
</div>
<div data-type="project" class="callout">
  <h3 id="the-ecosystem-project-7"><a class="heading-link" href="#the-ecosystem-project-7">Проєкт “Екосистема”</a></h3>
  <p>Візьміть свою систему створінь із Розділу 5 і використайте фізичний рушій для керування їх рухом та поведінкою. Ось деякі можливості:</p>
  <ul>
    <li>Використовуйте Matter.js, щоб налаштувати зіткнення між створіннями. Розгляньте можливість запускати певні події при зіткненні двох створінь.</li>
    <li>Використовуйте Matter.js для покращення дизайну ваших створінь. Побудуйте скелет з віддаленими з’єднаннями аб о зробіть відростки з шарнірними сполученнями.</li>
    <li>Використовуйте Toxiclibs.js, щоб покращити дизайн вашого створіння. Використовуйте ланцюжок частинок Toxiclibs.js для щупалець або сітку пружин як скелет.</li>
    <li>Використовуйте Toxiclibs.js, щоб додати поведінку притягання і відштовхування для ваших створінь.</li>
    <li>Використовуйте пружинні (або шарнірні) з’єднання між об’єктами, щоб контролювати їх взаємодію. Створюйте і видаляйте ці пружини на льоту. Розгляньте можливість робити ці з’єднання видимими або невидимими для глядача.</li>
  </ul>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1420&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#c8c8c8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/b19bb9c5da64036503bb914eb29a7a49/be6fc/06_libraries_21.webp 576w,./static/b19bb9c5da64036503bb914eb29a7a49/7c4ba/06_libraries_21.webp 1152w,./static/b19bb9c5da64036503bb914eb29a7a49/2e9c6/06_libraries_21.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/b19bb9c5da64036503bb914eb29a7a49/43bff/06_libraries_21.png" data-srcset="./static/b19bb9c5da64036503bb914eb29a7a49/09264/06_libraries_21.png 576w,./static/b19bb9c5da64036503bb914eb29a7a49/8a8ae/06_libraries_21.png 1152w,./static/b19bb9c5da64036503bb914eb29a7a49/43bff/06_libraries_21.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/b19bb9c5da64036503bb914eb29a7a49/be6fc/06_libraries_21.webp 576w,./static/b19bb9c5da64036503bb914eb29a7a49/7c4ba/06_libraries_21.webp 1152w,./static/b19bb9c5da64036503bb914eb29a7a49/2e9c6/06_libraries_21.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/b19bb9c5da64036503bb914eb29a7a49/43bff/06_libraries_21.png" srcSet="./static/b19bb9c5da64036503bb914eb29a7a49/09264/06_libraries_21.png 576w,./static/b19bb9c5da64036503bb914eb29a7a49/8a8ae/06_libraries_21.png 1152w,./static/b19bb9c5da64036503bb914eb29a7a49/43bff/06_libraries_21.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
</div>
</section>
<hr/><section class="not-prose flex w-full justify-between"><div><a class="group block" href="./autonomous-agents.html"><p class="text-gray-500">Попередній розділ</p><span class="text-lg font-semibold group-hover:underline">← <!-- -->5. Автономні агенти</span></a></div><div><a class="group block text-right" href="./cellular-automata.html"><p class="text-gray-500">Наступний розділм</p><span class="text-lg font-semibold group-hover:underline">7. Клітинні автомати<!-- --> →</span></a></div></section></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script src="./assets/js/main.js"></script></body></html>