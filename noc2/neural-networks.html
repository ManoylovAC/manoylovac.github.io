<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta data-react-helmet="true" name="description" content="Я почав з неживих об’єктів, що живуть у світі сил і надав їм бажання, автономію та здатність діяти відповідно до системи правил. Далі я дозволив цим о"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:url" content="https://natureofcode.com"/><meta data-react-helmet="true" property="og:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/><meta data-react-helmet="true" property="og:title" content="10. Нейронні мережі"/><meta data-react-helmet="true" property="og:description" content="Я почав з неживих об’єктів, що живуть у світі сил і надав їм бажання, автономію та здатність діяти відповідно до системи правил. Далі я дозволив цим о"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="10. Нейронні мережі"/><meta data-react-helmet="true" name="twitter:description" content="Я почав з неживих об’єктів, що живуть у світі сил і надав їм бажання, автономію та здатність діяти відповідно до системи правил. Далі я дозволив цим о"/><meta data-react-helmet="true" name="twitter:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/>

  <link rel="stylesheet" href="./assets/styles/global.css">

  <noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="./favicon-32x32.png" type="image/png"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title data-react-helmet="true">10. Нейронні мережі / Nature of Code</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="fixed left-0 right-0 top-0 z-40 bg-white px-6 lg:px-8"><div class="mx-auto flex h-[5em] max-w-6xl items-center justify-between"><div class="flex flex-col gap-x-6 lg:flex-row lg:items-center"><a href="./"><span class="text-lg font-black tracking-widest text-noc-400"><span class="font-black">ПРИРОДА</span> КОДУ</span></a><span class="hidden text-sm tracking-widest text-noc-400 xl:block">ДАНІЕЛЬ ШИФФМАН</span></div><button class="flex h-9 w-11 cursor-pointer flex-col items-center justify-between p-2 lg:hidden" aria-label="Toggle menu" title="Toggle menu"><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-opacity" style="opacity:1"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span></button><div class="hidden items-center gap-6 lg:flex"><ul class="flex items-center gap-6"><li><a href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M458.4 64.3C400.6 15.7 311.3 23 256 79.3 200.7 23 111.4 15.6 53.6 64.3-21.6 127.6-10.6 230.8 43 285.5l175.4 178.7c10 10.2 23.4 15.9 37.6 15.9 14.3 0 27.6-5.6 37.6-15.8L469 285.6c53.5-54.7 64.7-157.9-10.6-221.3zm-23.6 187.5L259.4 430.5c-2.4 2.4-4.4 2.4-6.8 0L77.2 251.8c-36.5-37.2-43.9-107.6 7.3-150.7 38.9-32.7 98.9-27.8 136.5 10.5l35 35.7 35-35.7c37.8-38.5 97.8-43.2 136.5-10.6 51.1 43.1 43.5 113.9 7.3 150.8z"></path></svg>SUPPORT</a></li><li><a href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>GITHUB</a></li><li><a href="https://thecodingtrain.com/" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./static/codingtrain_logo-53b0a841be45c7eac7a12f88b7bea596.png" alt="Coding Train&#x27;s logo" class="-ml-2 w-8"/>CODING TRAIN</a></li></ul><div class="not-prose flex items-center gap-4 undefined"><div class="relative"><a href="https://natureofcode.com/" target="_blank" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./favicon-32x32.png" alt="The Nature Of Code logo" class="noc2-logo"/>THE NATURE OF CODE</a></div></div></div></div></header>
  <nav class="fixed bottom-0 left-0 right-0 top-[5em] z-20 overflow-y-auto bg-white px-6 lg:hidden mb-menu hidden">
    <ul class="my-7 space-y-2">
      <li><a class="text-lg text-gray-800" href="./dedication.html">Присвята</a></li>
      <li><a class="text-lg text-gray-800" href="./acknowledgements.html">Подяки</a></li>
      <li><a class="text-lg text-gray-800" href="./introduction.html">Вступ</a></li>
      <li>
        <button class="sub-menu-btn flex items-center gap-2 text-lg text-gray-800">
          <span>Розділи</span>
          <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 transition-transform" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="transform: scaleY(1);"><polyline points="6 9 12 15 18 9"></polyline></svg>
        </button>
        <ul class="space-y-2 py-2 pl-4 sub-menu hidden">
          <li><a class="flex items-center text-gray-600" href="./random.html"><span class="w-8">0</span><span>Випадковість</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./vectors.html"><span class="w-8">1</span><span>Вектори</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./forces.html"><span class="w-8">2</span><span>Сили</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./oscillation.html"><span class="w-8">3</span><span>Коливання</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./particles.html"><span class="w-8">4</span><span>Система частинок</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./autonomous-agents.html"><span class="w-8">5</span><span>Автономні агенти</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./physics-libraries.html"><span class="w-8">6</span><span>Фізичні бібліотеки</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./cellular-automata.html"><span class="w-8">7</span><span>Клітинні автомати</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./fractals.html"><span class="w-8">8</span><span>Фрактали</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./genetic-algorithms.html"><span class="w-8">9</span><span>Еволюційне моделювання</span></a></li>
          <li><a aria-current="page" class="flex items-center text-gray-600 font-bold" href="./neural-networks.html"><span class="w-8">10</span><span>Нейронні мережі</span></a></li>
          <li><a class="flex items-center text-gray-600" href="./neuroevolution.html"><span class="w-8">11</span><span>Нейроеволюція</span></a></li>
        </ul>
      </li>
      <li><a class="text-lg text-gray-800" href="./appendix-creature.html">Додаток: Дизайн створінь</a></li>
      <li><a class="text-lg text-gray-800" href="./resources.html">Додаткові ресурси</a></li>
      <li><a class="text-lg text-gray-800" href="./credits.html">Credits</a></li>
      <li><a class="text-lg text-gray-800" href="./translation.html">Про переклад</a></li>
      <li><a class="text-lg text-gray-800" href="./examples.html">Приклади</a></li>
    </ul>
    <ul class="my-7 space-y-2">
      <li><a target="_blank" href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1 text-lg text-gray-800">Support<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
      <li><a target="_blank" href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1 text-lg text-gray-800">GitHub<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
      <li><a target="_blank" href="https://thecodingtrain.com/" class="flex items-center gap-1 text-lg text-gray-800">Coding Train<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>

      <li><a target="_blank" href="https://natureofcode.com/" class="flex items-center gap-1 text-lg text-gray-800">The Nature Of Code<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
    </ul>
  </nav>
  <div class="mt-[6em] px-6 lg:px-8"><div class="mx-auto max-w-6xl lg:flex lg:justify-between lg:gap-10 xl:gap-14"><aside class="sticky top-[6em] z-10 hidden max-h-[calc(100vh-6em)] min-w-[14em] overflow-y-auto pb-8 lg:block lg:flex-grow"><nav class="border-noc-200 rounded-3xl border"><ul class="divide-noc-200 divide-y"><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./dedication.html">Присвята</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./acknowledgements.html">Подяки</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./introduction.html">Вступ</a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./random.html"><span class="w-8">0</span><span class="group-hover:underline">Випадковість</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./vectors.html"><span class="w-8">1</span><span class="group-hover:underline">Вектори</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./forces.html"><span class="w-8">2</span><span class="group-hover:underline">Сили</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./oscillation.html"><span class="w-8">3</span><span class="group-hover:underline">Коливання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./particles.html"><span class="w-8">4</span><span class="group-hover:underline">Системи частинок</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./autonomous-agents.html"><span class="w-8">5</span><span class="group-hover:underline">Автономні агенти</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./physics-libraries.html"><span class="w-8">6</span><span class="group-hover:underline">Фізичні бібліотеки</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./cellular-automata.html"><span class="w-8">7</span><span class="group-hover:underline">Клітинні автомати</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./fractals.html"><span class="w-8">8</span><span class="group-hover:underline">Фрактали</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./genetic-algorithms.html"><span class="w-8">9</span><span class="group-hover:underline">Еволюційне моделювання</span></a></li><li><a aria-current="page" class="group relative flex items-center px-3 py-2 text-sm font-bold" href="./neural-networks.html"><span class="w-8">10</span><span class="group-hover:underline">Нейронні мережі</span></a><ul class="space-y-1 pb-2"><li><a href="#introducing-artificial-neural-networks" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Знайомство зі штучними нейронними мережами</a></li><li><a href="#the-perceptron" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Персептрон</a></li><li><a href="#putting-the-network-in-neural-network" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Розміщення “мережі” у нейронній мережі</a></li><li><a href="#machine-learning-with-ml5js" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Машинне навчання з ml5.js</a></li><li><a href="#building-a-gesture-classifier" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Створення класифікатора рухів</a></li></ul></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neuroevolution.html"><span class="w-8">11</span><span class="group-hover:underline">Нейроеволюція</span></a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./appendix-creature.html">Додаток: Дизайн створінь </a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./resources.html">Додаткові ресурси</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./credits.html">Credits</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./translation.html">Про переклад</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./examples.html">Приклади</a></li></ul></nav></aside><main class="prose mx-auto max-w-[50em] pb-8"><section data-type="chapter" id="section-neural-networks">
<h1 id="chapter-10-neural-networks">Розділ 10. Нейронні мережі</h1>
<div class="chapter-opening-quote">
  <blockquote data-type="epigraph">
    <p>Людський мозок має 100 мільярдів нейронів,</p>
    <p>кожен з’єднаний з 10 тисячами інших нейронів.</p>
    <p>Те, що знаходиться на ваших плечах</p>
    <p>є найскладнішим об’єктом</p>
    <p>у відомому нам всесвіті.</p>
    <div class="chapter-opening-quote-source">
      <p>— Мічіо Кайку</p>
    </div>
  </blockquote>
</div>
<div class="chapter-opening-figure">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1920px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1080&#x27; width=&#x27;1920&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#887868;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4905ee24f11b605879268745c4219779/3a3a2/10_nn_1.webp 480w,./static/4905ee24f11b605879268745c4219779/bde8a/10_nn_1.webp 960w,./static/4905ee24f11b605879268745c4219779/c512e/10_nn_1.webp 1920w" sizes="(min-width: 1920px) 1920px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1920px) 1920px, 100vw" decoding="async" loading="lazy" data-src="./static/4905ee24f11b605879268745c4219779/a764f/10_nn_1.jpg" data-srcset="./static/4905ee24f11b605879268745c4219779/fb67e/10_nn_1.jpg 480w,./static/4905ee24f11b605879268745c4219779/3059d/10_nn_1.jpg 960w,./static/4905ee24f11b605879268745c4219779/a764f/10_nn_1.jpg 1920w" alt="Кіпу на виставці в музеї Мачу-Пікчу, Куско, Перу (автор фото Pi3.124)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4905ee24f11b605879268745c4219779/3a3a2/10_nn_1.webp 480w,./static/4905ee24f11b605879268745c4219779/bde8a/10_nn_1.webp 960w,./static/4905ee24f11b605879268745c4219779/c512e/10_nn_1.webp 1920w" sizes="(min-width: 1920px) 1920px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1920px) 1920px, 100vw" decoding="async" loading="lazy" src="./static/4905ee24f11b605879268745c4219779/a764f/10_nn_1.jpg" srcSet="./static/4905ee24f11b605879268745c4219779/fb67e/10_nn_1.jpg 480w,./static/4905ee24f11b605879268745c4219779/3059d/10_nn_1.jpg 960w,./static/4905ee24f11b605879268745c4219779/a764f/10_nn_1.jpg 1920w" alt="Кіпу на виставці в музеї Мачу-Пікчу, Куско, Перу (автор фото Pi3.124)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
  <span id="khipu-on-display-at-the-machu-picchu-museum-cusco-peru-photo-by-pi3124"><a class="heading-link" href="#khipu-on-display-at-the-machu-picchu-museum-cusco-peru-photo-by-pi3124">Кіпу на виставці в музеї Мачу-Пікчу, Куско, Перу (автор фото Pi3.124)</a></span>
  <p><em>Кіпу</em> (або вузол) — це стародавній пристрій інків, який використовувався для ведення записів і спілкування. Він являв собою складну систему мотузкового сплетіння й вузликів для кодування та передачі інформації. Кожна кольорова мотузка, тип і візерунок вузла представляли певні дані, наприклад записи перепису чи календарну інформацію. Перекладачі, відомі як <em>кіпукамайоки</em>, діяли як свого роду бухгалтери й декодували мотузкові записи у зрозумілу інформацію.</p>
<hr/></div>
<p>Я почав з неживих об’єктів, що живуть у світі сил і надав їм бажання, автономію та здатність діяти відповідно до системи правил. Далі я дозволив цим об’єктам, які тепер називаються <em>створіннями</em>, жити в популяції й еволюціонувати з часом. Тепер я хочу запитати, яким чином відбувається процес прийняття рішень у кожного створіння? Як воно може змінити свій вибір, навчаючись з часом? Чи може обчислювальний об’єкт обробляти своє середовище і приймати рішення?</p>
<p>Щоб відповісти на ці запитання, я знову звернусь до природи, а саме до людського мозку. Мозок можна описати як біологічну <strong>нейронну мережу</strong> — взаємопов’язану мережу нейронів, що передають складні моделі електричних сигналів. Усередині кожного нейрона дендрити отримують вхідні сигнали й на їх основі нейрон подає вихідний сигнал через аксон (див. малюнок 10.1). Питання як саме працює людський мозок це витончена та складна таємниця, яку я, звісно, не збираюся детально розгадувати в межах цього розділу.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;979.9999999999999&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/472369e80e00d3edb93dae98f30c1ebf/85211/10_nn_2.webp 576w,./static/472369e80e00d3edb93dae98f30c1ebf/ddecd/10_nn_2.webp 1152w,./static/472369e80e00d3edb93dae98f30c1ebf/c3daf/10_nn_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/472369e80e00d3edb93dae98f30c1ebf/b0c60/10_nn_2.png" data-srcset="./static/472369e80e00d3edb93dae98f30c1ebf/6b2da/10_nn_2.png 576w,./static/472369e80e00d3edb93dae98f30c1ebf/f0fc5/10_nn_2.png 1152w,./static/472369e80e00d3edb93dae98f30c1ebf/b0c60/10_nn_2.png 2304w" alt="Малюнок 10.1: Нейрон з дендритами та аксоном, з’єднаним з іншим нейроном"/></picture><noscript><picture><source type="image/webp" srcSet="./static/472369e80e00d3edb93dae98f30c1ebf/85211/10_nn_2.webp 576w,./static/472369e80e00d3edb93dae98f30c1ebf/ddecd/10_nn_2.webp 1152w,./static/472369e80e00d3edb93dae98f30c1ebf/c3daf/10_nn_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/472369e80e00d3edb93dae98f30c1ebf/b0c60/10_nn_2.png" srcSet="./static/472369e80e00d3edb93dae98f30c1ebf/6b2da/10_nn_2.png 576w,./static/472369e80e00d3edb93dae98f30c1ebf/f0fc5/10_nn_2.png 1152w,./static/472369e80e00d3edb93dae98f30c1ebf/b0c60/10_nn_2.png 2304w" alt="Малюнок 10.1: Нейрон з дендритами та аксоном, з’єднаним з іншим нейроном"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.1: Нейрон з дендритами та аксоном, з’єднаним з іншим нейроном</figcaption>
</figure>
<p>На щастя, як ви бачили у цій книзі, розробка привабливих анімованих систем за допомогою коду не потребує наукової строгості чи точності. Розробка розумної ракети не є ракетобудуванням, а розробка штучної нейронної мережі не є наукою про мозок. Досить просто надихнутися <em>ідеєю</em> роботи мозку.</p>
<p>Цей розділ я почну з концептуального огляду властивостей і особливостей нейронних мереж й побудую найпростіший можливий приклад такої мережі, яка складатиметься з одного нейрона. Потім я познайомлю вас зі складнішими нейронними мережами із допомогою бібліотеки ml5.js. Це послужить основою для <a href="/neuroevolution#section-neuroevolution">Розділу 11</a> — великого фіналу цієї книги, де я поєднаю ГА із нейронними мережами для фізичного моделювання.</p>
<h2 id="introducing-artificial-neural-networks"><a class="heading-link" href="#introducing-artificial-neural-networks">Знайомство зі штучними нейронними мережами</a></h2>
<p>Вчені з інформатики вже давно надихаються людським мозком. У 1943 році нейробіолог Воррен Маккалох і логік Волтер Піттс, розробили першу концептуальну модель штучної нейронної мережі. У їх статті “Логічне обчислення ідей, властивих нервовій діяльності” вони описують <strong>нейрон</strong> як єдину обчислювальну клітину, що живе в мережі клітин, яка отримує вхідні дані, обробляє ці вхідні дані та генерує вихідні дані.</p>
<p>Їхня робота, а також робота багатьох вчених і дослідників, які йшли за ними, не мала на меті точно описати, як працює біологічний мозок. Навпаки, <em>штучна</em> нейронна мережа (надалі просто <em>нейронна мережа</em>) була задумана як обчислювальна модель, заснована на мозку, розроблена для розв&#x27;язання певних проблем, які традиційно були складними для комп’ютерів.</p>
<p>Деякі проблеми неймовірно прості для вирішення комп’ютером, але складні для таких людей, як ми з вами. Прикладом є знаходження квадратного кореня з числа 964 324. Швидкий рядок коду видає значення 982, число, яке мій комп’ютер може обчислити менш ніж за мілісекунду, але якщо ви попросите мене обчислити це число самостійно, вам доведеться трохи почекати. З іншого боку, певні задачі неймовірно просто розв’язати вам або мені, але не так легко для комп’ютера. Покажіть будь-якому малюку зображення кошеня чи цуценя і вони швидко зможуть сказати вам, хто з них де. Прислухайтеся до розмови в галасливому кафе і зосередьтеся на голосі однієї людини й ви легко зможете зрозуміти її слова. Але як щодо потрібної машини для виконання одного з цих завдань? Вчені присвятили для цього цілі кар’єри на дослідження і впровадження складних рішень й нейронні мережі є одним з них.</p>
<p>Ось кілька застосувань для нейронних мереж у програмному забезпеченні, деякі з них на сьогодні є простими для людини, але складними для машин:</p>
<ul>
  <li><strong>Розпізнавання шаблонів:</strong> нейронні мережі добре підходять для завдань, коли метою є виявлення, інтерпретація і класифікація ознак або патернів у наборі даних. Це може включати багато завдань, починаючи від ідентифікації об’єктів на зображеннях (наприклад, обличчя) до оптичного розпізнавання символів і до складніших завдань, таких як розпізнавання жестів.</li>
  <li><strong>Прогнозування часових рядів і виявлення аномалій:</strong> нейронні мережі використовуються як для прогнозування, наприклад, прогнозування тенденцій на фондових ринках або погодних умов, так і для розпізнавання аномалій, які можна застосовувати в таких галузях, як виявлення кібератак і запобігання шахрайству.</li>
  <li><strong>Системи управління й адаптивного прийняття рішень:</strong> застосування цих систем варіюються від автономних транспортних засобів, таких як безпілотні автомобілі та дрони, до адаптивного прийняття рішень, що використовується в іграх, моделях ціноутворення і систем ах рекомендацій на медіаплатформах.</li>
  <li><strong>Обробка природної мови:</strong> однією з найбільших подій за останні роки стало використання нейронних мереж для обробки й розуміння людської мови. Вони використовуються у різних завданнях, включаючи машинний переклад, аналіз настроїв і узагальнення тексту та є базовою технологією для багатьох цифрових помічників і чат-ботів.</li>
  <li><strong>Обробка сигналів і обчислювальні датчики:</strong> нейронні мережі відіграють вирішальну роль у таких пристроях, як кохлеарні імплантати та слухові апарати, фільтруючи шум й посилюючи важливі звуки. Вони також використовуються в <em>обчислювальних сенсорах</em> — програмних системах, які обробляють дані з багатьох джерел для всебічного аналізу навколишнього середовища.</li>
  <li><strong>Генеративні моделі:</strong> розвиток нових архітектур нейронних мереж зробив можливим генерацію нового контенту. Ці системи можуть синтезувати зображення, покращувати роздільну здатність зображення, передавати стиль малюнку між зображеннями й навіть створювати музику та відео.</li>
</ul>
<p>Охоплення повного спектра застосувань для нейронних мереж заслуг овує на цілу книгу (або серію книг) і на той час, коли ця книга буде надрукована, вона, ймовірно, застаріє. Сподіваюсь, цей список дав вам загальне уявлення про їх функціональність та можливості.</p>
<h3 id="how-neural-networks-work"><a class="heading-link" href="#how-neural-networks-work">Як працюють нейронні мережі</a></h3>
<p>Нейронні мережі дещо відрізняються від інших комп’ютерних програм. Обчислювальні системи, про які я писав до цього, є <strong>процедурними</strong>: програма починається з першого рядка коду, виконує його і переходить до наступного, дотримуючись інструкцій у лінійному порядку. Напротивагу, справжня нейронна мережа не слідує лінійним шляхом. Натомість інформація обробляється спільно, паралельно, у мережі вузлів, кожен з яких представляє нейрон. У цьому сенсі нейронна мережа вважається <strong>конекціоністською</strong> системою.</p>
<p>З іншого боку, нейронні мережі не дуже відрізняються від деяких програм, які ви вже бачили. Нейронна мережа демонструє всі ознаки складної системи, схожої на клітинний автомат або зграю боїдів. Пам’ятаєте як кожен окремий боїд сам по собі був простим для розуміння, але введення лише трьох правил таких як розділення, вирівнювання і згуртованість, сприяло утворенню складної поведінки? Кожен окремий елемент нейронної мережі однаково простий для розуміння. Він зчитує вхідні дані (числа), обробляє їх та генерує вихідні дані (інші числа). Це все, що стосується окремого нейрона, однак мережа з багатьох нейронів може демонструвати надзвичайно багатогранну й розумну поведінку, повторюючи складну динаміку, яку можна спостерігати у зграї боїдів.</p>
<div class="half-width-right">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1196&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/92052bfd3ba59f32e56a7b4bd9c2be0c/8fae9/10_nn_3.webp 576w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/5f1d9/10_nn_3.webp 1152w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/68995/10_nn_3.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/92052bfd3ba59f32e56a7b4bd9c2be0c/b8b9b/10_nn_3.png" data-srcset="./static/92052bfd3ba59f32e56a7b4bd9c2be0c/595fc/10_nn_3.png 576w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/a1c33/10_nn_3.png 1152w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/b8b9b/10_nn_3.png 2304w" alt="Малюнок 10.2: Нейронна мережа — це система нейронів і їх зв’язків"/></picture><noscript><picture><source type="image/webp" srcSet="./static/92052bfd3ba59f32e56a7b4bd9c2be0c/8fae9/10_nn_3.webp 576w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/5f1d9/10_nn_3.webp 1152w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/68995/10_nn_3.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/92052bfd3ba59f32e56a7b4bd9c2be0c/b8b9b/10_nn_3.png" srcSet="./static/92052bfd3ba59f32e56a7b4bd9c2be0c/595fc/10_nn_3.png 576w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/a1c33/10_nn_3.png 1152w,./static/92052bfd3ba59f32e56a7b4bd9c2be0c/b8b9b/10_nn_3.png 2304w" alt="Малюнок 10.2: Нейронна мережа — це система нейронів і їх зв’язків"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption>Малюнок 10.2: Нейронна мережа — це система нейронів і їх зв’язків</figcaption>
  </figure>
</div>
<p>Насправді нейронна мережа — це не просто складна система, а складна <em>адаптивна</em> система, тобто вона може змінювати свою внутрішню структуру на основі інформації, що проходить через неї. Іншими словами, вона має здатність до навчання. Зазвичай, це досягається шляхом регулювання <strong>ваг</strong>. На малюнку 10.2 кожна стрілка позначає зв’язок між двома нейронами й вказує напрямок потоку інформації. Кожне з’єднання має вагу — число, яке контролює сигнал між двома нейронами. Якщо мережа генерує <em>хороші</em> в ихідні дані або, інакше кажучи, вихід (який я визначу пізніше), немає потреби коригувати ваги. Однак, якщо мережа генерує <em>поганий</em> результат, так би мовити, помилку, тоді система адаптується, змінюючи ваги з надією поліпшити наступні результати.</p>
<p>Нейронні мережі можуть використовувати різноманітні стратегії навчання і на одній із них я зосереджуся у цьому розділі:</p>
<ul>
  <li><strong>Кероване навчання або навчання з учителем (навчання під наглядом):</strong> по суті, ця стратегія передбачає вчителя, який розумніший за саму мережу. Візьмемо випадок розпізнавання обличчя. Учитель показує мережі купу облич, і вчитель уже знає імена, пов’язані з кожним обличчям. Мережа робить свої припущення, а потім вчитель надає мережі фактичні імена. Мережа може порівнювати свої відповіді з відомими правильними та вносити корективи відповідно до своїх помилок. Нейронні мережі у цьому розділі наслідують цю модель.</li>
  <li><strong>Некероване навчання або навчання без учителя:</strong> ця техніка потрібна, коли у вас немає прикладу даних із відомими відповідями. Натомість мережа працює самостійно, щоб виявити у даних приховані закономірності. Прикладом застосуванням є кластеризація: набір елементів розподіляється на групи відповідно до невідомого шаблону. Я не буду наводити жодних прикладів неконтрольованого навчання, оскільки дана стратегія менш актуальна для прикладів у цій книзі.</li>
  <li><strong>Навчання з підкріпленням:</strong> ця стратегія побудована на спостереженні де агент, що навчається, приймає рішення і шукає результати у своєму середовищі. Він винагороджується за правильні рішення і карається за погані, щоб з часом навчитися приймати кращі рішення. Я обговорю цю стратегію більш детально у <a href="/neuroevolution#section-neuroevolution">Розділі 11</a>.</li>
</ul>
<p>Здатність нейронної мережі навчатися, вносячи корективи у свою структуру з часом — це те, що робить її такою корисною в галузі <strong>машинного навчання</strong>. Появу цього терміну можна знайти у статті “Деякі дослідження машинного навчання з використанням гри у шашки” 1959 року, в якій комп’ютерний науковець Артур Лі Семюель описує програму “самонавчання” для гри в шашки. Концепція алгоритму, який дозволяє комп’ютеру вчитися без явного програмування, є основою машинного навчання.</p>
<p>Подумайте про те, що ви робили протягом цієї книги: програмування! У традиційному програмуванні комп’ютерна програма приймає вхідні дані й на основі наданих вами правил генерує вихідні дані. Однак машинне навчання перевертає цей підхід з ніг на голову. Замість того, щоб ви писали правила, системі надаються приклади вхідних і вихідних даних й вона сама генерує правила! Для впровадження машинного навчання можна використовувати багато алгоритмів і нейронна мережа є лише одним із них.</p>
<p>Машинне навчання є частиною широкої й масштабної галузі <strong>штучного інтелекту (ШІ)</strong>, хоча ці терміни іноді використовуються взаємозамінно. У своєму вдумливому і дружньому посібнику “<em>Народний путівник з ШІ</em>” Мімі Онуоха та Діана Нусера (також відома під псевдонімом Mother Cyborg) визначають ШІ як “теорію і розробку комп’ютерних систем, здатних виконувати завдання, які зазвичай потребують людського інтелекту”. Алгоритми машинного навчання є одним із підходів до цих завдань, але не всі системи ШІ мають компонент самонавчання.</p>
<h3 id="machine-learning-libraries"><a class="heading-link" href="#machine-learning-libraries">Бібліотеки машинного навчання</a></h3>
<p>Сьогодн і використання машинного навчання у творчому програмуванні та інтерактивних медіа не лише можливе, але і все більш поширене завдяки спеціальним бібліотекам від розробників, які вирішують у них багато деталей реалізації нейронної мережі. Хоча переважна більшість розробок і досліджень машинного навчання виконується на Python, у світі веброзробки з’явилися потужні інструменти на основі JavaScript. Дві бібліотеки, які варто відзначити, це TensorFlow.js і ml5.js.</p>
<p>TensorFlow.js — це бібліотека з відкритим вихідним кодом, яка дозволяє визначати, навчати й запускати нейронні мережі безпосередньо у браузері за допомогою JavaScript, без необхідності встановлювати чи налаштовувати складні середовища. Вона є частиною екосистеми TensorFlow, яку підтримує та розвиває Google. TensorFlow.js — потужний інструмент, але його низькорівневі операції та високотехнічний API можуть налякати новачків. Тут на допомогу приходить ml5.js — бібліотека, побудована на основі TensorFlow.js і розроблена спеціально для використання з p5.js. Її мета — бути зручною для початківців і зробити машинне навчання доступним для широкої аудиторії митців, творчих програмістів й студентів. Я покажу, як використовувати ml5.js у розділі <a href="#machine-learning-with-ml5js" class="page-reference">“Машинне навчання за допомогою ml5.js”</a>.</p>
<p>Перевага таких бібліотек, як TensorFlow.js і ml5.js, полягає в тому, що ви можете використовувати їх для запуску натренованих моделей. <strong>Модель</strong> машинного навчання — це конкретна конфігурація нейронів і зв’язків, а <strong>натренована</strong> модель — це та, яка була попередньо підготовлена для виконання певного завдання. Наприклад, популярні натреновані моделі використовуються для класифікації зображень, визначення поз тіла, розпізнавання точок обличчя чи положення рук і навіть для аналізу настрою, вираженого у тексті. Ви можете використовувати таку модель як є або розглядати її як відправну точку для додаткового навчання (зазвичай його називають <strong>трансферним навчанням</strong>).</p>
<p>Перш ніж я розгляну бібліотеку ml5.js, я хочу спробувати свої сили у створенні найпростішої з усіх нейронних мереж з нуля, використовуючи лише p5.js, щоб проілюструвати, як концепції нейронних мереж і машинного навчання реалізуються у коді.</p>
<h2 id="the-perceptron"><a class="heading-link" href="#the-perceptron">Персептрон</a></h2>
<p><strong>Персептрон</strong> — це найпростіша нейронна мережа з м ожливих: обчислювальна модель одного нейрона. Винайдений у 1957 році Френком Розенблатом у лабораторії авіаційних досліджень Корнелського університету персептрон складається з одного чи кількох входів з даними, процесора та одного вихідного результату, як показано на малюнку 10.3.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;606&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/cf5195820637396bd5e310f20411a82a/7cd17/10_nn_4.webp 576w,./static/cf5195820637396bd5e310f20411a82a/e4512/10_nn_4.webp 1152w,./static/cf5195820637396bd5e310f20411a82a/77c02/10_nn_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/cf5195820637396bd5e310f20411a82a/ef93a/10_nn_4.png" data-srcset="./static/cf5195820637396bd5e310f20411a82a/af643/10_nn_4.png 576w,./static/cf5195820637396bd5e310f20411a82a/ff497/10_nn_4.png 1152w,./static/cf5195820637396bd5e310f20411a82a/ef93a/10_nn_4.png 2304w" alt="Малюнок 10.3: Простий персептрон з двома входами та одним виходом"/></picture><noscript><picture><source type="image/webp" srcSet="./static/cf5195820637396bd5e310f20411a82a/7cd17/10_nn_4.webp 576w,./static/cf5195820637396bd5e310f20411a82a/e4512/10_nn_4.webp 1152w,./static/cf5195820637396bd5e310f20411a82a/77c02/10_nn_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/cf5195820637396bd5e310f20411a82a/ef93a/10_nn_4.png" srcSet="./static/cf5195820637396bd5e310f20411a82a/af643/10_nn_4.png 576w,./static/cf5195820637396bd5e310f20411a82a/ff497/10_nn_4.png 1152w,./static/cf5195820637396bd5e310f20411a82a/ef93a/10_nn_4.png 2304w" alt="Малюнок 10.3: Простий персептрон з двома входами та одним виходом"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.3: Простий персептрон з двома входами та одним виходом</figcaption>
</figure>
<p>Персептрон слідує моделі <strong>прямого поширення</strong>: дані проходять (подаються) через мережу в одному напрямку. Вхідні дані надсилаються в нейрон, обробляються і призводять до виходу. Це означає, що однонейронна мережа, зображена на малюнку 10.3, читається  зліва направо (вперед): у процесор приходять вхідні дані й виходять вихідні.</p>
<p>Скажімо, у мене є персептрон з двома входами, значеннями 12 і 4. У машинному навчанні заведено позначати кожен вхід символом <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>, тому я назву ці входи як <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> та <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>:</p>
<table><thead><tr><th style="width:150px">Вхід</th><th>Значення</th></tr></thead><tbody><tr><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td>12</td></tr><tr><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td>4</td></tr></tbody></table>
<h3 id="perceptron-steps"><a class="heading-link" href="#perceptron-steps">Кроки персептрона</a></h3>
<p>Щоб перейти від цих вхідних даних до вихідних, персептрон виконує ряд кроків.</p>
<h4 id="step-1-weight-the-inputs">Крок 1: Зваження вхідних даних</h4>
<p>Кожне вхідне значення, яке надсилається у нейрон, спочатку має бути зважене, тобто його помножують на певне значення, часто на число від -1 до +1. Під час створення персептрона вхідні дані зазвичай мають випадкову вагу. Я назву свої ваги як <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">w_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">w_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>:</p>
<table><thead><tr><th style="width:150px">Вага</th><th>Значення</th></tr></thead><tbody><tr><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">w_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td>0.5</td></tr><tr><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">w_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td>–1</td></tr></tbody></table>
<div class="avoid-break">
  <p>Кожне вхідне значення потрібно помножити на відповідну вагу:</p>
  <table><thead><tr><th style="width:150px">Вхідне значення</th><th style="width:100px">Вага</th><th>Вхідне значення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="bold-italic" lspace="0.22em" rspace="0.22em">×</mo></mrow><annotation encoding="application/x-tex">\boldsymbol{\times}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.1333em"></span><span class="mord"><span class="mord"><span class="mord mathbf">×</span></span></span></span></span></span></span> Вага</th></tr></thead><tbody><tr><td>12</td><td>0.5</td><td>6</td></tr><tr><td>4</td><td>–1</td><td>–4</td></tr></tbody></table>
</div>
<h4 id="step-2-sum-the-inputs">Крок 2: Додавання вхідних даних</h4>
<p>Потім зважені вхідні дані додаються разом:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>6</mn><mo>+</mo><mo>−</mo><mn>4</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">6 + -4 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">−</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span></span></div>
<h4 id="step-3-generate-the-output">Крок 3: Формування результату</h4>
<p>Вихідне значення персептрона формується шляхом проведення суми через <strong>функцію активації</strong>, яка зменшує результат до одного з двох можливих значень. Можна уявити цей бінарний результат як світлодіод, який може бути або <em>вимкненим</em> або <em>увімкненим</em>, або як нейрон у реальному мозку, який або активний, або ні. Функція активації визначає, чи повинен персептрон бути активним.</p>
<p>Функції активації можуть бути складними. Якщо ви почнете читати про них у посібнику зі штучного інтелекту, то незабаром можете помітити, як тягнетеся за підручником з математики. Однак ваш новий друг простий персептрон пропонує простіший варіант, який все ще демонструє цю концепцію. Я зроблю функцію активації знаком суми. Якщо сума буде додатним числом, тоді результатом буде 1, а якщо сума від’ємна, тоді результатом буде -1:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>sign</mtext><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{sign}(2) = +1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">sign</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">+</span><span class="mord">1</span></span></span></span></span></div>
<h3 id="putting-it-all-together-1"><a class="heading-link" href="#putting-it-all-together-1">Збираємо все разом</a></h3>
<p>Поєднуючи попередні три частини разом, маємо наступні кроки для <strong>алгоритму персептрона</strong>:</p>
<ol>
  <li>Кожне вхідне значення множиться на його вагу.</li>
  <li>Усі зважені дані додаються разом.</li>
  <li>Результівне значення персептрона обчислюється через проведення отриманої суми через функцію активації (у поточному прикладі результат залежатиме від знаку суми).</li>
</ol>
<p>Я можу почати записувати цей алгоритм у коді, використовуючи два масиви значень, один для вхідних даних і один для їх ваги:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> inputs = [<span class="hljs-number">12</span>, <span class="hljs-number">4</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> weights = [<span class="hljs-number">0.5</span>, -<span class="hljs-number">1</span>];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Крок 1 передбачає використання циклу, який перемножує кожне вхідне значення на його відповідну вагу. Щоб отримати загальну суму, помножені результати можна скласти у цьому самому циклі:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; inputs.<span class="hljs-property">length</span>; i++) {
  sum += inputs[i] * weights[i];
}
</code></pre><div class="comment"><p>Кроки 1 і 2: додавання всіх зважених вхідних даних.</p></div></div></div>
<p>Маючи суму я можу обчислити вихідний результат:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> output = <span class="hljs-title function_">activate</span>(sum);
</code></pre><div class="comment"><p>Крок 3: проведення суми через функцію активації.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">activate</span>(<span class="hljs-params">sum</span>) {
</code></pre><div class="comment"><p>Функція активації.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
</code></pre><div class="comment"><p>Повертає 1, якщо значення позитивне і -1 — якщо негативне.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Вам може бути цікаво, як у функції активації я обробляю значення 0. Значення 0 позитивне чи негативне? Не заглиблюючись у філософські особливості цього питання, я довільно вирішив повертати -1, коли маю 0, але я міг би легко піти іншим шляхом. Все залежить від особливостей програми де це рішення може бути важливим, але для цього прикладу я можу вибрати будь-яке.</p>
<p>Тепер, коли я пояснив процес обчислення персептрона, давайте подивимося на приклад його дії.</p>
<h3 id="simple-pattern-recognition-using-a-perceptron"><a class="heading-link" href="#simple-pattern-recognition-using-a-perceptron">Просте розпізнавання шаблонів за допомогою персептрона</a></h3>
<p>Я вже згадував, що нейронні мережі широко використовуються для розпізнавання шаблонів. Сценарії, описані раніше, вимагають складніших мереж, але навіть простий персептрон може продемонструвати фундаментальний тип розпізнавання шаблонів, у якому дані класифікуються як належні до однієї з двох груп. Наприклад, уявіть, що у вас є набір даних про рослини й ви хочете ідентифікувати їх як <em>ксерофіти</em> (рослини, які еволюціонували, щоб виживати в середовищі з невеликою кількістю води й великою кількістю сонячного світла, наприклад у пустелі), або як <em>гідрофіти</em> (рослини, які пристосувалися жити у воді з обмеженим освітленням). Саме так я використовуватиму свій персептрон у цьому розділі.</p>
<p>Один зі способів підійти до класифікації рослин це візуалізувати їхні дані на 2D графіку і розглядати проблему як просторову. На вісі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> відмічайте кількість щоденного сонячного світла, яке отримує рослина, а по осі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>у</mtext></mrow><annotation encoding="application/x-tex">у</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord cyrillic_fallback">у</span></span></span></span></span> — кількість води. Після нанесення усіх даних, легко провести лінію через графік, де всі ксерофіти будуть з одного боку, а всі гідрофіти з іншого, як на малюнку 10.4. (Я дещо спрощую тут. Дані з реального світу, ймовірно, будуть менш очевидними, тому чітку межу буде провести складніше.) Таким чином можна класифікувати кожну рослину. Якщо згідно з даними вона знаходиться нижче лінії, тоді це ксерофіт. А якщо вона знаходиться вище лінії? Тоді це гідрофіт.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1551&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4b93e5e426ec433f58490a51c56456ba/31c0f/10_nn_5.webp 576w,./static/4b93e5e426ec433f58490a51c56456ba/017b2/10_nn_5.webp 1152w,./static/4b93e5e426ec433f58490a51c56456ba/1f602/10_nn_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/4b93e5e426ec433f58490a51c56456ba/1d8b2/10_nn_5.png" data-srcset="./static/4b93e5e426ec433f58490a51c56456ba/c2ab0/10_nn_5.png 576w,./static/4b93e5e426ec433f58490a51c56456ba/1c9d6/10_nn_5.png 1152w,./static/4b93e5e426ec433f58490a51c56456ba/1d8b2/10_nn_5.png 2304w" alt="Малюнок 10.4: Набір точок у 2D-просторі, розділених лінією, що представляє категорії рослин відповідно до споживання води і сонячного світла"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4b93e5e426ec433f58490a51c56456ba/31c0f/10_nn_5.webp 576w,./static/4b93e5e426ec433f58490a51c56456ba/017b2/10_nn_5.webp 1152w,./static/4b93e5e426ec433f58490a51c56456ba/1f602/10_nn_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/4b93e5e426ec433f58490a51c56456ba/1d8b2/10_nn_5.png" srcSet="./static/4b93e5e426ec433f58490a51c56456ba/c2ab0/10_nn_5.png 576w,./static/4b93e5e426ec433f58490a51c56456ba/1c9d6/10_nn_5.png 1152w,./static/4b93e5e426ec433f58490a51c56456ba/1d8b2/10_nn_5.png 2304w" alt="Малюнок 10.4: Набір точок у 2D-просторі, розділених лінією, що представляє категорії рослин відповідно до споживання води і сонячного світла"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.4: Набір точок у 2D-просторі, розділених лінією, що представляє категорії рослин відповідно до споживання води й сонячного світла</figcaption>
</figure>
<p>Насправді щоб сказати мені чи знаходиться точка вище, чи нижче лінії, мені не потрібна нейронна мережа, навіть простий персептрон. Я можу побачити відповідь на власні очі або дати моєму комп’ютеру визначити це завдання за допомогою простої алгебри. Але так само як розв’язання проблеми з відомою відповіддю “to be or not to be” було зручним першим тестом для ГА у <a href="/genetic-algorithms#section-genetic-algorithms">Розділі 9</a>, навчання персептрона класифікувати точки як такі, що знаходяться по один або по інший бік лінії буде цінним способом продемонструвати алгоритм персептрона і переконатися, що він працює належним чином.</p>
<p>Щоб розв&#x27;язувати цю проблему, я дам своєму персептрону два вхідні значення: <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> — це <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-координата точки, яка представлятиме кількість сонячного світла для рослини, а <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> — це <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-координата цієї точки, що представлятиме кількість води для рослини. Потім персептрон вгадуватиме класифікацію рослини відповідно до знака зваженої суми цих вхідних даних. Якщо сума додатна, персептрон повертатиме +1, що означатиме гідрофіт (знаходиться над лінією). Якщо сума від’ємна, тоді повертатиметься -1, що означатиме ксерофіт (нижче лінії). На малюнку 10.5 показано цей персептрон (зверніть увагу на скорочення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">w_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">w_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> для позначення ваги).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;632&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/35aed496ad7c74457e2ec50ca4e87124/c8044/10_nn_6.webp 576w,./static/35aed496ad7c74457e2ec50ca4e87124/3b54f/10_nn_6.webp 1152w,./static/35aed496ad7c74457e2ec50ca4e87124/ea082/10_nn_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/35aed496ad7c74457e2ec50ca4e87124/e5bb0/10_nn_6.png" data-srcset="./static/35aed496ad7c74457e2ec50ca4e87124/afddc/10_nn_6.png 576w,./static/35aed496ad7c74457e2ec50ca4e87124/7b8c6/10_nn_6.png 1152w,./static/35aed496ad7c74457e2ec50ca4e87124/e5bb0/10_nn_6.png 2304w" alt="Малюнок 10.5: Персептрон із двома вхідними даними (x_0 і x_1), вагою для кожного вхідного значення (w_0 та w_1), а також нейроном, який генерує результат"/></picture><noscript><picture><source type="image/webp" srcSet="./static/35aed496ad7c74457e2ec50ca4e87124/c8044/10_nn_6.webp 576w,./static/35aed496ad7c74457e2ec50ca4e87124/3b54f/10_nn_6.webp 1152w,./static/35aed496ad7c74457e2ec50ca4e87124/ea082/10_nn_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/35aed496ad7c74457e2ec50ca4e87124/e5bb0/10_nn_6.png" srcSet="./static/35aed496ad7c74457e2ec50ca4e87124/afddc/10_nn_6.png 576w,./static/35aed496ad7c74457e2ec50ca4e87124/7b8c6/10_nn_6.png 1152w,./static/35aed496ad7c74457e2ec50ca4e87124/e5bb0/10_nn_6.png 2304w" alt="Малюнок 10.5: Персептрон із двома вхідними даними (x_0 і x_1), вагою для кожного вхідного значення (w_0 та w_1), а також нейроном, який генерує результат"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.5: Персептрон із двома вхідними даними (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>), вагою для кожного вхідного значення (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">w_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> та <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">w_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>), а також нейроном, який генерує результат</figcaption>
</figure>
<p>Однак ця схема має досить серйозну проблему. Що робити, якщо моя точка даних дорівнює <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>, і я надсилаю цю точку в персептрон як вхідні дані <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span>? Незалежно від ваги, множення на 0 дорівнює 0. Тому зважені вхідні дані все ще дорівнюють 0 і їхня сума також дорівнюватиме 0. А знак 0 дорівнює... хм, знову глибока філософська дилема. Незалежно від того, як я ставлюся до цього, точка <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> може бути або вище або нижче різних ліній у 2D-світі. Як саме персептрон має це інтерпретувати?</p>
<p>Щоб уникнути цієї дилеми, персептрон потребує третє вхідне значення, яке зазвичай називають похибкою або значенням <strong>баєса</strong>. Цей додатковим параметр завжди має значення 1 і також є зваженим. На малюнку 10.6 показаний персептрон з баєсом.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;632&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/d20d61421b634610a18123e06d477a0d/c8044/10_nn_7.webp 576w,./static/d20d61421b634610a18123e06d477a0d/3b54f/10_nn_7.webp 1152w,./static/d20d61421b634610a18123e06d477a0d/ea082/10_nn_7.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/d20d61421b634610a18123e06d477a0d/e5bb0/10_nn_7.png" data-srcset="./static/d20d61421b634610a18123e06d477a0d/afddc/10_nn_7.png 576w,./static/d20d61421b634610a18123e06d477a0d/7b8c6/10_nn_7.png 1152w,./static/d20d61421b634610a18123e06d477a0d/e5bb0/10_nn_7.png 2304w" alt="Малюнок 10.6: Додавання до персептрона значення баєса разом із його вагою"/></picture><noscript><picture><source type="image/webp" srcSet="./static/d20d61421b634610a18123e06d477a0d/c8044/10_nn_7.webp 576w,./static/d20d61421b634610a18123e06d477a0d/3b54f/10_nn_7.webp 1152w,./static/d20d61421b634610a18123e06d477a0d/ea082/10_nn_7.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/d20d61421b634610a18123e06d477a0d/e5bb0/10_nn_7.png" srcSet="./static/d20d61421b634610a18123e06d477a0d/afddc/10_nn_7.png 576w,./static/d20d61421b634610a18123e06d477a0d/7b8c6/10_nn_7.png 1152w,./static/d20d61421b634610a18123e06d477a0d/e5bb0/10_nn_7.png 2304w" alt="Малюнок 10.6: Додавання до персептрона значення баєса разом із його вагою"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.6: Додавання до персептрона значення баєса разом із його вагою</figcaption>
</figure>
<p>Як це впливає на точку <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>?</p>
<table><thead><tr><th style="width:100px">Вхідне значення</th><th style="width:100px">Вага</th><th>Результат</th></tr></thead><tbody><tr><td>0</td><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">w_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td>0</td></tr><tr><td>0</td><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">w_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td>0</td></tr><tr><td>1</td><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mtext>bias</mtext></msub></mrow><annotation encoding="application/x-tex">w_\text{bias}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">bias</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td><td><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mtext>bias</mtext></msub></mrow><annotation encoding="application/x-tex">w_\text{bias}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">bias</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span></td></tr></tbody></table>
<p>Результатом буде сума зважених результатів: <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>0</mn><mo>+</mo><msub><mi>w</mi><mtext>bias</mtext></msub></mrow><annotation encoding="application/x-tex">0 + 0 + w_\text{bias}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">bias</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>. Таким чином, значення похибки саме по собі відповідає на питання, де знаходиться <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> стосовно лінії. Якщо вага похибки додатна, точка <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> буде знаходитися над лінією, а якщо від’ємна, то нижче. Додаткове значення <em>bias</em> і його вага змінюють розуміння персептроном положення лінії відносно координат <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>!</p>
<h3 id="the-perceptron-code"><a class="heading-link" href="#the-perceptron-code">Код персептрона</a></h3>
<p>Тепер я готовий зібрати код для класу <code>Perceptron</code>. Персептрону достатньо відстежувати лише ваги вхідних даних, які я можу зберегти за допомогою масиву:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Perceptron</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span> = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Конструктор може приймати аргумент, який вказуватиме кількість вхідних даних (у цьому випадку трьох: <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>, <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>, і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">bia</span><span class="mord mathnormal">s</span></span></span></span></span>) і створюватиме масив для ваг <code>weights</code> відповідного розміру, заповнюючи його для початку випадковими значеннями:</p>
<div class="snip-above snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span> = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
</code></pre><div class="comment"><p>Аргумент n визначає кількість вхідних даних (включаючи значення баєса).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i] = <span class="hljs-title function_">random</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Для початку значення ваг вибираються випадковим чином.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Робота персептрона полягає в тому, щоб отримувати вхідні дані й створювати вихідні. Ці вимоги можна об’єднати у методі <code>feedForward()</code>. У цьому прикладі вхідними даними персептрона є масив (який має бути такої ж довжини, як і масив вагових коефіцієнтів), а вихідним результатом є число, +1 або -1, яке повертає функція активації на основі знака суми:</p>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">feedForward</span>(<span class="hljs-params">inputs</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      sum += inputs[i] * <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">activate</span>(sum);
</code></pre><div class="comment"><p>Результатом є знак суми: -1 або +1.
Тут персептрон робить припущення
по яку сторону лінії знаходяться поточні дані.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Імовірно, тепер я можу створити об’єкт <code>Perceptron</code> і попросити його зробити припущення для будь-якої точки, як на малюнку 10.7.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1231&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/c48a7b768526aed01c79a10313c5c00d/80097/10_nn_8.webp 576w,./static/c48a7b768526aed01c79a10313c5c00d/3a6ad/10_nn_8.webp 1152w,./static/c48a7b768526aed01c79a10313c5c00d/5e857/10_nn_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/c48a7b768526aed01c79a10313c5c00d/4c1b8/10_nn_8.png" data-srcset="./static/c48a7b768526aed01c79a10313c5c00d/762f0/10_nn_8.png 576w,./static/c48a7b768526aed01c79a10313c5c00d/f6901/10_nn_8.png 1152w,./static/c48a7b768526aed01c79a10313c5c00d/4c1b8/10_nn_8.png 2304w" alt="Малюнок 10.7: Координата (x, y) з 2D простору є вхідним значення для персептрона"/></picture><noscript><picture><source type="image/webp" srcSet="./static/c48a7b768526aed01c79a10313c5c00d/80097/10_nn_8.webp 576w,./static/c48a7b768526aed01c79a10313c5c00d/3a6ad/10_nn_8.webp 1152w,./static/c48a7b768526aed01c79a10313c5c00d/5e857/10_nn_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/c48a7b768526aed01c79a10313c5c00d/4c1b8/10_nn_8.png" srcSet="./static/c48a7b768526aed01c79a10313c5c00d/762f0/10_nn_8.png 576w,./static/c48a7b768526aed01c79a10313c5c00d/f6901/10_nn_8.png 1152w,./static/c48a7b768526aed01c79a10313c5c00d/4c1b8/10_nn_8.png 2304w" alt="Малюнок 10.7: Координата (x, y) з 2D простору є вхідним значення для персептрона"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.7: Координата <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span></span></span></span></span> з 2D простору є вхідним значення для персептрона</figcaption>
</figure>
<p>Ось код для створення припущення:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> perceptron = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Perceptron</span>(<span class="hljs-number">3</span>);
</code></pre><div class="comment"><p>Створення персептрона.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> inputs = [<span class="hljs-number">50</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">1</span>];
</code></pre><div class="comment"><p>Вхідними даними є три значення: x, y та bias.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> guess = perceptron.<span class="hljs-title function_">feedForward</span>(inputs);
</code></pre><div class="comment"><p>Результат припущення!</p></div></div></div>
<p>Чи персептрон зробив правильне припущення? Можливо так, а можливо і ні. У цей момент персептрон має шанси отримати правильну відповідь не більше ніж 50/50, оскі льки кожна вага починається з випадкового значення. Нейронна мережа не є чарівним інструментом, який може самостійно правильно вгадати. Мені потрібно навчити його, як це робити!</p>
<p>Щоб навчити нейронну мережу відповідати правильно, я скористаюся методом навчання з учителем, який я описав раніше в цьому розділі. Пам’ятайте, що цей підхід передбачає надання мережі вхідних даних із відомими відповідями. Це дає змогу мережі перевірити, чи правильні вона робить припущення. Якщо ні, мережа може навчитися на своїй помилці та скорегувати свої ваги. Процес виглядає наступним чином:</p>
<ol>
  <li>Надайте персептрону вхідні дані, для яких є відома відповідь.</li>
  <li>Попросіть персептрон вгадати відповідь.</li>
  <li>Обчисліть похибку. (Чи була відповідь правильною, чи неправильною?)</li>
</ol>
<div class="avoid-break">
  <ol>
    <li value="4">Відкоригуйте всі ваги відповідно до помилки.</li>
    <li value="5">Поверніться до кроку 1 і повторіть!</li>
  </ol>
</div>
<p>Цей процес можна запакувати у метод класу <code>Perceptron</code>, але спершу мені потрібно детальніше розібратися з кроками 3 і 4. Як я можу визначити помилку персептрона? І як мені відкоригувати ваги відповідно до цієї помилки?</p>
<p>Помилка персептрона може бути визначена як різниця між бажаною відповіддю та припущенням щодо неї:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>помилка</mtext><mo>=</mo><mtext>бажаний результат</mtext><mo>−</mo><mtext>припущення</mtext></mrow><annotation encoding="application/x-tex">\text{помилка} = \text{бажаний результат} - \text{припущення}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord cyrillic_fallback">помилка</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">бажаний</span><span class="mord"> </span><span class="mord cyrillic_fallback">результат</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">припущення</span></span></span></span></span></span></div>
<p>Ця формула виглядає знайомою? Згадайте формулу для керувальної сили рухомим об’єктом, яку ми проходили у <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a>:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>керувальна сила</mtext><mo>=</mo><mtext>бажана швидкість</mtext><mo>−</mo><mtext>поточна швидкість</mtext></mrow><annotation encoding="application/x-tex">\text{керувальна сила} = \text{бажана швидкість} - \text{поточна швидкість}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">керувальна</span><span class="mord"> </span><span class="mord cyrillic_fallback">сила</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">бажана</span><span class="mord"> </span><span class="mord cyrillic_fallback">швидкість</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">поточна</span><span class="mord"> </span><span class="mord cyrillic_fallback">швидкість</span></span></span></span></span></span></div>
<p>Це теж розрахунок похибки! Поточна швидкість слугує припущенням, а помилка (керувальна сила) вказує, як відрегулювати швидкість у правильному напрямку. Налаштування шви дкості об’єкта для слідування за ціллю подібне до налаштування ваги нейронної мережі щодо правильної відповіді.</p>
<p>Для персептрона результат має лише два можливих значення: +1 або -1. Тому можливі лише три варіанти помилки. Якщо персептрон вгадає правильну відповідь, тоді припущення дорівнює бажаному результату, а помилка дорівнює 0. Якщо правильна відповідь -1, а персептрон видав +1, тоді помилка дорівнює -2. Якщо правильна відповідь +1, а персептрон видав -1, тоді помилка дорівнює +2. Цей процес узагальнено у наступній таблиці:</p>
<table><thead><tr><th style="width:150px">Бажаний результат</th><th style="width:100px">Здогадка</th><th>Помилка</th></tr></thead><tbody><tr><td>–1</td><td>–1</td><td>0</td></tr><tr><td>–1</td><td>+1</td><td>–2</td></tr><tr><td>+1</td><td>–1</td><td>+2</td></tr><tr><td>+1</td><td>+1</td><td>0</td></tr></tbody></table>
<p>Помилка є визначальним фактором у тому, як слід регулювати ваги персептрона. Для будь-якої заданої ваги я хочу обчислити зміну ваги, яку часто називають <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext>ваги</mtext></mrow><annotation encoding="application/x-tex">\Delta\text{ваги}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord text"><span class="mord cyrillic_fallback">ваги</span></span></span></span></span></span> (або <em>дельтою ваги</em>, символ <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span></span></span></span></span> є грецькою буквою дельта):</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>нова вага</mtext><mo>=</mo><mtext>вага</mtext><mo>+</mo><mi mathvariant="normal">Δ</mi><mtext>ваги</mtext></mrow><annotation encoding="application/x-tex">\text{нова вага} = \text{вага} + \Delta\text{ваги}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord cyrillic_fallback">нова</span><span class="mord"> </span><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord text"><span class="mord cyrillic_fallback">ваги</span></span></span></span></span></span></div>
<p>Для розрахунку <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext>ваги</mtext></mrow><annotation encoding="application/x-tex">\Delta\text{ваги}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord text"><span class="mord cyrillic_fallback">ваги</span></span></span></span></span></span>, мені потрібно помножити помилку на вхідні дані:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext>вага</mtext><mo>=</mo><mtext>значення помилки</mtext><mo>×</mo><mtext>вхідне значення</mtext></mrow><annotation encoding="application/x-tex">\Delta\text{вага} = \text{значення помилки} \times \text{вхідне значення}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord text"><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord cyrillic_fallback">значення</span><span class="mord"> </span><span class="mord cyrillic_fallback">помилки</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">вхідне</span><span class="mord"> </span><span class="mord cyrillic_fallback">значення</span></span></span></span></span></span></div>
<p>Отже, нова вага розраховується наступним чином:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>нова вага</mtext><mo>=</mo><mtext>вага</mtext><mo>+</mo><mtext>значення помилки</mtext><mo>×</mo><mtext>вхідне значення</mtext></mrow><annotation encoding="application/x-tex">\text{нова вага} = \text{вага} + \text{значення помилки} \times \text{вхідне значення}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord cyrillic_fallback">нова</span><span class="mord"> </span><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord cyrillic_fallback">зна чення</span><span class="mord"> </span><span class="mord cyrillic_fallback">помилки</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord cyrillic_fallback">вхідне</span><span class="mord"> </span><span class="mord cyrillic_fallback">значення</span></span></span></span></span></span></div>
<p>Щоб зрозуміти, чому це працює, подумайте ще раз про керування. Зусилля керма — це, по суті, помилка у швидкості. Застосовуючи керувальну силу як прискорення (або <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mtext>швидкості</mtext></mrow><annotation encoding="application/x-tex">\Delta\text{швидкості}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord">Δ</span><span class="mord text"><span class="mord cyrillic_fallback">швидкості</span></span></span></span></span></span>), швидкість корегується для руху в правильному напрямку. Це те, що я хочу зробити з вагами нейронної мережі. Я хочу налаштувати їх у правильному напрямку в залежності від помилки.</p>
<p>Однак із керуванням у мене була додаткова змінна, яка контролювала здатність до керування: максимальне значення сили. Висока максимальна сила дозволяла об’єкту прискорюватися і швидко повертати, тоді як менша сила призводила до повільнішого регулювання швидкості. Нейронна мережа використовуватиме подібну стратегію зі змінною під назвою <strong>константа навчання</strong>:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>нова вага</mtext><mo>=</mo><mtext>вага</mtext><mo>+</mo><mo stretchy="false">(</mo><mtext>помилка</mtext><mo>×</mo><mtext>вхідне значення</mtext><mo stretchy="false">)</mo><mo>×</mo><mtext>константа навчання</mtext></mrow><annotation encoding="application/x-tex">\text{нова вага} = \text{вага} + (\text{помилка} \times \text{вхідне значення}) \times \text{константа навчання}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord cyrillic_fallback">нова</span><span class="mord"> </span><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord cyrillic_fallback">вага</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text"><span class="mord cyrillic_fallback">помилка</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord cyrillic_fallback">вхідне</span><span class="mord"> </span><span class="mord cyrillic_fallback">значення</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord text"><span class="mord cyrillic_fallback">константа</span><span class="mord"> </span><span class="mord cyrillic_fallback">навчання</span></span></span></span></span></span></div>
<p>Висока константа навчання призводить до більш різких змін ваги. Це може допомогти персептрону швидше знайти рішення, але це також збільшує ризик перевищення оптимальної ваги. Невелика константа навчання регулюватиме ваги повільніше і потребуватиме більше часу на навчання, але дозволить мережі вносити невеликі коригування, які можуть підвищити загальну точність.</p>
<p>Припускаючи додану до класу <code>Perceptron</code> властивість <code>learningConstant</code>, я можу написати метод навчання для персептрона, дотримуючись кроків, які описав раніше:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">train</span>(<span class="hljs-params">inputs, desired</span>) {
</code></pre><div class="comment"><p>Крок 1: надамо вхідні дані та відому відповідь.
Вони передаються як аргументи до методу train().</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> guess = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">feedForward</span>(inputs);
</code></pre><div class="comment"><p>Крок 2: зробимо здогадку відповідно до введених даних.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> error = desired - guess;
</code></pre><div class="comment"><p>Крок 3: обчислимо помилку (різниця між бажаним і припущеним значеннями).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i] + error * inputs[i] * <span class="hljs-variable language_">this</span>.<span class="hljs-property">learningConstant</span>;
    }
</code></pre><div class="comment"><p>Крок 4: Налаштуємо всі ваги відповідно до помилки та константи навчання.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ось повний клас <code>Perceptron</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Perceptron</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">totalInputs</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">learningConstant</span> = <span class="hljs-number">0.01</span>;
</code></pre><div class="comment"><p>Персептрон зберігає свої ваги і константу навчання.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalInputs; i++) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i] = <span class="hljs-title function_">random</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    }
</code></pre><div class="comment"><p>Напочатку ваги вибираються випадково.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">feedForward</span>(<span class="hljs-params">inputs</span>) {
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>.<span class="hljs-property">length</span>; i++) {
      sum += inputs[i] * <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">activate</span>(sum);
  }
</code></pre><div class="comment"><p>Повернення результату на основі вхідних даних.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">activate</span>(<span class="hljs-params">sum</span>) {
    <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
  }
</code></pre><div class="comment"><p>Можливі результати: +1 або -1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">train</span>(<span class="hljs-params">inputs, desired</span>) {
    <span class="hljs-keyword">let</span> guess = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">feedForward</span>(inputs);
    <span class="hljs-keyword">let</span> error = desired - guess;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p>Навчання мережі на основі відомих даних.</p></div></div><div class="continue pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">weights</span>[i] + error * inputs[i] * <span class="hljs-variable language_">this</span>.<span class="hljs-property">learningConstant</span>;
    }
  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Щоб навчити персептрон, мені потрібен набір вхідних даних із відомими відповідями. Однак для сценарію з ксерофітами й гідрофітами я не маю реального набору даних (чи часу, щоб дослідити та зібрати його). Насправді мета цієї демонстрації не в тому, щоб показати вам, як класифікувати рослини. Йдеться про те, як персептрон може дізнатися, чи знаходяться точки вище, чи нижче лінії на графіку, тому підійде будь-який набір точок. Іншими словами, для даного прикладу я можу просто вигадати дані.</p>
<p>Те, що я описую називають <strong>синтетичними даними</strong> — штучно згенерованими даними, які часто використовуються у машинному навчанні для створення контрольованих сценаріїв для навчання і тестування. У цьому випадку мої синтетичні дані складатимуться з набору випадкових вхідних точок, кожна з яких має відому відповідь, яка вказує, чи знаходиться точка вище, чи нижче лінії. Щоб визначити лінію і згенерувати дані, я використаю просту алгебру. Такий підхід дозволяє мені наочно продемонструвати процес навчання та показати, як навчається персептрон.</p>
<p>Отже, постає питання, як мені вибрати точку і дізнатися, чи вона знаходиться вище або нижче лінії (без нейронної мережі)? Пряму можна описати як сукупність точок, де <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-координата кожної точки є функцією її <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-координати:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></div>
<p>Для прямої лінії (зокрема, лінійної функції) залежність можна записати таким чином:</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mi>m</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = mx + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span></div>
<p>Тут <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span> — це нахил лінії, а <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span> — значення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>, коли <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> дорівнює 0 (точка перетину <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>). Ось конкретний приклад із відповідним графіком на малюнку 10.8.</p>
<div data-type="equation" class="math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y = \frac{1}2x - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span></div>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1050&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/ceef1edc36196ee357443e5afb8c155f/04a71/10_nn_9.webp 576w,./static/ceef1edc36196ee357443e5afb8c155f/66d28/10_nn_9.webp 1152w,./static/ceef1edc36196ee357443e5afb8c155f/5257a/10_nn_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/ceef1edc36196ee357443e5afb8c155f/debe6/10_nn_9.png" data-srcset="./static/ceef1edc36196ee357443e5afb8c155f/5dc90/10_nn_9.png 576w,./static/ceef1edc36196ee357443e5afb8c155f/d49a2/10_nn_9.png 1152w,./static/ceef1edc36196ee357443e5afb8c155f/debe6/10_nn_9.png 2304w" alt="Малюнок 10.8: Графік для функції y = \frac{1}2x - 1"/></picture><noscript><picture><source type="image/webp" srcSet="./static/ceef1edc36196ee357443e5afb8c155f/04a71/10_nn_9.webp 576w,./static/ceef1edc36196ee357443e5afb8c155f/66d28/10_nn_9.webp 1152w,./static/ceef1edc36196ee357443e5afb8c155f/5257a/10_nn_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/ceef1edc36196ee357443e5afb8c155f/debe6/10_nn_9.png" srcSet="./static/ceef1edc36196ee357443e5afb8c155f/5dc90/10_nn_9.png 576w,./static/ceef1edc36196ee357443e5afb8c155f/d49a2/10_nn_9.png 1152w,./static/ceef1edc36196ee357443e5afb8c155f/debe6/10_nn_9.png 2304w" alt="Малюнок 10.8: Графік для функції y = \frac{1}2x - 1"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.8: Графік для функції <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y = \frac{1}2x - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span></figcaption>
</figure>
<p>Я довільно виберу це рівняння для моєї лінії та напишу відповідну функцію:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * x - <span class="hljs-number">1</span>;
}
</code></pre><div class="comment"><p>Функція для обчислення y на основі x уздовж лінії.</p></div></div></div>
<p>Тепер питання у тому, що полотно p5.js за замовчуванням має початкову координату <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span> у верхньому лівому куті, а вісь <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> спрямована вниз. Для поточного прикладу я додав у код зміщення початкової точки у центр полотна, щоб переорієнтувати його до більш традиційного вигляду декартового простору:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title function_">translate</span>(width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p>Переміщення початкових координат (0, 0) до центру.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-title function_">scale</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Переворот орієнтації для y-осі, щоб позитивні значення йшли вгору від початкової точки.</p></div></div></div>
</div>
<p>Тепер я можу вибрати випадкову точку у 2D просторі:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-title function_">random</span>(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> y = <span class="hljs-title function_">random</span>(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Як дізнатися, що ця точка вище або нижче лінії? Лінійна функція <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> повертає значення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> на лінії для переданої <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-позиції. Я позначатиму це як <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mtext>line</mtext></msub></mrow><annotation encoding="application/x-tex">y_\text{line}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">line</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> yline = <span class="hljs-title function_">f</span>(x);
</code></pre><div class="comment"><p>y-позиція на лінії.</p></div></div></div>
<p>Якщо значення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>, яке я досліджую, знаходиться над лінією, то воно буде більшим за <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mtext>line</mtext></msub></mrow><annotation encoding="application/x-tex">y_\text{line}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">line</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>, як на малюнку 10.9.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1043&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/49b5572f36549d6346879c40ca14a137/e9966/10_nn_10.webp 576w,./static/49b5572f36549d6346879c40ca14a137/4213b/10_nn_10.webp 1152w,./static/49b5572f36549d6346879c40ca14a137/686ed/10_nn_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/49b5572f36549d6346879c40ca14a137/5fdb9/10_nn_10.png" data-srcset="./static/49b5572f36549d6346879c40ca14a137/5128f/10_nn_10.png 576w,./static/49b5572f36549d6346879c40ca14a137/7dfe0/10_nn_10.png 1152w,./static/49b5572f36549d6346879c40ca14a137/5fdb9/10_nn_10.png 2304w" alt="Малюнок 10.9: Якщо y_\text{line} менше за y, тоді точка знаходиться над лінією"/></picture><noscript><picture><source type="image/webp" srcSet="./static/49b5572f36549d6346879c40ca14a137/e9966/10_nn_10.webp 576w,./static/49b5572f36549d6346879c40ca14a137/4213b/10_nn_10.webp 1152w,./static/49b5572f36549d6346879c40ca14a137/686ed/10_nn_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/49b5572f36549d6346879c40ca14a137/5fdb9/10_nn_10.png" srcSet="./static/49b5572f36549d6346879c40ca14a137/5128f/10_nn_10.png 576w,./static/49b5572f36549d6346879c40ca14a137/7dfe0/10_nn_10.png 1152w,./static/49b5572f36549d6346879c40ca14a137/5fdb9/10_nn_10.png 2304w" alt="Малюнок 10.9: Якщо y_\text{line} менше за y, тоді точка знаходиться над лінією"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.9: Якщо <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mtext>line</mtext></msub></mrow><annotation encoding="application/x-tex">y_\text{line}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">line</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> менше за <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>, тоді точка знаходиться над лінією</figcaption>
</figure>
<p>Ось код для цієї логіки:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> desired = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (y &gt; yline) {
</code></pre><div class="comment"><p>Почнемо зі значення -1.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  desired = <span class="hljs-number">1</span>;
</code></pre><div class="comment"><p>Якщо y знаходиться над рискою, відповідь стає +1.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Далі я можу створити масив вхідних даних для виведення вихідного значення <code>desired</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> trainingInputs = [x, y, <span class="hljs-number">1</span>];
</code></pre><div class="comment"><p>Не забудьте включити похибку (значення баєса)!</p></div></div></div>
<p>Припускаючи, що у мене є змінна <code>perceptron</code>, я можу навчити її, надаючи вхідні дані разом із бажаною відповіддю:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">perceptron.<span class="hljs-title function_">train</span>(trainingInputs, desired);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо я навчаю персептрон на новій випадковій точці (та її відповіді) для кожної ітерації функції <code>draw()</code>, він поступово покращуватиме свою класифікацію точок для кращого визначення їх над або під лінією.</p>
<div data-type="example">
  <h3 id="example-101-the-perceptron"><a class="heading-link" href="#example-101-the-perceptron">Приклад 10.1: Персептрон</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/10_nn/10_1_perceptron_with_normalization"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/sMozIaMCW" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> perceptron;
</code></pre><div class="comment"><p>Персептрон.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> training = [];
</code></pre><div class="comment"><p>Масив для навчальних даних.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Лічильник для почергового відстеження точок тренувальних даних.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * x + <span class="hljs-number">1</span>;
}
</code></pre><div class="comment"><p>Формула лінії.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  perceptron = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Perceptron</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0.0001</span>);
</code></pre><div class="comment"><p>Персептрон матиме три вхідні значення (включаючи похибку) і швидкість навчання 0.0001.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) {
</code></pre><div class="comment"><p>Створення 2000 тренувальних точок.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">random</span>(-width / <span class="hljs-number">2</span>, width / <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> y = <span class="hljs-title function_">random</span>(-height / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    training[i] = [x, y, <span class="hljs-number">1</span>];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">translate</span>(width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>);
  <span class="hljs-title function_">scale</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Переорієнтація полотна відповідно до традиційної декартової площини.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
  <span class="hljs-title function_">line</span>(-width / <span class="hljs-number">2</span>, <span class="hljs-title function_">f</span>(-width / <span class="hljs-number">2</span>), width / <span class="hljs-number">2</span>, <span class="hljs-title function_">f</span>(width / <span class="hljs-number">2</span>));
</code></pre><div class="comment"><p>Малювання лінії.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> x = training[count][<span class="hljs-number">0</span>];
  <span class="hljs-keyword">let</span> y = training[count][<span class="hljs-number">1</span>];
</code></pre><div class="comment"><p>Отримання координат (x, y) для поточної точки даних навчання.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> desired = -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-title function_">f</span>(x)) {
    desired = <span class="hljs-number">1</span>;
  }
</code></pre><div class="comment"><p>Який бажаний результат?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  perceptron.<span class="hljs-title function_">train</span>(training[count], desired);
</code></pre><div class="comment"><p>Тренування персептрону.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  count = (count + <span class="hljs-number">1</span>) % training.<span class="hljs-property">length</span>;
</code></pre><div class="comment"><p>Для ефекту анімації тренування відбувається на одній точці за раз.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dataPoint <span class="hljs-keyword">of</span> training) {
    <span class="hljs-keyword">let</span> guess = perceptron.<span class="hljs-title function_">feedForward</span>(dataPoint);
    <span class="hljs-keyword">if</span> (guess &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-title function_">fill</span>(<span class="hljs-number">127</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>);
    }
    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">1</span>);
    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">circle</span>(dataPoint[<span class="hljs-number">0</span>], dataPoint[<span class="hljs-number">1</span>], <span class="hljs-number">8</span>);
  }
</code></pre><div class="comment"><p>Малювання всіх точок і розфарбування їх відповідно до вихідних результатів персептрона.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У прикладі 10.1 навчальні дані візуалізуються поруч із лінією цільового рішення. Кожн а точка представляє фрагмент навчальних даних, а її колір визначається поточною класифікацією персептрона — сірий для +1 або білий для -1. Я використовую невелику константу навчання (0.0001), щоб уповільнити з часом процес уточнення системою своїх класифікацій.</p>
<p>Цікавий аспект цього прикладу полягає у взаємозв’язку між вагами персептрона і характеристиками лінії, що розділяє точки, зокрема, кутом нахилу лінії та точкою перетину по вісі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> (<span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">m</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span> із рівняння <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>m</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = mx + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">b</span></span></span></span></span>). Ваги в цьому контексті не є просто довільними або “магічними” значеннями — вони безпосередньо пов’язані з геометрією набору даних. У цьому випадку я використовую лише 2D дані, але для багатьох застосувань машинного навчання дані існують у набагато більших вимірах. Вагові коефіцієнти нейронної мережі допомагають орієнтуватися у цих вимірах, визначаючи <em>гіперплощини</em> або межі рішень, які сегментують і кл асифікують дані.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-101"><a class="heading-link" href="#exercise-101">Вправа 10.1</a></h3>
  <p>Змініть код із прикладу 10.1, щоб під час процесу навчання також малювати поточну межу рішення персептрона — його найкраще припущення щодо того, де має бути лінія. Підказка: використовуйте поточні ваги персептрона, щоб обчислити рівняння лінії.</p>
</div>
<p>Хоча цей приклад персептрона пропонує концептуальну основу, набори даних реального світу часто мають більш різноманітні та динамічні діапазони вхідних значень. Для спрощеного сценарію тут діапазон значень для <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> більший, ніж для <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>, через розмір полотна 640 на 240. П опри це, приклад все ще працює — зрештою, функція активації знака не покладається на конкретні вхідні діапазони даних і це таке доволі просте завдання бінарної класифікації.</p>
<p>Однак дані реального світу часто мають набагато більшу складність з точки зору вхідних діапазонів. Для цього у машинному навчанні критично важливим кроком є <strong>нормалізація даних</strong>. Нормалізація даних передбачає таке відображення навчальних даних, щоб гарантувати, що всі вхідні дані (і вихідні) відповідали єдиному діапазону — як правило, від 0 до 1 або, можливо, від -1 до 1. Цей процес може покращити ефективність навчання і запобігти домінуванню окремих вхідних даних у процесі тренування. У продовженні розділу я вбудую у процес навчання нормалізацію даних, використовуючи бібліотеку ml5.js.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-102"><a class="heading-link" href="#exercise-102">Вправа 10.2</a></h3>
  <p>Чи можете ви замість використання навчання з учителем, навчити нейронну мережу знаходити правильні ваги за допомогою ГА?</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-103"><a class="heading-link" href="#exercise-103">Вправа 10.3</a></h3>
  <p>Додайте до прикладу нормалізацію даних. Чи покращує це ефективність навчання?</p>
</div>
<h2 id="putting-the-network-in-neural-network"><a class="heading-link" href="#putting-the-network-in-neural-network">Розміщення “мережі” у нейронній мережі</a></h2>
<p>Персептрон може мати кілька вхідних даних, але це все одно єдиний самотній нейрон. На жаль, це обмежує коло проблем, які він може вирішити. Справжня сила нейронних мереж проявляється у <em>мережевій</em> частині. З’єднайте разом кілька нейронів і ви зможете розв’язувати проблеми набагато більшої складності.</p>
<p>Якщо ви прочитаєте підручник зі штучного інтелекту, там буде сказано, що персептрон може розв’язувати лише задачі <strong>лінійної роздільності</strong>. Якщо набір даних є лінійно роздільним, ви можете побудувати його графік і класифікувати на дві групи, просто провівши пряму лінію (див. малюнок 10.10, ліворуч). Приклад класифікації рослин на ксерофіти або гідрофіти є лінійно роздільною проблемою.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;874&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/f839c8fbe3541aa5c69d9bce0cf7d65d/50acd/10_nn_11.webp 576w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/d0ea4/10_nn_11.webp 1152w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/6eeaa/10_nn_11.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/f839c8fbe3541aa5c69d9bce0cf7d65d/fb542/10_nn_11.png" data-srcset="./static/f839c8fbe3541aa5c69d9bce0cf7d65d/3c9bc/10_nn_11.png 576w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/9eb8a/10_nn_11.png 1152w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/fb542/10_nn_11.png 2304w" alt="Малюнок 10.10: Точки даних, які можна розділити лінійно (ліворуч), і точки даних, які можна розділити нелінійно, оскільки для розділення точок потрібна крива (праворуч)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/f839c8fbe3541aa5c69d9bce0cf7d65d/50acd/10_nn_11.webp 576w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/d0ea4/10_nn_11.webp 1152w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/6eeaa/10_nn_11.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/f839c8fbe3541aa5c69d9bce0cf7d65d/fb542/10_nn_11.png" srcSet="./static/f839c8fbe3541aa5c69d9bce0cf7d65d/3c9bc/10_nn_11.png 576w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/9eb8a/10_nn_11.png 1152w,./static/f839c8fbe3541aa5c69d9bce0cf7d65d/fb542/10_nn_11.png 2304w" alt="Малюнок 10.10: Точки даних, які можна розділити лінійно (ліворуч), і точки даних, які можна розділити нелінійно, оскільки для розділення точок потрібна крива (праворуч)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.10: Точки даних, які можна розділити лінійно (ліворуч), і точки даних, які можна розділити нелінійно, оскільки для розділення точок потрібна крива (праворуч)</figcaption>
</figure>
<p>А тепер уявіть, що ви класифікуєте рослини за кислотністю ґрунту (по вісі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>) і температурою (по вісі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>у</mtext></mrow><annotation encoding="application/x-tex">у</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord cyrillic_fallback">у</span></span></span></span></span>). Деякі рослини можуть процвітати на кислих ґрунтах, але лише у вузькому діапазоні температур, тоді як інші рослини віддають перевагу менш кислим ґрунтам, але витримують ширший діапазон температур. Між двома змінними існує складніший зв’язок, тому неможливо провести пряму лінію, щоб розділити дві категорії рослин на <em>ацидофіти</em> та <em>базофіти</em> (див. малюнок 10.10, праворуч). Самотній персептрон не може впоратися з таким типом <strong>нелінійно роздільної</strong> проблеми. (Застереження: я вигадую ці приклади, тож якщо ви ботанік, будь ласка, дайте мені знати, чи я близький до реальності.)</p>
<p>Одним із найпростіших прикладів нелінійно роздільної задачі є XOR (виключна диз’юнкція). Це логічний оператор, подібний до більш звичних логічних операцій AND (кон’юнкція) та OR (диз’юнкція). Щоб <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span> AND <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span> разом давали істину, і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span> повинні бути істинними. З використанням операції OR результат може бути істинним, коли істинним буде <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span> або <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span> (або обидва). Це обидві задачі, які можна розділити лінійно. Таблиці істинності на малюнку 10.11 показують їх просторові розв’язки. Кожне значення <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> або <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">se</span></span></span></span></span> у таблиці показує результат для певної комбінації вхідних даних <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> або <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">se</span></span></span></span></span>. Погляньте, як можна намалювати пряму лінію, що відокремить в такому випадку істинні результати від хибних.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;649&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/9b334be04699d92c59aa6db680427793/2c37a/10_nn_12.webp 576w,./static/9b334be04699d92c59aa6db680427793/47a3c/10_nn_12.webp 1152w,./static/9b334be04699d92c59aa6db680427793/642b6/10_nn_12.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/9b334be04699d92c59aa6db680427793/fe4e3/10_nn_12.png" data-srcset="./static/9b334be04699d92c59aa6db680427793/884ae/10_nn_12.png 576w,./static/9b334be04699d92c59aa6db680427793/d8cbb/10_nn_12.png 1152w,./static/9b334be04699d92c59aa6db680427793/fe4e3/10_nn_12.png 2304w" alt="Малюнок 10.11: Таблиці істинності для логічних операторів AND та OR. Істинні та хибні значення можуть бути розділені лінією"/></picture><noscript><picture><source type="image/webp" srcSet="./static/9b334be04699d92c59aa6db680427793/2c37a/10_nn_12.webp 576w,./static/9b334be04699d92c59aa6db680427793/47a3c/10_nn_12.webp 1152w,./static/9b334be04699d92c59aa6db680427793/642b6/10_nn_12.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/9b334be04699d92c59aa6db680427793/fe4e3/10_nn_12.png" srcSet="./static/9b334be04699d92c59aa6db680427793/884ae/10_nn_12.png 576w,./static/9b334be04699d92c59aa6db680427793/d8cbb/10_nn_12.png 1152w,./static/9b334be04699d92c59aa6db680427793/fe4e3/10_nn_12.png 2304w" alt="Малюнок 10.11: Таблиці істинності для логічних операторів AND та OR. Істинні та хибні значення можуть бути розділені лінією"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.11: Таблиці істинності для логічних операторів AND та OR. Істинні та хибні значення можуть бути розділені лінією</figcaption>
</figure>
<div class="avoid-break">
  <p>Оператор XOR є еквівалентом сукупності операторів ((OR) AND (NOT AND)). Іншими словами результат операції <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span></span> XOR <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05017em">B</span></span></span></span></span> оцінюється як <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span>, лише якщо одне із вхідних даних є істинним. Якщо обидва значення хибні або обидва істинні, то результат буде <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">se</span></span></span></span></span>. Для прикладу припустімо, що ви любите піцу з ананасами й любите піцу з грибами, але складіть їх разом і вийде таке собі! І звичайна піца теж не годиться!</p>
</div>
<p>Таблиця істинності для операції XOR на малюнку 10.12 не є лінійно роздільною. Спробуйте намалювати пряму ліні ю, щоб відокремити результати з <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span></span> від <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">se</span></span></span></span></span>, але не вийде!</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;738&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/a5dfc1f69d1776a3486507f5191a7353/79b4e/10_nn_13.webp 576w,./static/a5dfc1f69d1776a3486507f5191a7353/eb9d9/10_nn_13.webp 1152w,./static/a5dfc1f69d1776a3486507f5191a7353/97869/10_nn_13.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/a5dfc1f69d1776a3486507f5191a7353/15a6b/10_nn_13.png" data-srcset="./static/a5dfc1f69d1776a3486507f5191a7353/43d41/10_nn_13.png 576w,./static/a5dfc1f69d1776a3486507f5191a7353/568ad/10_nn_13.png 1152w,./static/a5dfc1f69d1776a3486507f5191a7353/15a6b/10_nn_13.png 2304w" alt="Малюнок 10.12: Таблиця істинності для XOR (виключне OR). Вихідні результати true і false не можуть бути розділені однією лінією"/></picture><noscript><picture><source type="image/webp" srcSet="./static/a5dfc1f69d1776a3486507f5191a7353/79b4e/10_nn_13.webp 576w,./static/a5dfc1f69d1776a3486507f5191a7353/eb9d9/10_nn_13.webp 1152w,./static/a5dfc1f69d1776a3486507f5191a7353/97869/10_nn_13.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/a5dfc1f69d1776a3486507f5191a7353/15a6b/10_nn_13.png" srcSet="./static/a5dfc1f69d1776a3486507f5191a7353/43d41/10_nn_13.png 576w,./static/a5dfc1f69d1776a3486507f5191a7353/568ad/10_nn_13.png 1152w,./static/a5dfc1f69d1776a3486507f5191a7353/15a6b/10_nn_13.png 2304w" alt="Малюнок 10.12: Таблиця істинності для XOR (виключне OR). Вихідні результати true і false не можуть бути розділені однією лінією"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.12: Таблиця істинності для XOR (виключне OR). Вихідні результати true і false не можуть бути розділені однією лінією</figcaption>
</figure>
<p>Той факт, що потенціал персептрона не здатний вирішити навіть щось таке просте, як XOR, може здатися надзвичайно обмеженим. Але що, якби я створив мережу з двох персептронів? Якщо один персептрон може вирішити лінійно роздільні результати операції OR, а інший один персептрон може розв’язати лінійно відокремлені результати операції NOT AND, тоді комбінація двох персептронів може розв’язати нелінійно відокремлені результати XOR.</p>
<p>Коли ви поєднуєте кілька персептронів, то отримуєте <strong>багатошаровий персептрон</strong>, мережу з багатьох нейронів (див. малюнок 10.13). Деякі з них є вхідними нейронами й отримують початкові вхідні дані, деякі можуть бути частиною так званого <strong>прихованого шару</strong> (оскільки вони безпосередньо не пов’язані ні з вхідними даними, ані з вихідними), а також є вихідні нейрони, з яких зчитуються результати.</p>
<p>Досі я візуалізував окремий персептрон одним кругом, що представляв нейрон, який обробляв свої вхідні сигнали. Тепер, коли я переходжу до більших мереж, типовіше представляти всі елементи (входи, нейрони, виходи) у вигляді кругів зі стрілками, які вказують на потік даних. На малюнку 10.13 ви можете побачити зображення вхідних даних і баєси, що надходять у прихований шар, який потім перетікає у вихід.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1134&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/1553da6604cafeec69ac6f7b5d7bf33b/7ec1f/10_nn_14.webp 576w,./static/1553da6604cafeec69ac6f7b5d7bf33b/fd85c/10_nn_14.webp 1152w,./static/1553da6604cafeec69ac6f7b5d7bf33b/8fba5/10_nn_14.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/1553da6604cafeec69ac6f7b5d7bf33b/1a3e9/10_nn_14.png" data-srcset="./static/1553da6604cafeec69ac6f7b5d7bf33b/a406c/10_nn_14.png 576w,./static/1553da6604cafeec69ac6f7b5d7bf33b/68377/10_nn_14.png 1152w,./static/1553da6604cafeec69ac6f7b5d7bf33b/1a3e9/10_nn_14.png 2304w" alt="Малюнок 10.13: Багатошаровий персептрон має ті самі входи та вихід, що й простий персептрон, але тепер він містить прихований шар нейронів"/></picture><noscript><picture><source type="image/webp" srcSet="./static/1553da6604cafeec69ac6f7b5d7bf33b/7ec1f/10_nn_14.webp 576w,./static/1553da6604cafeec69ac6f7b5d7bf33b/fd85c/10_nn_14.webp 1152w,./static/1553da6604cafeec69ac6f7b5d7bf33b/8fba5/10_nn_14.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/1553da6604cafeec69ac6f7b5d7bf33b/1a3e9/10_nn_14.png" srcSet="./static/1553da6604cafeec69ac6f7b5d7bf33b/a406c/10_nn_14.png 576w,./static/1553da6604cafeec69ac6f7b5d7bf33b/68377/10_nn_14.png 1152w,./static/1553da6604cafeec69ac6f7b5d7bf33b/1a3e9/10_nn_14.png 2304w" alt="Малюнок 10.13: Багатошаровий персептрон має ті самі входи та вихід, що й простий персептрон, але тепер він містить прихований шар нейронів"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.13: Багатошаровий персептрон має ті самі входи та вихід, що й простий персептрон, але тепер він містить прихований шар нейронів</figcaption>
</figure>
<p>Навчання простого персептрона досить просте: ви пропускаєте дані та оцінюєте, як змінити ваги вхідних даних відповідно до помилки. Однак із багатошаровим персептроном процес навчання стає складнішим. Загальний вихід мережі все ще генерується по суті таким же чином, як і раніше: вхідні дані, помножені на ваги, додаються та передаються через різні рівні мережі. І ви все ще використовуєте припущення мережі, щоб обчислити помилку (бажаний результат мінус припущення). Але тепер існує досить багато зв’язків між рівнями мережі, кожен з яких має свою вагу. Як дізнатися, який внесок кожного нейрона або їх з’єднань має бути у загальній помилці мережі та як слід робити коригування?</p>
<p>Рішенням для оптимізації ваг багатошарової мережі є <strong>метод зворотного поширення помилки</strong>. Цей процес приймає помилку і передає її назад через мережу, щоб вона могла налаштувати ваги всіх з’єднань пропорційно до їх внеску у загальну помилку. Деталі зворотного поширення виходять за рамки цієї книги. Алгоритм використовує різноманітні функції активації (одним із класичних прикладів є сигмоїдна функція), а також деякі обчислення. Якщо вам цікаво продовжити цей шлях і дізнатися більше про те, як працює зворотне поширення, ви можете знайти мій проєкт <a href="https://thecodingtrain.com/toy-neural-network" target="_blank" rel="noopener">“Toy Neural Network” із супровідними відеоуроками на вебсайті Coding Train</a>. Вони показуються усі етапи розв’язання XOR, використовуючи багаторівневу мережу прямого поширення з методом зворотного поширення. Однак для продовження цього розділу я хочу отримати допомогу і зателефонувати другу.</p>
<h2 id="machine-learning-with-ml5js"><a class="heading-link" href="#machine-learning-with-ml5js">Машинне навчання з ml5.js</a></h2>
<p>Цей друг — ml5.js. Ця бібліотека машинного навчання може обробляти деталі складних процесів, як-от зворотне поширення, тож нам з вами не доведеться про них турбуватися. Як я вже згадував у цьому розділі, ml5.js має на меті надати дружню точку входу для тих, хто тільки починає знайомитися з машинним навчанням і нейронними мережами, водночас використовуючи за лаштунками потужність Google TensorFlow.js.</p>
<p>Щоб використовувати ml5.js у програмі, бібліотеку потрібно імпортувати через тег <code>&lt;script&gt;</code> у вашому файлі <em>index.html</em>, подібно до того, як ви робили це для Matter.js і Toxiclibs.js у <a href="/physics-libraries#section-physics-libraries">Розділі 6</a>:</p>
<div class="codesplit callout not-prose" data-code-language="html"><div class="pair"><pre><code class="hljs code language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/ml5@l/dist/ml5.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><div class="comment"><p></p></div></div></div>
<p>Моя мета до кінця цього розділу — показати роботу з ml5.js шляхом розробки системи, яка може розпізнавати рухи комп’ютерної миші. Це підготує вас до <a href="/neuroevolution#section-neuroevolution">Розділу 11</a>, де я додам “мозок” нейронної мережі до агента, що керуватиметься автономно, і зв’яжу машинне навчання з попередніми подіями цієї книги. Однак спочатку я хотів би більш загально поговорити про етапи навчання моделі багатошарової нейронної мережі за допомогою навчання під наглядом. Опис цих кроків висвітлить важливі рішення, які вам доведеться прийняти перед розробкою моделі навчання, представить синтаксис бібліотеки ml5.js і надасть вам контекст, який знадобиться перед навчанням власних моделей машинного навчання.</p>
<h3 id="the-machine-learning-life-cycle"><a class="heading-link" href="#the-machine-learning-life-cycle">Життєвий цикл машинного навчання</a></h3>
<p>Життєвий цикл моделі машинного навчання зазвичай розбивається на сім етапів:</p>
<ol>
  <li><strong>Збір даних.</strong> Дані складають основу будь-якого завдання машинного навчання. Цей етап може включати проведення експериментів, введення значень вручну, отримання загальнодоступних даних або безліч інших методів (наприклад, створення синтетичних даних).</li>
  <li><strong>Підготовка даних.</strong> Необроблені дані часто не мають формату, придатного для алгоритмів машинного навчання. Вони також можуть мати якісь повторювані чи відсутні значення або містити викиди, що перекошують дані. Такі невідповідності можливо доведеться скоригувати вручну. Крім того, як я вже згадував раніше, нейронні мережі найкраще працюють із нормалізованими даними, які мають значення, масштабовані відповідно до стандартного діапазону. Іншою важливою частиною підготовки даних є розділення їх на окремі набори для навчання, валідації й тестування. Навчальні дані використовуються для навчання моделі (крок 4), тоді як дані валідації та тестування (різниця незначна — докладніше про це пізніше) відкладаються і резервуються для оцінки продуктивності моделі (крок 5).</li>
  <li><strong>Вибір моделі.</strong> Розробка архітектури нейронної мережі. Різні моделі можуть бути більш підхожими для певних типів даних і відповідних виходів.</li>
</ol>
<div class="avoid-break">
  <ol>
    <li value="4"><strong>Тренування моделі.</strong> Проведення навчальної частини даних через модель і регулювання моделлю ваг нейронної мережі на основі її помилок. Цей процес відомий як <strong>оптимізація</strong>: модель налаштовує ваги таким чином, щоб вони призводили до найменшої кількості помилок.</li>
  </ol>
</div>
<ol>
  <li value="5"><strong>Оцінка моделі.</strong> Пам’ятаєте валідаційні дані, які були відкладені на кроці 2? Оскільки ці дані не використовувалися під час навчання, вони дають змогу оцінити наскільки добре модель працює на нових, невідомих даних.</li>
  <li value="6"><strong>Налаштування параметрів.</strong> На процес навчання впливає набір параметрів (часто називають <strong>гіперпараметрами</strong>), таких як швидкість навчання, яка визначає, наскільки сильно модель повинна коригувати свої ваги на основі помилок у своїх передбаченнях. У прикладі персептрона це була константа навчання. Тонко налаштувавши ці параметри й переглянувши крок 4 (навчання), 3 (вибір моделі)  або навіть 2 (підготовка даних), ви часто зможете покращити продуктивність моделі.</li>
  <li value="7"><strong>Розгортання моделі.</strong> Коли модель навчена і її продуктивність оцінена задовільно, настає час використовувати модель у реальному світі з новими даними!</li>
</ol>
<p>Ці кроки є наріжним каменем керованого машинного навчання. Однак, попри те, що 7 – справді чудове число, я думаю, що я пропустив ще один важливий крок. Я назву його кроком 0.</p>
<ol>
  <li value="0"><strong>Визначення проблеми.</strong> Цей початковий крок визначає проблему, яку потрібно вирішити. Яка мета? Що ви намагаєтеся досягти або передбачити за допомогою своєї моделі машинного навчання?</li>
</ol>
<p>Цей нульовий крок інформує всі інші кроки процесу. Зрештою, як ви можете збирати дані та вибирати модель, не знаючи, що ви намагаєтеся зробити? Ви прогнозуєте число? Категорію? Послідовність? Це бінарний вибір, чи є багато варіантів? Такого роду запитання часто зводяться до вибору між двома типами задач, до яких відноситься більшість програм машинного навчання: класифікації та регресії.</p>
<h3 id="classification-and-regression"><a class="heading-link" href="#classification-and-regression">Класифікація і регресія</a></h3>
<p><strong>Класифікація</strong> — це тип задачі машинного навчання, яка включає прогнозування <strong>мітки</strong> (також називається <strong>категорією</strong> або <strong>класом</strong>) для частини даних. Якщо це звучить знайомо, це тому, що так і є: простий персептрон у прикладі 10.1 був навчений класифікувати точки як точки над або під лінією. Іншим прикладом може бути класифікатор зображень, який намагається вгадати, чи на фотографії зображено кота, чи собаку і присвоїти відповідну мітку (див. малюнок 10.14).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;890.9999999999999&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/3871448e5dd4ce7e398121b5eee8d228/20e81/10_nn_15.webp 576w,./static/3871448e5dd4ce7e398121b5eee8d228/2f629/10_nn_15.webp 1152w,./static/3871448e5dd4ce7e398121b5eee8d228/50eb6/10_nn_15.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/3871448e5dd4ce7e398121b5eee8d228/9f1f2/10_nn_15.png" data-srcset="./static/3871448e5dd4ce7e398121b5eee8d228/409bc/10_nn_15.png 576w,./static/3871448e5dd4ce7e398121b5eee8d228/8709b/10_nn_15.png 1152w,./static/3871448e5dd4ce7e398121b5eee8d228/9f1f2/10_nn_15.png 2304w" alt="Малюнок 10.14: Виставлення зображенням міток котів чи собак"/></picture><noscript><picture><source type="image/webp" srcSet="./static/3871448e5dd4ce7e398121b5eee8d228/20e81/10_nn_15.webp 576w,./static/3871448e5dd4ce7e398121b5eee8d228/2f629/10_nn_15.webp 1152w,./static/3871448e5dd4ce7e398121b5eee8d228/50eb6/10_nn_15.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/3871448e5dd4ce7e398121b5eee8d228/9f1f2/10_nn_15.png" srcSet="./static/3871448e5dd4ce7e398121b5eee8d228/409bc/10_nn_15.png 576w,./static/3871448e5dd4ce7e398121b5eee8d228/8709b/10_nn_15.png 1152w,./static/3871448e5dd4ce7e398121b5eee8d228/9f1f2/10_nn_15.png 2304w" alt="Малюнок 10.14: Виставлення зображенням міток котів чи собак"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.14: Виставлення зображенням міток котів чи собак</figcaption>
</figure>
<p>Класифікація не відбувається за допомогою чарівної палички. Спочатку моделі потрібно показати багато прикладів собак і котів з правильними мітками, щоб правильно налаштувати ваги всіх з’єднань. Це тренувальна частина контрольованого навчання.</p>
<p>Класичне “Hello, world!” у світі машинного навчання і навчання під наглядом є проблемою класифікації набору даних MNIST. <strong>MNIST</strong>, скорочення від <em>Modified National Institute of Standards and Technology</em> – це набір даних, який збирали й опрацьовували Янн ЛеКун, (Інститут Куранта, NYU), Корінна Кортес (Google Labs) і Крістофер Дж. К. Берджес (Microsoft Research). Цей набір даних, який широко використовується для навчання і тестування у сфері машинного навчання, складається з 70 000 рукописних цифр від 0 до 9. Кожне зображення зроблене з градацій сірого кольору і має розмір 28 на 28 пікселів (приклади дивіться на малюнку 10.15). Кожне зображення позначено відповідною цифрою.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2000px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;939&#x27; width=&#x27;2000&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/039611cb4868fa4487268dcb6e697d1f/9d9de/10_nn_16.webp 500w,./static/039611cb4868fa4487268dcb6e697d1f/27af2/10_nn_16.webp 1000w,./static/039611cb4868fa4487268dcb6e697d1f/69c04/10_nn_16.webp 2000w" sizes="(min-width: 2000px) 2000px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2000px) 2000px, 100vw" decoding="async" loading="lazy" data-src="./static/039611cb4868fa4487268dcb6e697d1f/197e2/10_nn_16.png" data-srcset="./static/039611cb4868fa4487268dcb6e697d1f/b6e78/10_nn_16.png 500w,./static/039611cb4868fa4487268dcb6e697d1f/a7c43/10_nn_16.png 1000w,./static/039611cb4868fa4487268dcb6e697d1f/197e2/10_nn_16.png 2000w" alt="Малюнок 10.15: Вибір рукописних цифр 0–9 із набору даних MNIST (зображення люб’язно надано Suvanjanprasai)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/039611cb4868fa4487268dcb6e697d1f/9d9de/10_nn_16.webp 500w,./static/039611cb4868fa4487268dcb6e697d1f/27af2/10_nn_16.webp 1000w,./static/039611cb4868fa4487268dcb6e697d1f/69c04/10_nn_16.webp 2000w" sizes="(min-width: 2000px) 2000px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2000px) 2000px, 100vw" decoding="async" loading="lazy" src="./static/039611cb4868fa4487268dcb6e697d1f/197e2/10_nn_16.png" srcSet="./static/039611cb4868fa4487268dcb6e697d1f/b6e78/10_nn_16.png 500w,./static/039611cb4868fa4487268dcb6e697d1f/a7c43/10_nn_16.png 1000w,./static/039611cb4868fa4487268dcb6e697d1f/197e2/10_nn_16.png 2000w" alt="Малюнок 10.15: Вибір рукописних цифр 0–9 із набору даних MNIST (зображення люб’язно надано Suvanjanprasai)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.15: Вибір рукописних цифр 0–9 із набору даних MNIST (зображення люб’язно надано Suvanjanprasai)</figcaption>
</figure>
<p>MNIST є канонічним прикладом навчального набору даних для класифікації зображень: модель має дискретну кількість категорій на вибір (10, якщо бути точним, ні більше, ні менше). Після того, як модель натренована на 70 000 підписаних зображеннях, мета полягає в тому, щоб вона класифікувала нові зображення і призначала їм відповідну мітку, цифру від 0 до 9.</p>
<p>З іншого боку, <strong>регресія</strong> — це завдання машинного навчання, для якого прогноз є безперервним значенням, як правило, числом з рухомою крапкою. Регресійна задача може включати кілька вихідних результатів, але для початку простіше думати лише про одне. Наприклад, розглянемо модель машинного навчання, яка прогнозує щоденне споживання електроенергії будинку на основі вхідних факторів, таких як кількість мешканців, розмір будинку і температура на вулиці (див. малюнок 10.16).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1365&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/6e89544faab1495262b784fb2c0795a9/82a8f/10_nn_17.webp 576w,./static/6e89544faab1495262b784fb2c0795a9/c9cfe/10_nn_17.webp 1152w,./static/6e89544faab1495262b784fb2c0795a9/1b520/10_nn_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/6e89544faab1495262b784fb2c0795a9/e7af6/10_nn_17.png" data-srcset="./static/6e89544faab1495262b784fb2c0795a9/a629a/10_nn_17.png 576w,./static/6e89544faab1495262b784fb2c0795a9/706a3/10_nn_17.png 1152w,./static/6e89544faab1495262b784fb2c0795a9/e7af6/10_nn_17.png 2304w" alt="Малюнок 10.16: Такі фактори, як погода, розмір і кількість людей у будинку можуть впливати на щоденне споживання електроенергії"/></picture><noscript><picture><source type="image/webp" srcSet="./static/6e89544faab1495262b784fb2c0795a9/82a8f/10_nn_17.webp 576w,./static/6e89544faab1495262b784fb2c0795a9/c9cfe/10_nn_17.webp 1152w,./static/6e89544faab1495262b784fb2c0795a9/1b520/10_nn_17.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/6e89544faab1495262b784fb2c0795a9/e7af6/10_nn_17.png" srcSet="./static/6e89544faab1495262b784fb2c0795a9/a629a/10_nn_17.png 576w,./static/6e89544faab1495262b784fb2c0795a9/706a3/10_nn_17.png 1152w,./static/6e89544faab1495262b784fb2c0795a9/e7af6/10_nn_17.png 2304w" alt="Малюнок 10.16: Такі фактори, як погода, розмір і кількість людей у будинку можуть впливати на щоденне споживання електроенергії"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.16: Такі фактори, як погода, розмір і кількість людей у будинку можуть впливати на щоденне споживання електроенергії</figcaption>
</figure>
<p>Замість того, щоб вибирати з окремого набору вихідних параметрів, мета нейронної мережі тепер полягає в тому, щоб вгадати число — будь-яке число. Чи будинок використає цього дня 30.5 кіловат-годин електроенергії? Або 48.7 кВт·год? Або 100.2 кВт·год? Вихі дним прогнозом може бути будь-яке значення з безперервного діапазону.</p>
<h3 id="network-design"><a class="heading-link" href="#network-design">Проєктування мережі</a></h3>
<p>Знання того, яку проблему ви намагаєтеся вирішити (крок 0), також має значний вплив на дизайн нейронної мережі, зокрема, на її вхідний і вихідний рівні. Я продемонструю це на іншому класичному прикладі класифікації з галузі науки про дані й машинне навчання: набір даних про квітки ірису. Цей набір даних, який можна знайти у репозиторії Каліфорнійського університету машинного навчання, походить від роботи американського ботаніка Едгара Андерсона.</p>
<p>Андерсон збирав дані про квіти протягом багатьох років у багатьох регіонах Сполучених Штатів і Канади. Щоб дізнатися більше про походження цього знаменитого набору даних, дивіться <a href="https://academic.oup.com/jrssig/article/18/6/26/7038520" target="_blank" rel="noopener">“The Iris Data Set: In Search of the Source of <em>Virginica</em>”</a> під авторством Ентоні Анвіна та Кіма Клейнмана. Після ретельного аналізу даних Андерсон створив таблицю для класифікації квітів ірисів на три різні види: <em>ірис щетинистий</em>, <em>ірис строкатий</em> та <em>ірис віргінський</em> (див. малюнок 10.17).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;892&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/20e81/10_nn_18.webp 576w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/e92ce/10_nn_18.webp 1152w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/ff96f/10_nn_18.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/f7aad/10_nn_18.png" data-srcset="./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/409bc/10_nn_18.png 576w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/50783/10_nn_18.png 1152w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/f7aad/10_nn_18.png 2304w" alt="Малюнок 10.17: Три різні види квітів ірису"/></picture><noscript><picture><source type="image/webp" srcSet="./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/20e81/10_nn_18.webp 576w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/e92ce/10_nn_18.webp 1152w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/ff96f/10_nn_18.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/f7aad/10_nn_18.png" srcSet="./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/409bc/10_nn_18.png 576w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/50783/10_nn_18.png 1152w,./static/e2d1d6ac9d6f4e0b2dccf4992055a8e9/f7aad/10_nn_18.png 2304w" alt="Малюнок 10.17: Три різні види квітів ірису"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.17: Три різні види квітів ірису</figcaption>
</figure>
<p>Андерсон включив чотири числові атрибути для кожної квітки: довжину чашолистка, ширину чашолистка, довжину пелюстки й ширину пелюстки, усі виміряні в сантиметрах. (Він також записав інформацію про колір, але ці дані, здається, були втрачені.) Кожен запис потім поєднується з відповідною категорією ірису:</p>
<table><thead><tr><th>Довжина чашолистка</th><th>Ширина чашолистка</th><th>Довжина пелюстки</th><th>Ширина пелюстки</th><th>Класифікація</th></tr></thead><tbody><tr><td>5.1</td><td>3.5</td><td>1.4</td><td>0.2</td><td><em>Ірис щетинистий</em></td></tr><tr><td>4.9</td><td>3.0</td><td>1.4</td><td>0.2</td><td><em>Ірис щетинистий</em></td></tr><tr><td>7.0</td><td>3.2</td><td>4.7</td><td>1.4</td><td><em>Ірис строкатий</em></td></tr><tr><td>6.4</td><td>3.2</td><td>4.5</td><td>1.5</td><td><em>Ірис строкатий</em></td></tr><tr><td>6.3</td><td>3.3</td><td>6.0</td><td>2.5</td><td><em>Ірис віргінський</em></td></tr><tr><td>5.8</td><td>2.7</td><td>5.1</td><td>1.9</td><td><em>Ірис віргінський</em></td></tr></tbody></table>
<p>У цьому наборі даних перші чотири стовпці (довжина чашолистка, ширина чашолистка, довжина пелюстки, ширина пелюстки) слугують вхідними даними для нейронної мережі. Результатом є класифікація, наведена у п’ятому стовпці. На малюнку 10.18 зображено можливу архітектуру нейронної мережі, яку можна навчити на цих даних.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1379&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/a239ffb554888efa65c5e151d02d6183/96b93/10_nn_19.webp 576w,./static/a239ffb554888efa65c5e151d02d6183/9d1d4/10_nn_19.webp 1152w,./static/a239ffb554888efa65c5e151d02d6183/737ed/10_nn_19.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/a239ffb554888efa65c5e151d02d6183/8d508/10_nn_19.png" data-srcset="./static/a239ffb554888efa65c5e151d02d6183/43592/10_nn_19.png 576w,./static/a239ffb554888efa65c5e151d02d6183/ffa2a/10_nn_19.png 1152w,./static/a239ffb554888efa65c5e151d02d6183/8d508/10_nn_19.png 2304w" alt="Малюнок 10.18: Можлива архітектура мережі для класифікації ірисів"/></picture><noscript><picture><source type="image/webp" srcSet="./static/a239ffb554888efa65c5e151d02d6183/96b93/10_nn_19.webp 576w,./static/a239ffb554888efa65c5e151d02d6183/9d1d4/10_nn_19.webp 1152w,./static/a239ffb554888efa65c5e151d02d6183/737ed/10_nn_19.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/a239ffb554888efa65c5e151d02d6183/8d508/10_nn_19.png" srcSet="./static/a239ffb554888efa65c5e151d02d6183/43592/10_nn_19.png 576w,./static/a239ffb554888efa65c5e151d02d6183/ffa2a/10_nn_19.png 1152w,./static/a239ffb554888efa65c5e151d02d6183/8d508/10_nn_19.png 2304w" alt="Малюнок 10.18: Можлива архітектура мережі для класифікації ірисів"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.18: Можлива архітектура мережі для класифікації ірисів</figcaption>
</figure>
<p>Зліва знаходяться чотири входи в мер ежу, що відповідають першим чотирьом стовпцям таблиці даних. Праворуч є три можливі виходи, кожен з яких представляє одну з міток для виду квітки ірису. Між ними знаходиться прихований рівень, який, як згадувалося раніше, додає складності архітектурі мережі, необхідної для обробки нелінійно розділених даних. Кожен вузол у прихованому шарі з’єднаний з кожним вузлом, який знаходиться перед і після нього. Це зазвичай називають <strong>повністю з’єднаним</strong> або <strong>щільним</strong> шаром.</p>
<p>Ви також можете помітити відсутність явних вузлів баєса на цій діаграмі. У той час як похибки відіграють важливу роль у виході кожного нейрона, вони часто залишаються поза візуальним відображенням, щоб зберегти діаграми чистими й зосередженими на первинному потоці даних. (Бібліотека ml5.js зрештою керуватиме цим самостійно.)</p>
<p>Мета нейронної мережі полягає в тому, щоб “активувати” правильний вихід для вхідних даних, подібно до того, як персептрон виводить +1 або -1 для своєї єдиної бінарної класифікації. У цьому випадку вихідні значення схожі на сигнали, які допомагають мережі вирішити, яку мітку виду ірису призначити. На йвище обчислене значення активується, щоб показати найкраще припущення мережі щодо класифікації.</p>
<p>Ключовий висновок тут полягає в тому, що мережа класифікації повинна мати стільки входів, скільки значень для кожного елемента в наборі даних, і стільки виходів, скільки є категорій. Що стосується прихованого шару, його дизайн менш фіксований. Прихований шар на малюнку 10.18 має п’ять вузлів, але це число цілком довільне. Архітектури нейронних мереж можуть сильно відрізнятися і кількість прихованих вузлів часто визначається методом проб та помилок або іншими методами вгадування (так звані <em>евристики</em>). У контексті цієї книги я буду покладатися на ml5.js для автоматичного налаштування архітектури на основі вхідних і вихідних даних.</p>
<p>А як щодо входів і виходів у регресійному сценарії, як-от з прикладом споживання електроенергії домогосподарствами, про який я згадував раніше? Я створю набір даних для цього сценарію зі значеннями, що представляють мешканців і розмір будинку, денну температуру та відповідне споживання електроенергії. Це дуже схоже на синтетичний набір даних, враховуючи, що вони не зібрані для сценарію реального світу. Але в той час, як синтетичні дані генеруються автоматично, тут я вручну вводжу числа зі своєї власної уяви:</p>
<table><tbody><tr><td><strong>Мешканці</strong></td><td><strong>Розмір (m²)</strong></td><td><strong>Температура на вулиці (°C)</strong></td><td><strong>Споживання електроенергії (кВт·год)</strong></td></tr><tr><td>4</td><td>150</td><td>24</td><td>25.3</td></tr><tr><td>2</td><td>100</td><td>25.5</td><td>16.2</td></tr><tr><td>1</td><td>70</td><td>26.5</td><td>12.1</td></tr><tr><td>4</td><td>120</td><td>23</td><td>22.1</td></tr><tr><td>2</td><td>90</td><td>21.5</td><td>15.2</td></tr><tr><td>5</td><td>180</td><td>20</td><td>24.4</td></tr><tr><td>1</td><td>60</td><td>18.5</td><td>11.7</td></tr></tbody></table>
<p>Нейронна мережа для цієї задачі повинна мати три вхідні вузли, що відповідають першим трьом стовпцям (мешканці, розмір, температура). Тим часом вона повинна мати один вихідний вузол, що представляє четвертий стовпець — припущення мережі щодо споживання електроенергії. І я довільно вкажу, що прихований рівень мережі повинен мати чотири вузли, а не п’ять. На малюнку 10.19 показана архітектура цієї мережі.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1103&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/bc885fbe5ad07ecf954aa833d4c1423a/caff3/10_nn_20.webp 576w,./static/bc885fbe5ad07ecf954aa833d4c1423a/0b3eb/10_nn_20.webp 1152w,./static/bc885fbe5ad07ecf954aa833d4c1423a/254e8/10_nn_20.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/bc885fbe5ad07ecf954aa833d4c1423a/8bb13/10_nn_20.png" data-srcset="./static/bc885fbe5ad07ecf954aa833d4c1423a/6c4c7/10_nn_20.png 576w,./static/bc885fbe5ad07ecf954aa833d4c1423a/952a2/10_nn_20.png 1152w,./static/bc885fbe5ad07ecf954aa833d4c1423a/8bb13/10_nn_20.png 2304w" alt="Малюнок 10.19: Можлива мережева архітектура для трьох входів і одного регресійного виходу"/></picture><noscript><picture><source type="image/webp" srcSet="./static/bc885fbe5ad07ecf954aa833d4c1423a/caff3/10_nn_20.webp 576w,./static/bc885fbe5ad07ecf954aa833d4c1423a/0b3eb/10_nn_20.webp 1152w,./static/bc885fbe5ad07ecf954aa833d4c1423a/254e8/10_nn_20.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/bc885fbe5ad07ecf954aa833d4c1423a/8bb13/10_nn_20.png" srcSet="./static/bc885fbe5ad07ecf954aa833d4c1423a/6c4c7/10_nn_20.png 576w,./static/bc885fbe5ad07ecf954aa833d4c1423a/952a2/10_nn_20.png 1152w,./static/bc885fbe5ad07ecf954aa833d4c1423a/8bb13/10_nn_20.png 2304w" alt="Малюнок 10.19: Можлива мережева архітектура для трьох входів і одного регресійного виходу"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.19: Можлива мережева архітектура для трьох входів і одного регресійного виходу</figcaption>
</figure>
<p>На відміну від мережі класифікації ірисів, яка вибирає з трьох міток а, отже, має три виходи, ця мережа намагається спрогнозувати лише одне число, тому має лише один вихід. Однак я зауважу, що єдиний вихід не є вимогою регресії. Модель машинного навчання може також виконувати регресію, яка передбачає кілька значень і в такому випадку модель матиме кілька виходів.</p>
<h3 id="ml5js-syntax"><a class="heading-link" href="#ml5js-syntax">Синтаксис ml5.js</a></h3>
<p>Бібліотека ml5.js — це набір моделей машинного навчання, до яких можна отримати доступ за допомогою синтаксису <code>ml5.<em>functionName</em>()</code>. Наприклад, щоб використати попередньо навчену модель, яка визначає положення рук, ви можете викор истовувати <code>ml5.handPose()</code>. Для класифікації зображень можна використовувати <code>ml5.imageClassifier()</code>. Хоча я закликаю вас вивчити все, що може запропонувати ml5.js (я згадаю деякі з цих попередньо підготовлених моделей у майбутніх ідеях для вправ), у цій главі я зосереджуся лише на одній функції <code>ml5.neuralNetwork()</code>, яка створює порожню нейронну мережу для навчання.</p>
<p>Щоб скористатися цією функцією, ви повинні спочатку підготувати об’єкт JavaScript, який буде налаштовувати створювану модель. У властивостях можна задати деякі з аспектів загальної картини, які я щойно обговорював. Це завдання класифікації чи регресії? Скільки входів і виходів братиме участь у процесі? Я почну з визначення потрібного типу завдання, щоб модель виконувала <code>&quot;regression&quot;</code> або <code>&quot;classification&quot;</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = { <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;classification&quot;</span> };
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> classifier = ml5.<span class="hljs-title function_">neuralNetwork</span>(options);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Це, однак, дає ml5.js мало можливостей для розробки мережевої архітектури. Додавання входів і виходів завершить решту головоломки. Класифікація квітки ірису має чотири входи й три можливі вихідні мітки. Це можна налаштувати як частину об’єкта <code>options</code> з єдиним цілим числом для кількості вхідних даних і масиву рядків зі списком вихідних міток:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">inputs</span>: <span class="hljs-number">4</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">outputs</span>: [<span class="hljs-string">&quot;iris-setosa&quot;</span>, <span class="hljs-string">&quot;iris-virginica&quot;</span>, <span class="hljs-string">&quot;iris-versicolor&quot;</span>],
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;classification&quot;</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> digitClassifier = ml5.<span class="hljs-title function_">neuralNetwork</span>(options);
</code></pre><div class="comment"><p></p></div></div></div>
<p>У сценарії регресії споживання електроенергії було три вхідні значення (мешканці, розмір, температура) і одне вихідне значення (споживання кВт·год). У регресії немає вихідних міток-рядків, тому потрібне лише ціле число, що вказує кількість виходів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">inputs</span>: <span class="hljs-number">3</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">outputs</span>: <span class="hljs-number">1</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;regression&quot;</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> energyPredictor = ml5.<span class="hljs-title function_">neuralNetwork</span>(options);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Через об’єкт <code>options</code> ви можете налаштувати багато інших властивостей моделі. Наприклад, ви можете вказати кількість прихованих шарів між входами та виходами (зазвичай їх декілька), кількість нейронів у кожному шарі, які функції активації використовувати тощо. У більшості випадків, однак, ви можете не використовувати ці додаткові параметри й дозволити ml5.js зробити найкраще припущення про те, як спроєктувати модель на основі завдання і наявних даних.</p>
<h2 id="building-a-gesture-classifier"><a class="heading-link" href="#building-a-gesture-classifier">Створення класифікатора рухів</a></h2>
<p>Зараз я пройдуся по етапах життєвого циклу машинного навчання на прикладі проблеми, яка добре підходить для p5.js, створюючи весь код для кожного кроку за допомогою ml5.js. Я почну з кроку 0, сформулювавши проблему. Уявіть на мить, що ви працюєте над інтерактивною програмою, яка реагує на жести або певні рухи. Можливо, жести будуть призначені для створення записів на основі відстеження рухів тіла, але ви хочете почати з чогось набагато простішого — одного руху комп’ютерної миші (див. малюнок 10.20).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1018.9999999999999&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/70bb0719aa8a5963de053e50902d0d33/8c87b/10_nn_21.webp 576w,./static/70bb0719aa8a5963de053e50902d0d33/0bd73/10_nn_21.webp 1152w,./static/70bb0719aa8a5963de053e50902d0d33/1de14/10_nn_21.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/70bb0719aa8a5963de053e50902d0d33/42f17/10_nn_21.png" data-srcset="./static/70bb0719aa8a5963de053e50902d0d33/b7c0f/10_nn_21.png 576w,./static/70bb0719aa8a5963de053e50902d0d33/4ceec/10_nn_21.png 1152w,./static/70bb0719aa8a5963de053e50902d0d33/42f17/10_nn_21.png 2304w" alt="Малюнок 10.20: Один рух миші як вектор між початковою та кінцевою точками"/></picture><noscript><picture><source type="image/webp" srcSet="./static/70bb0719aa8a5963de053e50902d0d33/8c87b/10_nn_21.webp 576w,./static/70bb0719aa8a5963de053e50902d0d33/0bd73/10_nn_21.webp 1152w,./static/70bb0719aa8a5963de053e50902d0d33/1de14/10_nn_21.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/70bb0719aa8a5963de053e50902d0d33/42f17/10_nn_21.png" srcSet="./static/70bb0719aa8a5963de053e50902d0d33/b7c0f/10_nn_21.png 576w,./static/70bb0719aa8a5963de053e50902d0d33/4ceec/10_nn_21.png 1152w,./static/70bb0719aa8a5963de053e50902d0d33/42f17/10_nn_21.png 2304w" alt="Малюнок 10.20: Один рух миші як вектор між початковою та кінцевою точками"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.20: Один рух миші як вектор між початковою та кінцевою точками</figcaption>
</figure>
<p>Кожен рух може бути записаний як вектор, що простягається від початку до кінцевої точки руху миші. Координати вектора <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> будуть вхідними даними моделі. Завдання моделі полягатиме в тому, щоб передбачити одну з чотирьох можливих міток для руху: <em>вгору</em>, <em>вниз</em>, <em>вліво</em> або <em>вправо</em>. З дискретним набором можливих результатів це звучить як проблема класифікації. Чотири мітки будуть виходами моделі.</p>
<p>Подібно до деяких демонстрацій ГА-мів у <a href="/genetic-algorithms#section-genetic-algorithms">Розділі 9</a>, і як приклад простого персептрона, наведеного раніше у цій главі, проблема, яку я вибираю тут, має відоме рішення і її можна вирішити легше та ефективніше без нейронної мережі. Напрямок вектора можна класифікувати за допомогою функції <code>heading()</code> і ряду виразів з оператором <code>if</code>! Однак, використовуючи цей, здавалося б, тривіальний сценарій, я сподіваюся пояснити процес тренування моделі машинного навчання зрозумілим і дружнім способом. Крім того, цей приклад допоможе легко перевірити, чи код працює належним чином. Коли я закінчу, я дам кілька ідей про те, як розширити класифікатор для сценарію, який не зможе обійтися простим використанням <code>if</code>-операторів.</p>
<h3 id="collecting-and-preparing-the-data"><a class="heading-link" href="#collecting-and-preparing-the-data">Збір і підготовка даних</a></h3>
<p>Визначивши проблему, я можу перейти до кроків 1 і 2: збору і підготовки даних. У реальному світі ці кроки можуть бути виснажливими, особливо коли не оброблені дані, які ви збираєте, заплутані та потребують багато початкової обробки. Ви можете думати про це як про необхідність упорядкувати, помити й нарізати всі інгредієнти, перед приготуванням їжі.</p>
<p>Для простоти я хочу замість цього замовити “набір їжі” машинного навчання з уже розділеними та підготовленими інгредієнтами (даними). Таким чином я перейду безпосередньо до самого приготування, до процесу навчання моделі. Зрештою, це насправді лише закуска для того, що стане остаточною стравою у <a href="/neuroevolution#section-neuroevolution">Розділі 11</a>, коли я застосую нейронні мережі до керованих агентів.</p>
<p>З думкою про це, я закодую деякі приклади даних вручну і вручну збережу їх нормалізованими в діапазоні від -1 до +1. Я організую дані у масив об’єктів, об’єднавши <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-компоненти вектора з підписаною міткою. Я вибираю значення, які на мою думку, чітко вказують у певному напрямку, і призначаю відповідну мітку — по два приклади на кожну мітку:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> data = [
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.99</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.02</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;right&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.76</span>, <span class="hljs-attr">y</span>: -<span class="hljs-number">0.1</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;right&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: -<span class="hljs-number">1.0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.12</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;left&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: -<span class="hljs-number">0.9</span>, <span class="hljs-attr">y</span>: -<span class="hljs-number">0.1</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;left&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.02</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.98</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;down&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: -<span class="hljs-number">0.2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0.75</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;down&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: <span class="hljs-number">0.01</span>, <span class="hljs-attr">y</span>: -<span class="hljs-number">0.9</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;up&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  { <span class="hljs-attr">x</span>: -<span class="hljs-number">0.1</span>, <span class="hljs-attr">y</span>: -<span class="hljs-number">0.8</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&quot;up&quot;</span> },
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">];
</code></pre><div class="comment"><p></p></div></div></div>
<p>На малюнку 10.21 показані ті самі дані, позначені стрілкам.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;667&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/83292d2f0a8b9fd89780e8803b3d260d/57eb2/10_nn_22.webp 576w,./static/83292d2f0a8b9fd89780e8803b3d260d/8553d/10_nn_22.webp 1152w,./static/83292d2f0a8b9fd89780e8803b3d260d/ec1d6/10_nn_22.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/83292d2f0a8b9fd89780e8803b3d260d/6ff01/10_nn_22.png" data-srcset="./static/83292d2f0a8b9fd89780e8803b3d260d/6734c/10_nn_22.png 576w,./static/83292d2f0a8b9fd89780e8803b3d260d/be414/10_nn_22.png 1152w,./static/83292d2f0a8b9fd89780e8803b3d260d/6ff01/10_nn_22.png 2304w" alt="Малюнок 10.21: Вхідні дані, візуалізовані у вигляді векторів (стрілок)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/83292d2f0a8b9fd89780e8803b3d260d/57eb2/10_nn_22.webp 576w,./static/83292d2f0a8b9fd89780e8803b3d260d/8553d/10_nn_22.webp 1152w,./static/83292d2f0a8b9fd89780e8803b3d260d/ec1d6/10_nn_22.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/83292d2f0a8b9fd89780e8803b3d260d/6ff01/10_nn_22.png" srcSet="./static/83292d2f0a8b9fd89780e8803b3d260d/6734c/10_nn_22.png 576w,./static/83292d2f0a8b9fd89780e8803b3d260d/be414/10_nn_22.png 1152w,./static/83292d2f0a8b9fd89780e8803b3d260d/6ff01/10_nn_22.png 2304w" alt="Малюнок 10.21: Вхідні дані, візуалізовані у вигляді векторів (стрілок)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.21: Вхідні дані, візуалізовані у вигляді векторів (стрілок)</figcaption>
</figure>
<p>У більш реалістичному сценарії я, ймовірно, мав би набагато більший набір даних, який би завантажувався з окремого файлу, а не записувався безпосередньо в код. Наприклад, JSON та CSV є двома популярними форматами для зберігання та завантаження даних. JSON зберігає дані у парах ключ-значення та має той самий формат, що й літерали об’єктів JavaScript. CSV — це формат файлу, який зберігає табличні дані (як електронна таблиця), де значення розділені комами. Ви можете використовувати й багато інших форматів даних, залежно від ваших потреб та середовища програмування з яким ви працюєте.</p>
<p>У реальному світі значення для цього більшого набору даних насправді мають якесь надходження. Можливо, я збирав би дані, попросивши користувачів виконувати певні рухи та записуючи їхні дані, або написавши алгоритм для автоматичного генерування більшої кількості синтетичних даних, які представляють ідеалізовані версії рухів, які потрібні для розпізнавання моделлю. У будь-якому випадку ключовим кроком буде збір різноманітного набору прикладів, які адекватно представляють варіації того, як можуть виконуватися рухи. Однак наразі подивимось як це працює з кількома порціями даних.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-104"><a class="heading-link" href="#exercise-104">Вправа 10.4</a></h3>
  <p>Створіть програму p5.js, яка збирає дані рухів від користувачів і зберігає їх у файлі JSON. Для позначення початку і кінця кожного руху ви можете використовувати функції <code>mousePressed()</code> і <code>mouseReleased()</code>, а також функцію <code>saveJSON()</code>, щоб зберегти дані у файл.</p>
</div>
<h3 id="choosing-a-model"><a class="heading-link" href="#choosing-a-model">Вибір моделі</a></h3>
<p>Тепер я підійшов до третього кроку життєвого циклу машинного навчання — вибору моделі. Ось тут я збираюся дозволити бібліотеці ml5.js виконати важку роботу за мене. Щоб створити модель за допомогою ml5.js, все що мені потрібно зробити, це вказати завдання, вхідні дані й бажані виходи:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;classification&quot;</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">inputs</span>: <span class="hljs-number">2</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">outputs</span>: [<span class="hljs-string">&quot;up&quot;</span>, <span class="hljs-string">&quot;down&quot;</span>, <span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>],
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> classifier = ml5.<span class="hljs-title function_">neuralNetwork</span>(options);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ось воно! Я все зробив! Завдяки ml5.js я можу обійти безліч складнощів, таких як кількість шарів і нейронів для кожного шару, тип функцій активації, які потрібно використовувати, і те, як налаштувати алгоритми для навчання мережі. Бібліотека прийматиме ці рішення за мене.</p>
<p>Звісно, типова архітектура моделі ml5.js може бути не ідеальною для всіх випадків. Раджу додатково прочитати документацію ml5.js, щоб дізнатися більше про те, як налаштувати модель. Я також зазначу, що ml5.js може визначати вхідні та вихідні дані з набору даних, тому ці властивості не обов’язково включати тут в об’єкт <code>options</code>. Однак для ясності (і оскільки мені потрібно буде вказати їх для подальших прикладів), я включаю їх тут явним чином.</p>
<p>Якщо для властивості <code>debug</code> встановлено значення <code>true</code>, тоді вмикається візуальний інтерфейс для процесу навчання. Це корисний інструмент для виявлення потенційних проблем під час тренування і для кращого розуміння того, що відбувається за лаштунками. Як виглядає цей інтерфейс ви побачите далі у цьому розділі.</p>
<h3 id="training-the-model"><a class="heading-link" href="#training-the-model">Навчання моделі</a></h3>
<p>Тепер, коли у мене є дані у змінній <code>data</code> і нейронна мережа, ініціалізована у змінній <code>classifier</code>, я готовий навчати модель. Цей процес починається з додавання до моделі даних. І виявляється, що я для цього ще не закінчив їх підготовку.</p>
<p>Наразі мої дані акуратно організовано в масиві об’єктів, кожен з яких містить <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> та <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-компоненти вектора і відповідну мітку. Це типовий формат для навчальних даних, але ml5.js безпосередньо його не використовує. (Звісно, я міг би спочатку організувати дані у форматі, який розпізнає ml5.js, але я включаю цей додатковий крок, оскільки він, імовірно, буде необхідним, коли ви використовуєте набір даних зібраний або отриманий з інших джерел.) Щоб додати дані до моделі, мені потрібно відокремити входи від виходів, щоб ця модель розуміла де з них які.</p>
<p>Бібліотека ml5.js пропонує достатню гнучкість щодо кількості форматів, які вона приймає, але я оберу використання масиву: один для входів — <code>inputs</code> і один для ви ходів — <code>outputs</code>. Щоб реорганізувати кожен елемент даних і додати його до моделі я можу використати цикл:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> data) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> inputs = [item.<span class="hljs-property">x</span>, item.<span class="hljs-property">y</span>];
</code></pre><div class="comment"><p>Масив із двох чисел для вхідних даних.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> outputs = [item.<span class="hljs-property">label</span>];
</code></pre><div class="comment"><p>Одна мітка для вихідного значення.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  classifier.<span class="hljs-title function_">addData</span>(inputs, outputs);
</code></pre><div class="comment"><p>Додавання навчальних даних до класифікатора.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Що я тут зробив, так це встановив <strong>форму</strong> даних. У машинному навчанні цей термін описує розміри й структуру даних. Структура визначає організацію даних у вигляді рядків, стовпців і, потенційно, навіть глибше, з додатковими вимірами. Розуміння форми ваших даних має вирішальне значення, оскільки воно визначає спосіб структурування моделі.</p>
<p>Тут форма вхідних даних є 1D масивом, що містить два числа, які представляють <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>. Вихідні дані, так само, є 1D масивом, що містить лише одну мітку. Кожна частина даних, що надходить і виходить з мережі, буде відповідати цьому шаблону. Хоча це невеликий і простий приклад, він гарно відображає багато реальних сценаріїв, у яких вхідні дані представлені в масиві чисельними значеннями, а вихідні мітки є рядками.</p>
<p>Після передачі даних у класифікатор <code>classifier</code>, ml5.js надає допоміжний метод для їх нормалізації. Як я вже зазначав,  нормалізація даних (налаштування масштабу до стандартного діапазону) є критичним кроком у процесі машинного навчання:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">classifier.<span class="hljs-title function_">normalizeData</span>();
</code></pre><div class="comment"><p>Normalize the data.</p></div></div></div>
<p>У цьому випадку закодовані вручну дані були обмежені діапазоном від -1 до +1 від початку, тому виклик методу <code>normalizeData()</code> тут, ймовірно, зайвий. Проте цей виклик важливо продемонструвати. Завчасна нормалізація ваших даних як частина етапу попередньої підготовки безумовно спрацює, але наявність методу автоматичної нормалізації у ml5.js є хорошою підмогою!</p>
<p>Тепер серце процесу машинного навчання — власне навчання моделі. Ось код:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">classifier.<span class="hljs-title function_">train</span>(finishedTraining);
</code></pre><div class="comment"><p>Метод train() ініціює процес навчання.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">finishedTraining</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Training complete!&quot;</span>);
}
</code></pre><div class="comment"><p>Функція зворотного виклику, що спрацює після завершення навчання.</p></div></div></div>
<p>Так, це все! Адже важка робота вже завершена. Дані були зібрані, підготовлені та введені у модель. Все, що залишається, це викликати метод <code>train()</code>, розслабитися і дозволити ml5.js робити свою справу.</p>
<p>Насправді це <em>не настільки</em> просто. Якби я запустив написаний код, а потім перевірив модель, результати, ймовірно, були б неадекватними. Ось де в гру вступає ще один ключовий аспект машинного навчання — <strong>епохи</strong>. Метод <code>train()</code> говорить нейронній мережі почати процес навчання. Але як довго потрібно тренуватися? Ви можете розглядати епоху як один раунд практики, один цикл використання всього навчального набору даних для оновлення ваг нейронної мережі. Взагалі кажучи, чим більше епох ви проходите, тим краще працюватиме мережа, але в певний момент віддача буде зменшуватися. Кількість епох можна встановити, передавши у метод <code>train()</code> об’єкт з відповідними опціями:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = { <span class="hljs-attr">epochs</span>: <span class="hljs-number">25</span> };
</code></pre><div class="comment"><p>Встановлення кількості епох навчання.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">classifier.<span class="hljs-title function_">train</span>(options, finishedTraining);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Кількість епох є прикладом гіперпараметра — глобального параметра для процесу навчання. Через об’єкт опцій ви можете встановлювати й інші параметри (наприклад, швидкість навчання), але я залишусь зі стандартними значеннями. Ви можете прочитати більше про параметри налаштування у документації ml5.js.</p>
<p>Другий аргумент методу <code>train()</code> необов’язковий, але його добре включати. Він визначає функцію зворотного виклику, яка запускається після завершення процесу навчання — у цьому випадку це функція <code> finshedTraining()</code>. Це корисно, щоб дізнатися, коли можна переходити до наступних кроків нашого коду. Інший додатковий зворотний виклик, який я зазвичай називаю <code>whileTraining()</code>, запускається після кожної епохи. Однак для моїх цілей досить знати коли навчання закінчено повністю!</p>
<div data-type="note" class="callout">
  <h3 id="callbacks"><a class="heading-link" href="#callbacks">Зворотні виклики</a></h3>
  <p><strong>Функція зворотного виклику</strong> у JavaScript — це фу нкція, яку ви насправді не викликаєте самі. Замість цього ви надаєте її як аргумент іншій функції, маючи намір автоматично викликати її пізніше (зазвичай це пов’язано з якоюсь подією, наприклад клацанням миші). Ви бачили це раніше під час роботи з Matter.js у <a href="/physics-libraries#section-physics-libraries">Розділі 6</a>, де ви вказували функцію для виклику щоразу, коли виявлялося зіткнення.</p>
  <p>Зворотні виклики потрібні для <strong>асинхронних</strong> операцій, коли ви хочете, щоб ваш код продовжував анімацію або виконував інші дії, очікуючи на завершення певного завдання (наприклад, тренування моделі машинного навчання). Класичним прикладом такого підходу у p5.js є завантаження даних у програму за допомогою функції <code>loadJSON()</code>.</p>
  <p>JavaScript також надає більш сучасний підхід для обробки асинхронних операцій, відомих як <strong>promises</strong>. З промісами ви можете використовувати такі ключові слова, як <code>async</code> і <code>await</code>, щоб ваш асинхронний код виглядав як більш традиційний синхронний код. Хоча ml5.js також підтримує цей стиль, я буду використовувати зворотні виклики, щоб мій код залишався узгодженими зі стилем p5.js.</p>
</div>
<h3 id="evaluating-the-model"><a class="heading-link" href="#evaluating-the-model">Оцінка моделі</a></h3>
<p>Якщо при початковому виклику <code>ml5.neuralNetwork()</code>, параметр <code>debug</code> було встановлено як <code>true</code>, то після запуску методу <code>train()</code> повинен з’явитися візуальний інтерфейс, який перекриє більшу частину сторінки й полотна p5.js (див. малюнок 10.22). Цей інтерфейс, який називається <em>Visor</em>, представляє етап оцінювання.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1492px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1980&#x27; width=&#x27;1492&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/5914cf106edc6036cda6bfb3e8d96172/d8f12/10_nn_23.webp 373w,./static/5914cf106edc6036cda6bfb3e8d96172/46b9a/10_nn_23.webp 746w,./static/5914cf106edc6036cda6bfb3e8d96172/1bd42/10_nn_23.webp 1492w" sizes="(min-width: 1492px) 1492px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1492px) 1492px, 100vw" decoding="async" loading="lazy" data-src="./static/5914cf106edc6036cda6bfb3e8d96172/f8308/10_nn_23.png" data-srcset="./static/5914cf106edc6036cda6bfb3e8d96172/adafa/10_nn_23.png 373w,./static/5914cf106edc6036cda6bfb3e8d96172/1bdef/10_nn_23.png 746w,./static/5914cf106edc6036cda6bfb3e8d96172/f8308/10_nn_23.png 1492w" alt="Малюнок 10.22: Visor з графіком функції втрат і деталями моделі"/></picture><noscript><picture><source type="image/webp" srcSet="./static/5914cf106edc6036cda6bfb3e8d96172/d8f12/10_nn_23.webp 373w,./static/5914cf106edc6036cda6bfb3e8d96172/46b9a/10_nn_23.webp 746w,./static/5914cf106edc6036cda6bfb3e8d96172/1bd42/10_nn_23.webp 1492w" sizes="(min-width: 1492px) 1492px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1492px) 1492px, 100vw" decoding="async" loading="lazy" src="./static/5914cf106edc6036cda6bfb3e8d96172/f8308/10_nn_23.png" srcSet="./static/5914cf106edc6036cda6bfb3e8d96172/adafa/10_nn_23.png 373w,./static/5914cf106edc6036cda6bfb3e8d96172/1bdef/10_nn_23.png 746w,./static/5914cf106edc6036cda6bfb3e8d96172/f8308/10_nn_23.png 1492w" alt="Малюнок 10.22: Visor з графіком функції втрат і деталями моделі"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 10.22: Visor з графіком функції втрат і деталями моделі</figcaption>
</figure>
<p>Visor походить від TensorFlow.js (який лежить в основі ml5.js) і містить графік, який надає зворотний зв’язок у режимі реального часу щодо прогресу навчання. На цьому графіку на осі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> відкладаються втрати моделі від кількості епох уздовж осі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>. Втрати — це міра того, наскільки далекі прогнози моделі від правильних результатів, наданих навчальними даними. Він кількісно визначає загальну похибку моделі. Коли починається навчання, втрати зазвичай бувають великими, оскільки модель ще нічого не навчилася. В ідеалі, коли модель тренується через більшу кількість епох, вона має покращувати свої прогнози, а втрати мають зменшуватися. Якщо зі збільшенням епох графік опускається, це хороший знак!</p>
<p>Проведення навчання протягом 200 епох, зображених на малюнку 10.21, може здатися вам дещо надмірним. У реальному сценарії з більшими даними я б, ймовірно, використав менше епох, наприклад 25, які я вказав у вихідному фрагменті коду. Однак, оскільки набір даних тут дуже малий, більша кількість епох допомагає моделі отримати достатньо практики з даними. Пам’ятайте, що це іграшковий приклад, спрямований на розуміння концепцій, а не на створення складної моделі машинного навчання.</p>
<p>Під графіком Visor також показує підсумкову таблицю моделі з деталями архітектури моделі нижнього рівня, яку за лаштунками створив TensorFlow.js. Таблиця включає назви шарів, кількість нейронів на шар (у стовпці “Output Shape”) і кількість параметрів, тобто загальну кількість ваг, по одному для кожного з’єднання між двома нейронами. У цьому випадку dense_Dense1 — це прихований шар із 16 нейронами (кількість вибрана ml5.js), а dense_Dense2 — вихідний рівень із 4 нейронами, по одному для кожної категорії класифікації. (TensorFlow.js не розглядає вхідні дані як окремий рівень, вони радше є лише початковою точкою потоку даних.) Позначка “batch” у стовпці “Output Shape” не стосується конкретного числа, але вказує, що модель може обробляти змінну кількість навчальних даних (пакет) для будь-якого окремого циклу навчання моделі.</p>
<p>Коли я вперше окреслив етапи життєвого циклу машинного навчання, то зазначив, що для допомоги в процесі оцінювання, підготовка даних зазвичай передбачає поділ набору даних на три частини:</p>
<ul>
  <li><strong>Навчання (тренування):</strong> основний набір даних, який використовується для навчання моделі</li>
  <li><strong>Валідація:</strong> підмножина даних, яка використовується для перевірки моделі під час навчання, зазвичай наприкінці кожної епохи</li>
  <li><strong>Тестування:</strong> додаткові незмінні дані, які ніколи не розглядаються під час процесу навчання і потрібні для визначення кінцевої продуктивності моделі після завершення навчання</li>
</ul>
<p>Можливо, ви помітили, що я ніколи цього не робив. Для простоти я замість цього використав увесь набір даних для навчання. Зрештою, мій набір даних містить лише вісім записів — це занадто мало, щоб розділити його на три набори! З великим набором даних цей трьохчастинний розподіл буде більш доцільним.</p>
<p>Однак використання такого невеликого набору може призвести до <strong>перенавчання</strong> моделі: модель стає занадто налаштованою на конкретні особливості навчальних даних, що робить її значно менш ефективною під час роботи з новими, небаченими раніше даними. Основною причиною використання валідаційного набору полягає у моніторингу моделі під час процесу навчання. Під час навчання, якщо точність моделі поліпшується на навчальних даних, але погіршується на валідаційних, це є вагомим показником того, що може статися перенавчання. (Тестовий набір зберігається виключно для остаточної оцінки, однієї з останніх можливостей оцінити ефективність моделі після завершення тренування.)</p>
<p>Для більш реалістичних сценаріїв ml5.js надає спосіб розділення даних, а також автоматичні функції для використання валідаційних даних. Якщо ви хочете піти далі, то можете ознайомитися з повним набором прикладів нейронної мережі <a href="https://ml5js.org/" target="_blank" rel="noopener">на вебсайті ml5.js</a>.</p>
<h3 id="tuning-the-parameters"><a class="heading-link" href="#tuning-the-parameters">Налаштування параметрів</a></h3>
<p>Після етапу оцінювання зазвичай відбувається ітеративний процес коригування гіперпараметрів і повторного проходження навчання для досягнення найкращої продуктивності моделі. Хоча ml5.js пропонує можливості для налаштування параметрів (про які ви можете дізнатися у довідці бібліотеки), він насправді не спрямований на внесення низькорівневих тонких коригувань моделі. Якщо ви хочете розібратися з цим кроком більш детально, найкращим вибором може бути безпосереднє використання TensorFlow.js, оскільки він пропонує ширший набір інструментів і дозволяє контролювати процес навчання на нижчому рівні.</p>
<p>У цьому випадку налаштовувати параметри не обов’язково. Графік у Visor показує втрати до 0.1, що досить точно для моїх цілей. Я готовий рухатися далі.</p>
<h3 id="deploying-the-model"><a class="heading-link" href="#deploying-the-model">Розгортання моделі</a></h3>
<p>Нарешті настав час розгорнути модель і побачити результати цієї важкої роботи. Зазвичай це передбачає інтеграцію моделі в окрему програму для прогнозування або прийняття рішень на основі нових, раніше невідомих даних. Для цього ml5.js пропонує зручну функцію <code>save()</code>, щоб зберегти навчену модель у файлі з однієї програми та функцію <code>load()</code> для її завантаження і використання в іншій програмі. Це позбавляє вас від необхідності перенавчати модель з нуля щоразу, коли вам це потрібно.</p>
<p>Хоча модель, як правило, використовується в іншій прог рамі від тої де її було навчено, для спрощення я збираюся розгорнути модель у тій самій програмі. Після завершення процесу навчання отримана модель, по суті, вже розгорнута і доступна у поточній програмі. Вона зберігається у змінній <code>classifier</code> і може використовуватися для прогнозування, передаючи нові дані моделі через метод <code>classify()</code>. Форма даних, яка передається у <code>classify()</code> має збігатися з формою вхідних даних, які використовуються під час навчання — у цьому випадку це два числа з рухомою крапкою, що представляють <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> і <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span> компоненти вектора напрямку:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> direction = <span class="hljs-title function_">createVector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
</code></pre><div class="comment"><p>Ручне створення вектора.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> inputs = [direction.<span class="hljs-property">x</span>, direction.<span class="hljs-property">y</span>];
</code></pre><div class="comment"><p>Перетворення x і y компонентів у вхідний масив.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">classifier.<span class="hljs-title function_">classify</span>(inputs, gotResults);
</code></pre><div class="comment"><p>Класифікування моделлю вхідних даних.</p></div></div></div>
<p>Другим аргументом методу <code>classify()</code> є функція зворотного виклику, яка отримає доступ до результатів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">gotResults</span>(<span class="hljs-params">results</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Прогноз моделі передається у функцію зворотного виклику у вигляді аргументу, який у коді я назв ав <code>results</code>. Усередині результату ви знайдете масив можливих міток, відсортованих за <strong>вірогідністю</strong> і значення ймовірності, яку модель присвоює кожній мітці. Ці ймовірності показують рівень вірогідності моделі у цьому конкретному передбаченні. Вони варіюються від 0 до 1, причому значення, ближчі до 1, вказують на вищу ймовірність, а значення ближчі до 0 — про нижчу:</p>
<div class="codesplit callout not-prose" data-code-language="json"><div class="pair"><pre><code class="hljs code language-json"><span class="hljs-punctuation">[</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">{</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;right&quot;</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;confidence&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.9669702649116516</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">{</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;up&quot;</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;confidence&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.01878807507455349</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">{</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;down&quot;</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;confidence&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.013948931358754635</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">{</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;left&quot;</span><span class="hljs-punctuation">,</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">    <span class="hljs-attr">&quot;confidence&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.00029277068097144365</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json">  <span class="hljs-punctuation">}</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-json"><span class="hljs-punctuation">]</span>
</code></pre><div class="comment"><p></p></div></div></div>
<p>У цьому прикладі вихідних даних модель має високу впевненість (приблизно 96.7 відсотка), що правильна мітка це <code>&quot;right&quot;</code>, тоді як для мітки <code>&quot;left&quot;</code> вона має мінімальну впевненість (0.03 відсотка). Значення впевненості нормалізуються й у сумі складають 100 відсотків.</p>
<p>Усе, що залишилося, це доповнити програму кодом, щоб модель могла отримувати вхідні дані від миші у реальному часі. Першим кроком є сигнал про завершення процесу навчання, щоб користувач знав, що модель готова. Для відстеження процесу навчання й остаточного відображення передбаченої мітки на полотні я додам глобальну змінну <code>status</code>. Спочатку змінна ініціалізується значенням <code>&quot;training&quot;</code>, але оновлюється на <code>&quot;ready&quot;</code> у функції зворотного виклику <code>finishedTraining()</code>:</p>
<div class="avoid-break">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> status = <span class="hljs-string">&quot;training&quot;</span>;
</code></pre><div class="comment"><p>Коли програма почнеться, статус матиме значення &quot;training&quot;.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">textAlign</span>(<span class="hljs-variable constant_">CENTER</span>, <span class="hljs-variable constant_">CENTER</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">textSize</span>(<span class="hljs-number">64</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">text</span>(status, width / <span class="hljs-number">2</span>, height / <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">finishedTraining</span>(<span class="hljs-params"></span>) {
  status = <span class="hljs-string">&quot;ready&quot;</span>;
}
</code></pre><div class="comment"><p>Коли навчання буде завершено, ця функція зворотного виклику змінить значення статус на &quot;ready&quot;.</p></div></div></div>
</div>
<p>На завершення, я використаю функції p5.js для подій миші, щоб створити вектор руху під час перетягування миші й викличу метод <code>classifier.classify()</code>, передавши в нього налаштований вектор.</p>
<div data-type="example">
  <h3 id="example-102-gesture-classifier"><a class="heading-link" href="#example-102-gesture-classifier">Приклад 10.2: Класифікатор рухів</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/10_nn/10_2_gesture_classifier"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/SbfSv_GhM" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mousePressed</span>(<span class="hljs-params"></span>) {
  start = <span class="hljs-title function_">createVector</span>(mouseX, mouseY);
}
</code></pre><div class="comment"><p>Збереження початку руху після натискання миші.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseDragged</span>(<span class="hljs-params"></span>) {
  end = <span class="hljs-title function_">createVector</span>(mouseX, mouseY);
}
</code></pre><div class="comment"><p>Оновлення кінця руху під час перетягування миші.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseReleased</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Коли миша відпущена, потрібний рух завершено.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> dir = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">sub</span>(end, start);
  dir.<span class="hljs-title function_">normalize</span>();
</code></pre><div class="comment"><p>Обчислення і нормалізація вектора напрямку.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> inputs = [dir.<span class="hljs-property">x</span>, dir.<span class="hljs-property">y</span>];
  classifier.<span class="hljs-title function_">classify</span>(inputs, gotResults);
</code></pre><div class="comment"><p>Перетворення напрямку у вхідний масив і класифікація.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">gotResults</span>(<span class="hljs-params">error, results</span>) {
  status = results[<span class="hljs-number">0</span>].<span class="hljs-property">label</span>;
}
</code></pre><div class="comment"><p>Збереження отриманої мітки у змінній status для відображення на пол отні.</p></div></div></div>
<p>Якщо для прогнозу мені достатньо використовувати одну мітку я можу отримати доступ до першого елемента масиву результатів <code>results[0].label</code>, оскільки масив <code>results</code> відсортовано за вірогідністю від більших значень до менших. Значення цієї мітки передається до змінної <code>status</code>, яка буде відображена на полотні.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-105"><a class="heading-link" href="#exercise-105">Вправа 10.5</a></h3>
  <p>Розділіть приклад 10.2 на три програми: одну для збору даних, другу для навчання і третю для використання моделі. Використовуйте <code>ml5.neuralNetwork</code> і функції <code>save()</code> та <code>load()</code> для збереження та завантаження моделі у файл і відповідно зчитування з нього.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-106"><a class="heading-link" href="#exercise-106">Вправа 10.6</a></h3>
  <p>Розширте модель розпізнавання рухів для точнішої класифікації послідовності векторів, які складають шлях довшого руху миші. Пам’ятайте, що ваші вхідні дані повинні мати відповідну форму, тому доведеться вирішити, скільки векторів використовувати для представлення руху та зберігати не більше і не менше для кожної точки даних. Хоча цей підхід може працювати, інші моделі машинного навчання (такі як рекурентні нейронні мережі) спеціально розроблені для обробки послідовних даних і можуть запропонувати більшу гнучкість та потенційну точність.</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-107"><a class="heading-link" href="#exercise-107">Вправа 10.7</a></h3>
  <p>Одна з попередньо натренованих моделей у ml5.js називається <em>Handpose</em>. Вхідними даними моделі є зображення, а прогнозом список із 21 ключової точки — <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положень, відомих як <em>орієнтири</em>, які описують долоню.</p>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1179&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/a0c6008f4dc2e227487e0b392503e132/88534/10_nn_24.webp 576w,./static/a0c6008f4dc2e227487e0b392503e132/90be2/10_nn_24.webp 1152w,./static/a0c6008f4dc2e227487e0b392503e132/80ac5/10_nn_24.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/a0c6008f4dc2e227487e0b392503e132/c1250/10_nn_24.png" data-srcset="./static/a0c6008f4dc2e227487e0b392503e132/159ad/10_nn_24.png 576w,./static/a0c6008f4dc2e227487e0b392503e132/21940/10_nn_24.png 1152w,./static/a0c6008f4dc2e227487e0b392503e132/c1250/10_nn_24.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/a0c6008f4dc2e227487e0b392503e132/88534/10_nn_24.webp 576w,./static/a0c6008f4dc2e227487e0b392503e132/90be2/10_nn_24.webp 1152w,./static/a0c6008f4dc2e227487e0b392503e132/80ac5/10_nn_24.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/a0c6008f4dc2e227487e0b392503e132/c1250/10_nn_24.png" srcSet="./static/a0c6008f4dc2e227487e0b392503e132/159ad/10_nn_24.png 576w,./static/a0c6008f4dc2e227487e0b392503e132/21940/10_nn_24.png 1152w,./static/a0c6008f4dc2e227487e0b392503e132/c1250/10_nn_24.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
  <p>Чи зможете ви використати вихідні дані моделі <code>ml5.handPose()</code> як вхідні дані для <code>ml5.neuralNetwork()</code> і класифікувати різні жести долонь (наприклад, піднятий вгору великий палець або опущений вниз)? Для отримання підказок, ви можете переглянути <a href="https://thecodingtrain.com/pose-classifier" target="_blank" rel="noopener">мій відеоурок, який продемонструє цей процес на прикладі з позами тіла на вебсайті Coding Train</a>.</p>
</div>
<div data-type="project" class="callout">
  <h3 id="the-ecosystem-project-11"><a class="heading-link" href="#the-ecosystem-project-11">Проєкт “Екосистема”</a></h3>
  <p>Включіть у свою екосистему машинне навчання, щоб покращити поведінку істот. Як тут можна застосувати класифікацію або регресію?</p>
  <ul>
    <li>Чи зможете ви класифікувати істот вашої екосистеми на кілька категорій? Що, якщо ви використаєте початкову популяцію як навчальний набір даних, а при народженні нових істот, система класифікуватиме їх відповідно до їхніх особливостей? Які дані для вашої системи будуть вхідними й вихідними?</li>
    <li>Чи можете ви використати регресію, щоб передбачити тривалість життя істоти на основі її властивостей? Подумайте про те, як розмір і швидкість вплинули на тривалість життя блупів з <a href="/genetic-algorithms#section-genetic-algorithms">Розділу 9</a>. Чи можете ви проаналізувати, наскільки прогнози регресійної моделі узгоджуються з фактичними результатами?</li>
  </ul>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1420&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#d8d8d8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/8a648e3898317646d1bc8cbf4eecdff1/be6fc/10_nn_25.webp 576w,./static/8a648e3898317646d1bc8cbf4eecdff1/7c4ba/10_nn_25.webp 1152w,./static/8a648e3898317646d1bc8cbf4eecdff1/2e9c6/10_nn_25.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/8a648e3898317646d1bc8cbf4eecdff1/43bff/10_nn_25.png" data-srcset="./static/8a648e3898317646d1bc8cbf4eecdff1/09264/10_nn_25.png 576w,./static/8a648e3898317646d1bc8cbf4eecdff1/8a8ae/10_nn_25.png 1152w,./static/8a648e3898317646d1bc8cbf4eecdff1/43bff/10_nn_25.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/8a648e3898317646d1bc8cbf4eecdff1/be6fc/10_nn_25.webp 576w,./static/8a648e3898317646d1bc8cbf4eecdff1/7c4ba/10_nn_25.webp 1152w,./static/8a648e3898317646d1bc8cbf4eecdff1/2e9c6/10_nn_25.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/8a648e3898317646d1bc8cbf4eecdff1/43bff/10_nn_25.png" srcSet="./static/8a648e3898317646d1bc8cbf4eecdff1/09264/10_nn_25.png 576w,./static/8a648e3898317646d1bc8cbf4eecdff1/8a8ae/10_nn_25.png 1152w,./static/8a648e3898317646d1bc8cbf4eecdff1/43bff/10_nn_25.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
</div>
<p></p>
</section>
<hr/><section class="not-prose flex w-full justify-between"><div><a class="group block" href="./genetic-algorithms.html"><p class="text-gray-500">Попередній розділ</p><span class="text-lg font-semibold group-hover:underline">← <!-- -->9. Еволюційне моделювання</span></a></div><div><a class="group block text-right" href="./neuroevolution.html"><p class="text-gray-500">Наступний розділм</p><span class="text-lg font-semibold group-hover:underline">11. Нейроеволюція<!-- --> →</span></a></div></section></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div>
<script src="./assets/js/main.js"></script>
</body></html>