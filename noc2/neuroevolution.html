<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.25.7"/><meta data-react-helmet="true" name="description" content="Щиро вітаю! Ви дійшли до фінального акту цієї книги. Знайдіть хвилинку, щоб відсвяткувати все, чого ви навчилися. У цій книзі ви досліджували фундамен"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" property="og:url" content="https://natureofcode.com"/><meta data-react-helmet="true" property="og:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/><meta data-react-helmet="true" property="og:title" content="11. Нейроеволюція"/><meta data-react-helmet="true" property="og:description" content="Щиро вітаю! Ви дійшли до фінального акту цієї книги. Знайдіть хвилинку, щоб відсвяткувати все, чого ви навчилися. У цій книзі ви досліджували фундамен"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="11. Нейроеволюція"/><meta data-react-helmet="true" name="twitter:description" content="Щиро вітаю! Ви дійшли до фінального акту цієї книги. Знайдіть хвилинку, щоб відсвяткувати все, чого ви навчилися. У цій книзі ви досліджували фундамен"/><meta data-react-helmet="true" name="twitter:image" content="https://natureofcode.com/static/7dd3422c43faa1513528cd25636d9e6b/b08a9/cover.png"/>

    <link rel="stylesheet" href="./assets/styles/global.css">

    <noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="./favicon-32x32.png" type="image/png"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png"/><title data-react-helmet="true">11. Нейроеволюція / Nature of Code</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="fixed left-0 right-0 top-0 z-40 bg-white px-6 lg:px-8"><div class="mx-auto flex h-[5em] max-w-6xl items-center justify-between"><div class="flex flex-col gap-x-6 lg:flex-row lg:items-center"><a href="./"><span class="text-lg font-black tracking-widest text-noc-400"><span class="font-black">ПРИРОДА</span> КОДУ</span></a><span class="hidden text-sm tracking-widest text-noc-400 xl:block">ДАНІЕЛЬ ШИФФМАН</span></div><button class="flex h-9 w-11 cursor-pointer flex-col items-center justify-between p-2 lg:hidden" aria-label="Toggle menu" title="Toggle menu"><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-opacity" style="opacity:1"></span><span class="block h-0.5 w-full rounded bg-noc-200 transition-transform"></span></button><div class="hidden items-center gap-6 lg:flex"><ul class="flex items-center gap-6"><li><a href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M458.4 64.3C400.6 15.7 311.3 23 256 79.3 200.7 23 111.4 15.6 53.6 64.3-21.6 127.6-10.6 230.8 43 285.5l175.4 178.7c10 10.2 23.4 15.9 37.6 15.9 14.3 0 27.6-5.6 37.6-15.8L469 285.6c53.5-54.7 64.7-157.9-10.6-221.3zm-23.6 187.5L259.4 430.5c-2.4 2.4-4.4 2.4-6.8 0L77.2 251.8c-36.5-37.2-43.9-107.6 7.3-150.7 38.9-32.7 98.9-27.8 136.5 10.5l35 35.7 35-35.7c37.8-38.5 97.8-43.2 136.5-10.6 51.1 43.1 43.5 113.9 7.3 150.8z"></path></svg>SUPPORT</a></li><li><a href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1.5 text-sm text-gray-500 hover:underline"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="text-noc-200" height="1.2em" width="1.2em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>GITHUB</a></li><li><a href="https://thecodingtrain.com/" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./static/codingtrain_logo-53b0a841be45c7eac7a12f88b7bea596.png" alt="Coding Train&#x27;s logo" class="-ml-2 w-8"/>CODING TRAIN</a></li></ul><div class="not-prose flex items-center gap-4 undefined"><div class="relative"><a href="https://natureofcode.com/" target="_blank" class="flex items-center text-sm text-gray-500 hover:underline"><img src="./favicon-32x32.png" alt="The Nature Of Code logo" class="noc2-logo"/>THE NATURE OF CODE</a></div></div></div></div></header>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YD31R75NSS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YD31R75NSS');
    </script>
    <nav class="fixed bottom-0 left-0 right-0 top-[5em] z-20 overflow-y-auto bg-white px-6 lg:hidden mb-menu hidden">
        <ul class="my-7 space-y-2">
            <li><a class="text-lg text-gray-800" href="./dedication.html">Присвята</a></li>
            <li><a class="text-lg text-gray-800" href="./acknowledgements.html">Подяки</a></li>
            <li><a class="text-lg text-gray-800" href="./introduction.html">Вступ</a></li>
            <li>
                <button class="sub-menu-btn flex items-center gap-2 text-lg text-gray-800">
                    <span>Розділи</span>
                    <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 transition-transform" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="transform: scaleY(1);"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <ul class="space-y-2 py-2 pl-4 sub-menu hidden">
                    <li><a class="flex items-center text-gray-600" href="./random.html"><span class="w-8">0</span><span>Випадковість</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./vectors.html"><span class="w-8">1</span><span>Вектори</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./forces.html"><span class="w-8">2</span><span>Сили</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./oscillation.html"><span class="w-8">3</span><span>Коливання</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./particles.html"><span class="w-8">4</span><span>Система частинок</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./autonomous-agents.html"><span class="w-8">5</span><span>Автономні агенти</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./physics-libraries.html"><span class="w-8">6</span><span>Фізичні бібліотеки</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./cellular-automata.html"><span class="w-8">7</span><span>Клітинні автомати</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./fractals.html"><span class="w-8">8</span><span>Фрактали</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./genetic-algorithms.html"><span class="w-8">9</span><span>Еволюційне моделювання</span></a></li>
                    <li><a class="flex items-center text-gray-600" href="./neural-networks.html"><span class="w-8">10</span><span>Нейронні мережі</span></a></li>
                    <li><a aria-current="page" class="flex items-center text-gray-600 font-bold" href="./neuroevolution.html"><span class="w-8">11</span><span>Нейроеволюція</span></a></li>
                </ul>
            </li>
            <li><a class="text-lg text-gray-800" href="./appendix-creature.html">Додаток: Дизайн створінь</a></li>
            <li><a class="text-lg text-gray-800" href="./resources.html">Додаткові ресурси</a></li>
            <li><a class="text-lg text-gray-800" href="./credits.html">Credits</a></li>
            <li><a class="text-lg text-gray-800" href="./translation.html">Про переклад</a></li>
            <li><a class="text-lg text-gray-800" href="./examples.html">Приклади</a></li>
        </ul>
        <ul class="my-7 space-y-2">
            <li><a target="_blank" href="https://github.com/sponsors/CodingTrain" class="flex items-center gap-1 text-lg text-gray-800">Support<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
            <li><a target="_blank" href="https://github.com/nature-of-code/noc-book-2" class="flex items-center gap-1 text-lg text-gray-800">GitHub<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
            <li><a target="_blank" href="https://thecodingtrain.com/" class="flex items-center gap-1 text-lg text-gray-800">Coding Train<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>

            <li><a target="_blank" href="https://natureofcode.com/" class="flex items-center gap-1 text-lg text-gray-800">The Nature Of Code<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-3.5 text-gray-400" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></li>
        </ul>
    </nav>
    <div class="mt-[6em] px-6 lg:px-8"><div class="mx-auto max-w-6xl lg:flex lg:justify-between lg:gap-10 xl:gap-14"><aside class="sticky top-[6em] z-10 hidden max-h-[calc(100vh-6em)] min-w-[14em] overflow-y-auto pb-8 lg:block lg:flex-grow"><nav class="border-noc-200 rounded-3xl border"><ul class="divide-noc-200 divide-y"><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./dedication.html">Присвята</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./acknowledgements.html">Подяки</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./introduction.html">Вступ</a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./random.html"><span class="w-8">0</span><span class="group-hover:underline">Випадковість</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./vectors.html"><span class="w-8">1</span><span class="group-hover:underline">Вектори</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./forces.html"><span class="w-8">2</span><span class="group-hover:underline">Сили</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./oscillation.html"><span class="w-8">3</span><span class="group-hover:underline">Коливання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./particles.html"><span class="w-8">4</span><span class="group-hover:underline">Системи частинок</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./autonomous-agents.html"><span class="w-8">5</span><span class="group-hover:underline">Автономні агенти</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./physics-libraries.html"><span class="w-8">6</span><span class="group-hover:underline">Фізичні бібліотеки</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./cellular-automata.html"><span class="w-8">7</span><span class="group-hover:underline">Клітинні автомати</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./fractals.html"><span class="w-8">8</span><span class="group-hover:underline">Фрактали</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./genetic-algorithms.html"><span class="w-8">9</span><span class="group-hover:underline">Еволюційне моделювання</span></a></li><li><a class="group relative flex items-center px-3 py-2 text-sm" href="./neural-networks.html"><span class="w-8">10</span><span class="group-hover:underline">Нейронні мережі</span></a></li><li><a aria-current="page" class="group relative flex items-center px-3 py-2 text-sm font-bold" href="./neuroevolution.html"><span class="w-8">11</span><span class="group-hover:underline">Нейроеволюція</span></a><ul class="space-y-1 pb-2"><li><a href="#reinforcement-learning" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Навчання з підкріпленням</a></li><li><a href="#evolving-neural-networks-is-neat" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Еволюція нейронних мереж</a></li><li><a href="#coding-flappy-bird" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Програмування Flappy Bird</a></li><li><a href="#neuroevolutionary-flappy-bird" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Нейроеволюційний Flappy Bird</a></li><li><a href="#steering-the-neuroevolutionary-way" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Керування нейроеволюцією</a></li><li><a href="#a-neuroevolutionary-ecosystem" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Нейроеволюційна екосистема</a></li><li><a href="#the-end" class="ml-11 block py-0.5 pr-2 text-sm text-gray-500 hover:underline false">Кінець</a></li></ul></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./appendix-creature.html">Додаток: Дизайн створінь </a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./resources.html">Додаткові ресурси</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./credits.html">Credits</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./translation.html">Про переклад</a></li><li><a class="relative block px-3 py-2 text-sm hover:underline" href="./examples.html">Приклади</a></li></ul></nav></aside><main class="prose mx-auto max-w-[50em] pb-8"><section data-type="chapter" id="section-neuroevolution">
<h1 id="chapter-11-neuroevolution">Розділ 11. Нейроеволюція</h1>
<div class="chapter-opening-quote">
  <blockquote data-type="epigraph">
    <p>Читати про природу – це добре,</p>
    <p>але якщо людина ходить лісом і уважно слухає,</p>
    <p>вона може дізнатися набагато більше,</p>
    <p>ніж те, що написано у книгах.</p>
    <div class="chapter-opening-quote-source">
      <p>— Джордж Вашингтон Карвер</p>
    </div>
  </blockquote>
</div>
<div class="chapter-opening-figure">
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:1800px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1013&#x27; width=&#x27;1800&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#e8e8d8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/55a495d6d6634c6eda35df35fc4d89ff/f657c/11_nn_ga_1.webp 450w,./static/55a495d6d6634c6eda35df35fc4d89ff/67124/11_nn_ga_1.webp 900w,./static/55a495d6d6634c6eda35df35fc4d89ff/d274c/11_nn_ga_1.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" data-src="./static/55a495d6d6634c6eda35df35fc4d89ff/6d4eb/11_nn_ga_1.png" data-srcset="./static/55a495d6d6634c6eda35df35fc4d89ff/a5858/11_nn_ga_1.png 450w,./static/55a495d6d6634c6eda35df35fc4d89ff/bec9b/11_nn_ga_1.png 900w,./static/55a495d6d6634c6eda35df35fc4d89ff/6d4eb/11_nn_ga_1.png 1800w" alt="Зірконосий кріт (зображення надано Нью-Йоркською публічною бібліотекою, 1826–1828 рр.)"/></picture><noscript><picture><source type="image/webp" srcSet="./static/55a495d6d6634c6eda35df35fc4d89ff/f657c/11_nn_ga_1.webp 450w,./static/55a495d6d6634c6eda35df35fc4d89ff/67124/11_nn_ga_1.webp 900w,./static/55a495d6d6634c6eda35df35fc4d89ff/d274c/11_nn_ga_1.webp 1800w" sizes="(min-width: 1800px) 1800px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 1800px) 1800px, 100vw" decoding="async" loading="lazy" src="./static/55a495d6d6634c6eda35df35fc4d89ff/6d4eb/11_nn_ga_1.png" srcSet="./static/55a495d6d6634c6eda35df35fc4d89ff/a5858/11_nn_ga_1.png 450w,./static/55a495d6d6634c6eda35df35fc4d89ff/bec9b/11_nn_ga_1.png 900w,./static/55a495d6d6634c6eda35df35fc4d89ff/6d4eb/11_nn_ga_1.png 1800w" alt="Зірконосий кріт (зображення надано Нью-Йоркською публічною бібліотекою, 1826–1828 рр.)"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
  <span id="star-nosed-moles-courtesy-of-new-york-public-library-c-18261828"><a class="heading-link" href="#star-nosed-moles-courtesy-of-new-york-public-library-c-18261828">Зірконосий кріт (зображення надано Нью-Йоркською публічною бібліотекою, 1826–1828 рр.)</a></span>
  <p>Зірконосий кріт (<em>Condylura cristata</em>), поширений переважно на північному сході Сполучених Штатів і східній Канаді, має унікальний і вузькоспеціалізований носовий орган. Його ніс, який розвивався протягом багатьох поколінь, складається з 22 мацаків, що мають понад 25 000 дрібних сенсорних рецепторів. Попри те, що кроти незрячі, ці мацаки дозволяють їм створюват и детальну просторову карту свого оточення. Вони можуть орієнтуватися у своєму темному підземному середовищі з точністю і прудкістю, що вражають, швидко розпізнаючи та споживаючи їстівні об’єкти за лічені мілісекунди.</p>
<hr/></div>
<p>Щиро вітаю! Ви дійшли до фінального акту цієї книги. Знайдіть хвилинку, щоб відсвяткувати все, чого ви навчилися.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1246&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/6f75146ba2d1313d04125c9b3532c372/af721/11_nn_ga_2.webp 576w,./static/6f75146ba2d1313d04125c9b3532c372/0a8bf/11_nn_ga_2.webp 1152w,./static/6f75146ba2d1313d04125c9b3532c372/8950e/11_nn_ga_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/6f75146ba2d1313d04125c9b3532c372/9ea8b/11_nn_ga_2.png" data-srcset="./static/6f75146ba2d1313d04125c9b3532c372/993e5/11_nn_ga_2.png 576w,./static/6f75146ba2d1313d04125c9b3532c372/62dd3/11_nn_ga_2.png 1152w,./static/6f75146ba2d1313d04125c9b3532c372/9ea8b/11_nn_ga_2.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/6f75146ba2d1313d04125c9b3532c372/af721/11_nn_ga_2.webp 576w,./static/6f75146ba2d1313d04125c9b3532c372/0a8bf/11_nn_ga_2.webp 1152w,./static/6f75146ba2d1313d04125c9b3532c372/8950e/11_nn_ga_2.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/6f75146ba2d1313d04125c9b3532c372/9ea8b/11_nn_ga_2.png" srcSet="./static/6f75146ba2d1313d04125c9b3532c372/993e5/11_nn_ga_2.png 576w,./static/6f75146ba2d1313d04125c9b3532c372/62dd3/11_nn_ga_2.png 1152w,./static/6f75146ba2d1313d04125c9b3532c372/9ea8b/11_nn_ga_2.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption></figcaption>
</figure>
<p>У цій книзі ви досліджували фундаментальні принципи інтерактивного моделювання фізики за допомогою p5.js, занурювалися у складні поведінки агентів та інших поведінок заснованих на правилах, а також заглиблювалися у захопливу галузь машинного навчання. Ви стали природним!</p>
<p>Однак <a href="/neural-networks#section-neural-networks">Розділ 10</a> лише трохи торкнувся поверхні роботи  з даними й машинним навчанням на основі нейронних мереж — величезного краєвиду, для повного охоплення якого знадобилися б незліченні продовження цієї книги. Моя мета полягала не у заглибленні у нейронні мережі, а була простим ознайомленням з основними концепціями під час підготовки до великого фіналу. Фіналу, де я покажу спосіб інтегрування машинного навчання у світ анімованих інтерактивних програм p5.js і об’єднаю для останнього успіху якомога більше наших нових концепцій з <em>природи коду</em>, наскільки це можливо.</p>
<p>Шлях вперед пролягає через <strong>нейроеволюцію</strong> — стиль машинного навчання, який поєднує ГА-ми із <a href="/genetic-algorithms#section-genetic-algorithms">Розділу 9</a> з нейронними мережами з <a href="/neural-networks#section-neural-networks">Розділу 10</a>. Нейроеволюційна система використовує дарвінівські принципи, щоб розвивати ваги (а в деяких випадках і саму структуру) нейронної мережі протягом поколінь навчання методом проб і помилок. У цьому розділі я покажу, як використовувати нейроеволюцію на знайомому прикладі зі світу ігор. На завершення я зміню керувальні поведінки Крейга Рейнольдса з <a href="/autonomous-agents#section-autonomous-agents">Розді лу 5</a>, щоб вони навчались шляхом нейроеволюції.</p>
<h2 id="reinforcement-learning"><a class="heading-link" href="#reinforcement-learning">Навчання з підкріпленням</a></h2>
<p>Нейроеволюція має багато спільного з іншою методологією машинного навчання, про яку я коротко згадував у <a href="/neural-networks#section-neural-networks">Розділі 10</a> — <strong>навчання з підкріпленням</strong>, яке включає машинне навчання у симуляції. Агент із підтримкою нейронної мережі навчається, взаємодіючи з навколишнім середовищем і отримуючи зворотний зв’язок про свої рішення у формі винагород або штрафів. Це стратегія, побудована навколо спостереження.</p>
<p>Уявіть маленьку мишку, що біжить лабіринтом. Якщо вона повертає ліворуч, то отримує шматочок сиру, а якщо повертає праворуч — отримує невеликий електричний удар. (Не хвилюйтеся, це лише вигадана миша.) Імовірно, з часом миша навчиться повертати ліворуч. Її біологічна нейронна мережа приймає рішення з результатом (поворот ліворуч або праворуч) і спостерігає за своїм оточенням (ням-ням або ой-ой). Якщо спостереження вбачає негативні результати, мережа може скорегувати свої ваги, щоб наступного разу прийняти інше рішення.</p>
<p>У реальному сві ті навчання з підкріпленням зазвичай використовується не для мучення гризунів, а для розробки роботів. У момент часу <em>t</em> робот виконує завдання і спостерігає за результатами. Чи він врізався у стіну, чи впав зі столу, чи він неушкоджений? З часом робот навчається інтерпретувати сигнали з навколишнього середовища оптимальним чином, щоб виконувати свої завдання й уникати шкоди.</p>
<p>Замість мишки чи робота, подумайте тепер про будь-які об’єкти із прикладів цієї книги (блукачі, агенти, частинки, рухомі створіння). Уявіть, що вбудовуєте нейронну мережу в один із цих об’єктів і використовуєте її для обчислення сили чи іншої дії. Нейронна мережа може отримувати вхідні дані з навколишнього середовища (наприклад, відстань до перешкоди) і виводити певне рішення. Можливо, мережа вибиратиме з набору дискретних параметрів (переміщення вліво або вправо) або набору безперервних значень (величина і напрямок керувальної сили).</p>
<p>Чи це звучить знайомо? Це нічим не відрізняється від того, як нейронна мережа працювала після навчання у прикладах із <a href="/neural-networks#section-neural-networks">Розділу 10</a>, отримуючи вхідні дані та прогнозуючи класифікацію чи регресію! Власне навчання одного з цих об’єктів для прийняття правильного рішення є тим місцем, що відрізняє процес навчання з підкріпленням від підходу навчання під наглядом. Щоб краще продемонструвати це, розпочнімо зі, сподіваюся, легкого для розуміння і можливо знайомого сценарію — гри <em>Flappy Bird</em> (див. малюнок 11.1).</p>
<p>Гра оманливо проста. Ви керуєте маленькою пташкою, яка постійно рухається по екрану горизонтально. З кожною дією гравця птах змахує крилами й трохи підіймається вгору. Виклик полягає в тому, щоб пташка здолала на своєму шляху серію вертикальних труб, розташованих одна за одною через нерівні проміжки, які виходять з правої сторони екрана. У трубах на різних рівнях є прогалини й вашою основною метою є безпечне проведення пташки через ці прогалини. Якщо ви зіштовхуєтеся із трубою, гра завершується. У міру просування швидкість гри зростає і чим більше труб ви проходите, тим вищий ваш рахунок.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1246&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/a703fe8d9796362703d7c168d17aa844/af721/11_nn_ga_3.webp 576w,./static/a703fe8d9796362703d7c168d17aa844/0a8bf/11_nn_ga_3.webp 1152w,./static/a703fe8d9796362703d7c168d17aa844/8950e/11_nn_ga_3.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/a703fe8d9796362703d7c168d17aa844/9ea8b/11_nn_ga_3.png" data-srcset="./static/a703fe8d9796362703d7c168d17aa844/993e5/11_nn_ga_3.png 576w,./static/a703fe8d9796362703d7c168d17aa844/62dd3/11_nn_ga_3.png 1152w,./static/a703fe8d9796362703d7c168d17aa844/9ea8b/11_nn_ga_3.png 2304w" alt="Малюнок 11.1: Гра Flappy Bird"/></picture><noscript><picture><source type="image/webp" srcSet="./static/a703fe8d9796362703d7c168d17aa844/af721/11_nn_ga_3.webp 576w,./static/a703fe8d9796362703d7c168d17aa844/0a8bf/11_nn_ga_3.webp 1152w,./static/a703fe8d9796362703d7c168d17aa844/8950e/11_nn_ga_3.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/a703fe8d9796362703d7c168d17aa844/9ea8b/11_nn_ga_3.png" srcSet="./static/a703fe8d9796362703d7c168d17aa844/993e5/11_nn_ga_3.png 576w,./static/a703fe8d9796362703d7c168d17aa844/62dd3/11_nn_ga_3.png 1152w,./static/a703fe8d9796362703d7c168d17aa844/9ea8b/11_nn_ga_3.png 2304w" alt="Малюнок 11.1: Гра Flappy Bird"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 11.1: Гра <em>Flappy Bird</em></figcaption>
</figure>
<p>Припустімо, що ви хочете автоматизувати ігровий процес, і замість людських дій для створення пташиного руху цим буде займатися нейронна мережа, яка сама вирішуватиме, чи потрібно пташці змахувати крильцями. Чи може тут спрацювати машинне навчання? Пропустимо на мить початкові етапи життєвого циклу машинного навчання і подумаємо про те, як вибрати модель. Які у нейронної мережі мають бути входи й виходи?</p>
<p>Це досить цікаве запитання, оскільки тут, принаймні для вхідних даних, немає однозначної відповіді. Якщо ви не дуже знайомі з грою або не бажаєте визначати, які аспекти гри є важливими, доцільніше, щоб вхідними даними були усі пікселі ігрового екрана. Цей підхід намагається передати моделі <em>усе</em> про гру і дозволити її самій визначити, що є важливим.</p>
<p>Однак я маю достатній досвід гри у <em>Flappy Bird</em> і вважаю, що досить добре її розумію. Тому я можу обійтися без передачі всіх пікселів до моделі й звести суть гри лише до кількох частин вхідних даних, необхідних для формування прогнозів. Ці частини даних, які часто називають <strong>ознаками (особливостями, характеристиками)</strong> машинного навчання, представляють відмінні характеристики даних, які є найбільш важливими для прогнозування. Уявіть, що ви кусаєте загадково соковитий фрукт — його смак (солодкий!), консистенція (хрустка!) і колір (яскраво-червоний!) допомагають ідентифікувати цей фрукт як яблуко. У випадку з <em>Flappy Bird</em> найважливіші особливості перераховані нижче:</p>
<ol>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення птаха</li>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-швидкість птаха</li>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення отвору наступної верхньої труби</li>
  <li value="4"><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення отвору наступної нижньої труби</li>
  <li value="5"><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-відстань до наступної труби</li>
</ol>
<p>Ці ознаки показано на малюнку 11.2.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1246&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/cd5f383c6f5b90d77c33e9b0c05e069e/af721/11_nn_ga_4.webp 576w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/0a8bf/11_nn_ga_4.webp 1152w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/8950e/11_nn_ga_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/cd5f383c6f5b90d77c33e9b0c05e069e/9ea8b/11_nn_ga_4.png" data-srcset="./static/cd5f383c6f5b90d77c33e9b0c05e069e/993e5/11_nn_ga_4.png 576w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/62dd3/11_nn_ga_4.png 1152w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/9ea8b/11_nn_ga_4.png 2304w" alt="Малюнок 11.2: Вхідні ознаки Flappy Bird для нейронної мережі"/></picture><noscript><picture><source type="image/webp" srcSet="./static/cd5f383c6f5b90d77c33e9b0c05e069e/af721/11_nn_ga_4.webp 576w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/0a8bf/11_nn_ga_4.webp 1152w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/8950e/11_nn_ga_4.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/cd5f383c6f5b90d77c33e9b0c05e069e/9ea8b/11_nn_ga_4.png" srcSet="./static/cd5f383c6f5b90d77c33e9b0c05e069e/993e5/11_nn_ga_4.png 576w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/62dd3/11_nn_ga_4.png 1152w,./static/cd5f383c6f5b90d77c33e9b0c05e069e/9ea8b/11_nn_ga_4.png 2304w" alt="Малюнок 11.2: Вхідні ознаки Flappy Bird для нейронної мережі"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 11.2: Вхідні ознаки <em>Flappy Bird</em> для нейронної мережі</figcaption>
</figure>
<p>Нейронна мережа матиме п’ять входів, по одному для кожної ознаки, а як щодо виходів? Це задача класифікації чи регресії? Це може здатися дивним запитанням у контексті такої гри, як <em>Flappy Bird</em>, але насправді воно дуже важливе і пов’язане зі способом керування грою. Дотики до екрана, натискання кнопок чи використання клавіатури — усе це приклади класифікації. Зрештою, у гравця є лише обмежений набір вибору: доторкатися до екрана чи ні або яку саме з клавіш натиснути W, A, S або D. З іншого боку, використання аналогового контролера такого як джойстик схиляє до регресії. Джойстик можна нахилити на різні кути у будь-якому напрямку, перетворюючи на вихідні значення безперервного діапазону як для горизонтальної, так і для вертикальної осей.</p>
<p>Для <em>Flappy Bird</em> виходи являють собою вибір класифікації лише з двома варіантами:</p>
<ul>
  <li>Махнути крильми.</li>
  <li>Не махати крильми.</li>
</ul>
<p>Це означає, що мережа повинна мати два виходи, що вказує на загальну архітектуру мережі, як зображено на малюнку 11.3.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;2011&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/576ce33ed18da59b66f8bc314ce045ec/0c839/11_nn_ga_5.webp 576w,./static/576ce33ed18da59b66f8bc314ce045ec/5281a/11_nn_ga_5.webp 1152w,./static/576ce33ed18da59b66f8bc314ce045ec/c1f3b/11_nn_ga_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/576ce33ed18da59b66f8bc314ce045ec/884c3/11_nn_ga_5.png" data-srcset="./static/576ce33ed18da59b66f8bc314ce045ec/202e0/11_nn_ga_5.png 576w,./static/576ce33ed18da59b66f8bc314ce045ec/4407e/11_nn_ga_5.png 1152w,./static/576ce33ed18da59b66f8bc314ce045ec/884c3/11_nn_ga_5.png 2304w" alt="Малюнок 11.3: Можливий дизайн нейронної мережі для Flappy Bird"/></picture><noscript><picture><source type="image/webp" srcSet="./static/576ce33ed18da59b66f8bc314ce045ec/0c839/11_nn_ga_5.webp 576w,./static/576ce33ed18da59b66f8bc314ce045ec/5281a/11_nn_ga_5.webp 1152w,./static/576ce33ed18da59b66f8bc314ce045ec/c1f3b/11_nn_ga_5.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/576ce33ed18da59b66f8bc314ce045ec/884c3/11_nn_ga_5.png" srcSet="./static/576ce33ed18da59b66f8bc314ce045ec/202e0/11_nn_ga_5.png 576w,./static/576ce33ed18da59b66f8bc314ce045ec/4407e/11_nn_ga_5.png 1152w,./static/576ce33ed18da59b66f8bc314ce045ec/884c3/11_nn_ga_5.png 2304w" alt="Малюнок 11.3: Можливий дизайн нейронної мережі для Flappy Bird"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 11.3: Можливий дизайн нейронної мережі для <em>Flappy Bird</em></figcaption>
</figure>
<p>Тепер у мене є вся інформація, необхідна для налаштування моделі, щоб створити її за допомогою ml5.js:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> options = {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">inputs</span>: <span class="hljs-number">5</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">outputs</span>: [<span class="hljs-string">&quot;flap&quot;</span>, <span class="hljs-string">&quot;no flap&quot;</span>],
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;classification&quot;</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">};
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> birdBrain = ml5.<span class="hljs-title function_">neuralNetwork</span>(options);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Що далі? Якщо виконувати кроки, описані в <a href="/neural-networks#section-neural-networks">Розділі 10</a>, мені довелося б повернутися до кроків 1 і 2 процесу машинного навчання: збору і підготовки даних. Як саме це буде працювати тут? Одна з ідей може полягати у пошуку найкращого гравця у <em>Flappy Bird</em> усіх часів і записати його гру впродовж багатьох годин. Я міг би зареєструвати особливості вхідних даних для кожного моменту ігрового процесу разом з тим коли гравець робив змахи для пташки, а коли ні. Введіть усі ці дані у модель, натренуйте її, і я вже бачу заголовки: “Бот зі штучним інтелектом перемагає у Flappy Bird”.</p>
<p>Але зачекайте, чи справді комп’ютеризований агент навчився грати у <em>Flappy Bird</em> самостійно, чи він просто навчився віддзеркалювати ігровий процес людини? Що, якщо людина під час гри пропустила ключовий аспект стратегії <em>Flappy Bird</em>? Автоматизований гравець цього ніколи не виявить. Не кажучи вже про те, що збирати всі ці дані було б неймовірно виснажливо.</p>
<p>Проблема полягає в тому, що я повернувся до сценарію навчання під наглядом, подібного до тих, що були у <a href="/neural-networks#section-neural-networks">Розділі 10</a>, але це має бути розділ про навчання з підкріпленням. На відміну від навчання під наглядом, у якому правильні відповіді надходять з навчальним набором даних, агент у навчанні з підкріпленням навчається на відповідях — оптимальних рішеннях — методом проб і помилок, взаємодіючи з середовищем і отримуючи зворотний зв’язок. У випадку з <em>Flappy Bird</em>, агент може отримувати позитивну відзнаку (своєрідна винагорода) кожного разу, коли він успішно проходить трубу й н егативну відзнаку (своєрідне покарання), якщо він влучає у трубу або землю. Мета агента — визначити, які дії з часом призводять до найбільшої сукупної винагороди.</p>
<p>На початку агент <em>Flappy Bird</em> не знає, коли найкраще махати крилами, що призведе до багатьох зіткнень. У міру того, як він отримує все більше і більше відгуків від незліченних спроб проходження тунелю, він починає вдосконалювати свої дії та розробляти оптимальну стратегію для проходження труб без збоїв, максимізуючи свою загальну винагороду. Цей процес <em>навчання через практику</em> й оптимізації на основі зворотного зв’язку є суттю навчання з підкріпленням.</p>
<p>У цьому розділі я розгляну принципи, які тут викладаю, але з нововведенням. Традиційні методи навчання з підкріпленням включають визначення стратегії (званої <strong>політикою</strong>) і відповідної <strong>функції винагороди</strong>, щоб забезпечити зворотний зв’язок для коригування політики. Однак замість того, щоб піти цим шляхом, я звернуся до зірки цього розділу — нейроеволюції.</p>
<h2 id="evolving-neural-networks-is-neat"><a class="heading-link" href="#evolving-neural-networks-is-neat">Еволюція нейронних мереж</a></h2>
<p>Замість традиційн ого зворотного поширення помилки, політики й функції винагороди, нейроеволюція застосовує принципи ГА та природного відбору для тренування ваг у нейронній мережі. Ця техніка запускає відразу багато нейронних мереж для розв&#x27;язання проблеми. Періодично “відбираються” найкращі нейронні мережі і їхні “гени” (ваги мережевих з’єднань) комбінуються та змінюються для створення наступного покоління мереж. Нейроеволюція особливо ефективна в середовищах, де правила навчання не визначені точно або задачі є складними й мають численні потенційні рішення.</p>
<p>Один із перших прикладів нейроеволюції можна знайти у статті Едмунда Рональда і Марка Шенауера 1994 року <a href="https://doi.org/10.1007/3-540-58484-6_288" target="_blank" rel="noopener">“Genetic Lander: An Experiment in Accurate Neuro-genetic Control”</a>. У 1990-х роках традиційні методи навчання нейронних мереж ще тільки зароджувалися і ця робота досліджувала альтернативний підхід. У документі описано, як імітований космічний корабель — у грі з влучною назвою <em>Lunar Lander</em> — може навчитися безпечно спускатися і приземлятися на поверхню. Замість того, щоб використовувати створені вручну правила чи промарковані набори даних, дослідники вирішили використовувати ГА для розвитку і навчання нейронних мереж протягом кількох поколінь. І це спрацювало!</p>
<p>У 2002 році Кеннет О. Стенлі та Рісто Мійккулайнен розширили попередні нейроеволюційні підходи у своїй статті <a href="https://doi.org/10.1162/106365602320169811" target="_blank" rel="noopener">“Evolving Neural Networks Through Augmenting Topologies”</a>. На відміну від методу посадки на Місяць, який зосереджувався на еволюції ваг нейронної мережі, Стенлі та Мійккулайнен представили метод, який також розвивав структуру самої мережі! Їхній алгоритм NEAT — NeuroEvolution of Augmenting Topologies — починається з простих мереж і поступово вдосконалює їхню топологію шляхом еволюції. У результаті NEAT може відкрити мережеву архітектуру, адаптовану до конкретних завдань, часто даючи більш оптимізовані й ефективні рішення.</p>
<p>Комплексна реалізація NEAT потребує глибшого вивчення архітектури нейронних мереж і безпосередньої роботи з TensorFlow.js. Натомість моя мета — імітувати оригінальні дослідження Рональда та Шенауера в сучасному контексті веббраузера за допомогою ml5.js. Замість того, щоб використовувати гру <em>Lunar Lander</em>, я спробую зробити це з <em>Flappy Bird</em>. І  для цього мені спочатку потрібно запрограмувати версію <em>Flappy Bird</em> у якій зможе працювати моя нейроеволюційна мережа.</p>
<h2 id="coding-flappy-bird"><a class="heading-link" href="#coding-flappy-bird">Програмування Flappy Bird</a></h2>
<p><em>Flappy Bird</em> створив в’єтнамський розробник ігор Донг Нгуєн у 2013 році. У січні 2014 року він став додатком з найбільшою кількістю завантажень в Apple App Store. Однак 8 лютого того ж року Нгуєн оголосив, що видаляє гру у зв’язку зі звиканням до неї. З того часу вона стала однією з найбільш клонованих ігор в історії.</p>
<p><em>Flappy Bird</em> є чудовим прикладом закону Бушнелла, афоризму, який приписують засновнику Atari й творцю гри <em>Pong</em> Нолану Бушнеллу: “В усі найкращі ігри легко навчитися грати, але важко опанувати досконало”. Це також чудова гра для програмістів-початківців, яку можна відтворити у навчальних цілях і вона ідеально відповідає концепціям цієї книги.</p>
<p>Щоб запрограмувати гру за допомогою p5.js, я почну з визначення класу <code>Bird</code>. Це може вас шокувати, але у цій демонстрації я збираюся пропустити використання класу <code>p5.Vector</code>, а натомість для положення птаха буду використовувати роздільні <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-змінні. Оскільки птах у грі рухається тільки по вертикальній осі, значення властивості <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span> залишається постійною! Таким чином <code>velocity</code> (і всі відповідні сили) можуть бути єдиним скалярним значенням лише для осі <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>.</p>
<p>Для ще більшого спрощення коду, я додам сили безпосередньо до швидкості птаха замість накопичення їх у змінній <code>acceleration</code>. На додаток до звичайного методу <code>update()</code>, я включу метод <code>flap()</code> для того, щоб птах робив змах вгору. Метод <code>show()</code> тут не описано, оскільки він лише малює круг. Ось код:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">50</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = <span class="hljs-number">120</span>;
</code></pre><div class="comment"><p>Положення птаха (значення x буде константним).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gravity</span> = <span class="hljs-number">0.5</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flapForce</span> = -<span class="hljs-number">10</span>;
</code></pre><div class="comment"><p>Швидкість і сили є скалярними, оскільки птах рухається лише вздовж осі y.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">flap</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">flapForce</span>;
  }
</code></pre><div class="comment"><p>Метод для змаху крилами.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">gravity</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>;
</code></pre><div class="comment"><p>Додавання сили тяжіння.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> *= <span class="hljs-number">0.95</span>;
</code></pre><div class="comment"><p>Послаблення швидкості.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> &gt; height) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = height;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-number">0</span>;
    }
</code></pre><div class="comment"><p>Обробка зіткнення з підлогою.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Іншими основними елементами гри є труби через які птах має пролітати. Я створю клас <code>Pipe</code> де опишу пару прямокутників: один виходитиме із верхньої частини полотна, а інший — з нижньої. Подібно до того, як птах рухається лише у вертикальному напрямку, труби ковзають лише вздовж горизонтальної осі, тому їх властивості також можуть бути скалярними значеннями, а не векторами. Труби рухаються з постійною швидкістю і не зазнають ніяких інших сил.</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pipe</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">spacing</span> = <span class="hljs-number">100</span>;
</code></pre><div class="comment"><p>Розмір отвору між двома частинами труби.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span> = <span class="hljs-title function_">random</span>(height - <span class="hljs-variable language_">this</span>.<span class="hljs-property">spacing</span>);
</code></pre><div class="comment"><p>Довільна висота верхньої частини труби.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bottom</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">spacing</span>;
</code></pre><div class="comment"><p>Початкове положення нижньої труби (на основі верхньої)</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = width;
</code></pre><div class="comment"><p>Розташування труби починається з правого краю полотна.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span> = <span class="hljs-number">20</span>;
</code></pre><div class="comment"><p>Ширина труби.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-number">2</span>;
</code></pre><div class="comment"><p>Горизонтальна швидкість труби.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">noStroke</span>();
    <span class="hljs-title function_">rect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span>);
    <span class="hljs-title function_">rect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">bottom</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>, height - <span class="hljs-variable language_">this</span>.<span class="hljs-property">bottom</span>);
  }
</code></pre><div class="comment"><p>Малювання верхньої і нижньої труб.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> -= <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>;
  }
</code></pre><div class="comment"><p>Оновлення горизонтального положення.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Для ясності, гра зображує птаха, який летить через труби — птах рухається вздовж двомірного простору, а труби залишаються нерухомими. Однак простіше запрограмувати гру таким чином, ніби птах нерухомий у своєму горизонтальному положенні, а труби рухаються.</p>
<p>З написаними класами <code>Bird</code> і <code>Pipe</code>, я практично готовий до запуску гри. Однак не вистачає ключової деталі — зіткнень. Вся гра полягає в тому, що птах намагається уникнути зіткнення з трубами! На щастя, в цьому немає нічого нового. У цій книзі ви вже бачили кілька прикладів з об’єктами, які звіряли своє положення з іншими елементами оточення. Метод для перевірки зіткнень можна розмістити або в класі <code>Bird</code> (щоб перевірити, чи птах вдаряється об трубу), або у класі <code>Pipe</code> (щоб перевірити, чи труба вдаряє птаха). Будь-який варіант може бути логічно виправданим, залежно від вашої точки зору.</p>
<p>Я розміщу метод у класі <code>Pipe</code> і назву його <code>collides()</code>. Сам код дещо складніший, ніж можна подумати, на перший погляд, оскільки метод потребує перевірки як верхнього, т ак і нижнього прямокутників труби із положенням птаха. Я міг би підійти до цього різними шляхами. Один зі способів — спочатку перевірити, чи знаходиться птах вертикально в межах будь-якого прямокутника (над нижньою частиною верхньої труби чи під верхньою частиною нижньої). Але птах стикається з трубою тільки в тому випадку, якщо він також знаходиться горизонтально в межах ширини труби. Елегантний спосіб написати це — поєднати кожну з цих перевірок з логічним <em>і</em>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">collides</span>(<span class="hljs-params">bird</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> verticalCollision = bird.<span class="hljs-property">y</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span> || bird.<span class="hljs-property">y</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">bottom</span>;
</code></pre><div class="comment"><p>Чи знаходиться птах у вертикальному діапазоні верхньої чи нижньої труби?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> horizontalCollision = bird.<span class="hljs-property">x</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> &amp;&amp; bird.<span class="hljs-property">x</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">w</span>;
</code></pre><div class="comment"><p>Чи знаходиться птах у горизонтальному діапазоні якоїсь із труб?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> verticalCollision &amp;&amp; horizontalCollision;
</code></pre><div class="comment"><p>Якщо є і вертикальний і горизонтальний перетин — це зіткнення!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Наразі алгоритм розглядає птаха як одну точку і не враховує його розміри. Для більш реалістичної гри цей момент варто вдосконалити.</p>
<p>Залишилося лише написати функції <code>setup()</code> і <code>draw()</code>. Мені потрібна одна змінна для птаха і масив для списку набору труб. Взаємодія із користувачем полягає лише у клацанні комп’ютерної миші, що запускає метод птаха <code>flap()</code>. Замість того, щоб створювати повнофункціональну гру з рахунком, фінальними показниками та іншими звичними елементами, я просто переконаюся, що працює сама ігрова механіка, намалювавши текст “<em>OOPS!</em>” поблизу будь-якої труби, коли відбувається зіткнення. У повному коді клас <code>Pipe</code> має додатковий метод <code>offscreen()</code>, який перевіряє чи труба вже перемістилася за ліву межу полотна — це дозволяє видалити її з масиву, коли вона вже не потрібна.</p>
<div data-type="example">
  <h3 id="example-111-flappy-bird-clone"><a class="heading-link" href="#example-111-flappy-bird-clone">Приклад 11.1: Клон гри Flappy Bird</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/11_nn_ga/11_1_flappy_bird"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/Pv-JlO0cl" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> bird;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> pipes = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  bird = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();
  pipes.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pipe</span>());
</code></pre><div class="comment"><p>Створення пташки і першої труби.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mousePressed</span>(<span class="hljs-params"></span>) {
  bird.<span class="hljs-title function_">flap</span>();
}
</code></pre><div class="comment"><p>Птах махає крилами, коли відбувається клацання мишкою.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = pipes.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    pipes[i].<span class="hljs-title function_">show</span>();
    pipes[i].<span class="hljs-title function_">update</span>();
    <span class="hljs-keyword">if</span> (pipes[i].<span class="hljs-title function_">collides</span>(bird)) {
      <span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;OOPS!&quot;</span>, pipes[i].<span class="hljs-property">x</span>, pipes[i].<span class="hljs-property">top</span> + <span class="hljs-number">20</span>);
    }
    <span class="hljs-keyword">if</span> (pipes[i].<span class="hljs-title function_">offscreen</span>()) {
      pipes.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);
    }
  }
</code></pre><div class="comment"><p>Перевірка і обробка усіх труб.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  bird.<span class="hljs-title function_">update</span>();
  bird.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Оновлення і малювання птаха.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (frameCount % <span class="hljs-number">100</span> === <span class="hljs-number">0</span>) {
    pipes.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pipe</span>());
  }
</code></pre><div class="comment"><p>Додавання нової труби кожні 100 кадрів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Найскладніший аспект цього коду полягає у створенні труб через регулярні проміжки часу за допомогою змінної <code>frameCount</code> і операції ділення по модулю. У p5.js <code>frameCount</code> є системною змінною, що збільшується із кожним кадром і зберігає значення кількості кадрів пройдених від початку запуску програми. Оператор модуля, позначений як <code><strong>%</strong></code>, повертає залишок від операції ділення. Наприклад <code>7 % 3</code> повертає у результаті <code>1</code>, тому що при діленні 7 на 3 результат дорівнює 2 із залишком 1. Отже, логічний вираз <code>frameCount % 100 === 0</code> перевіряє чи поточне значення змінної <code>frameCount</code> націло ділиться на 100, що в результаті ділення по модулю має повертати нуль. Ця умова відповідає істині кожні 100 кадрів і тоді створюється нова парна труба та додається до масиву <code>pipes</code>.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-111"><a class="heading-link" href="#exercise-111">Вправа 11.1</a></h3>
  <p>Імплементуйте підрахунок очок, які нараховуються за успішне проходження кожної труби. Не соромтеся також додавати власні візуальні елементи оформлення для птаха, труб і середовища!</p>
</div>
<h2 id="neuroevolutionary-flappy-bird"><a class="heading-link" href="#neuroevolutionary-flappy-bird">Нейроеволюційний Flappy Bird</a></h2>
<p>Мій клон <em>Flappy Bird</em>, як він є наразі, керується за допомогою клацання миші. Тепер я хочу передати контроль над грою комп’ютеру і, використавши нейроеволюцію, навчити його грати. На щастя, процес нейроеволюції вже вбудований у ml5.js, тому зробити цей перехід буде порівняно просто. Перший крок — надати пташці мозок, щоб вона могла самостійно вирішувати, коли махати крилами.</p>
<h3 id="the-bird-brain"><a class="heading-link" href="#the-bird-brain">Пташиний мозок</a></h3>
<p>Коли я розповідав про навчання з підкріпленням, то склав спис ок вхідних характеристик, які повинні складати процес прийняття рішень птахом. Я збираюся використати той самий список, але з одним спрощенням. Оскільки розмір отвору між трубами постійний, немає потреби включати <span style="white-space:nowrap"><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення</span> верхньої й нижньої сторони — вистачить будь-якого з них. Отже, вхідні дані будуть наступними:</p>
<ol>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення птаха</li>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-швидкість птаха</li>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-положення отвору наступної верхньої (або нижньої!) труби</li>
  <li><span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-відстань до наступної труби</li>
</ol>
<p>Два виходи представляють два варіанти для птаха: махати крилами чи не махати. З налаштованими входами та виходами, для зберігання нейронної мережі ml5.js із відповідною конфігурацією, я можу додати до конструктора пташки властивість <code>brain</code>. Щоб продемонструвати тут інший стиль кодування, я пропущу створення окремої змінної <code>options</code> і передам потрібні опції у вигляді літерала об’єкта безпосередньо у функцію <code>ml5.neuralNetwork()</code>. Зверніть увагу на додану властивість <code>neuroEvolution</code> зі значенням <code>true</code>. Це необхідно, щоб увімкнути деяку функціональність, яку я буду використовувати у коді пізніше:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span> = ml5.<span class="hljs-title function_">neuralNetwork</span>({
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-attr">inputs</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">outputs</span>: [<span class="hljs-string">&quot;flap&quot;</span>, <span class="hljs-string">&quot;no flap&quot;</span>],
      <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;classification&quot;</span>,
</code></pre><div class="comment"><p>Мозок птаха отримує чотири вхідні дані і класифікує їх в одну з двох міток.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-attr">neuroEvolution</span>: <span class="hljs-literal">true</span>.
</code></pre><div class="comment"><p>Нова властивість, необхідна для забезпечення функціональності нейроеволюції.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    });
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Далі до класу <code>Bird</code> я додам новий метод <code>think()</code> для обчислення всіх необхідних вхідних даних птаха в кожен момент часу. Перші два входи прості — це просто властивості птаха <code>y</code> і <code>velocity</code>. Однак для входів 3 і 4 мені потрібно визначити, яка труба є наступною.</p>
<p>На перший погляд, може здатися, що наступна труба завжди буде у масиві першою, оскільки труби додаються по одній у кінець масиву. Однак після того, як труба проходить повз птаха, вона вже не актуальна, але все ще залишається деякий проміжок часу допоки повністю не вийде за межі полотна і не буде видалена з початку масиву. Тому мені потрібно знайти у масиві першу трубу в якої положення правого краю (її <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-позиція плюс ширина) більше за <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>-позицію пташки:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">think</span>(<span class="hljs-params">pipes</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> nextPipe = <span class="hljs-literal">null</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pipe <span class="hljs-keyword">of</span> pipes) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">if</span> (pipe.<span class="hljs-property">x</span> + pipe.<span class="hljs-property">w</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>) {
        nextPipe = pipe;
        <span class="hljs-keyword">break</span>;
      }
</code></pre><div class="comment"><p>Наступна труба — це та, яка ще не пройшла повз птаха.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Отримавши наступну перешкоду, я можу створити чотири входи:</p>
<div class="snip-above snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> inputs = [
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>,
</code></pre><div class="comment"><p>y-положення птаха.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>,
</code></pre><div class="comment"><p>y-швидкість птаха.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      nextPipe.<span class="hljs-property">top</span>,
</code></pre><div class="comment"><p>Верхня частина отвору наступної труби.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      nextPipe.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>,
</code></pre><div class="comment"><p>Відстань до наступної труби.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    ];
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Вже близько, але я забув критичний крок. Діапазон усіх вхідних значень визначається розмірами полотна, але нейронна мережа очікує значення у стандартизованому діапазоні, подібному до діапазону від 0 до 1. Одним із методів нормалізації цих значень є розділення значень вхідних даних, пов’язаних із вертикальними властивостями, на значення <code>height</code>, а тих, що пов&#x27;язані з горизонтальними — на <code>width</code>:</p>
<div class="snip-above snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> inputs = [
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> / height,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> / height,
      nextPipe.<span class="hljs-property">top</span> / height,
      (nextPipe.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>) / width,
</code></pre><div class="comment"><p>Усі вхідні дані тепер нормалізовано по ширині і висоті.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    ];
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Маючи в руках вхідні дані, я готовий передати їх методу нейронної мережі <code>classify()</code>. Однак у мене є ще одна невелика проблема: метод  <code>classify()</code> асинхронний, тобто для обробки рішення моделі мені доведеться реалізувати механізм зворотного виклику усередині класу <code>Bird</code>. Це додало б значного ускладнення коду, але, на щастя, у цьому випадку це зовсім непотрібно. Асинхронні зворотні виклики для функцій машинного навчання ml5.js зазвичай потрібні через час, необхідний для обробки моделлю великої кількості даних. Без функції зворотного виклику програмі для отримання результату від моделі може знадобитися певний час і якщо модель працює як частина програми p5.js, ця затримка може серйозно вплинути на плавність анімації. Проте нейронна мережа тут має лише чотири числові входи й дві вихідні мітки! Ці дані достатньо маленькі й можуть працювати досить швидко, тому в такому випадку немає причин використовувати асинхронний код.</p>
<div class="avoid-break">
  <p>Для повноти на вебсайті книги я додав версію прикладу, яка реалізує нейроеволюцію з асинхронними зворотними викликами. Однак для цього обговорення я збираюся використовувати функцію ml5.js, яка дозволяє мені використовувати синхронний підхід. Метод <code>classifySync()</code> ідентичний методу <code>classify()</code>, але він працює синхронно, тобто код зупиняється та чекає на результати, перш ніж рушити далі. Ви повинні бути дуже обережними, використовуючи цю версію методу, оскільки вона може спричинити проблеми в інших контекстах, але для цього простого сценарію вона працюватиме добре. Ось кінцева частина методу <code>think()</code> з використанням <code>classifySync()</code>:</p>
</div>
<div class="snip-above">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> results = <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span>.<span class="hljs-title function_">classifySync</span>(inputs);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (results[<span class="hljs-number">0</span>].<span class="hljs-property">label</span> === <span class="hljs-string">&quot;flap&quot;</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">flap</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Прогноз нейронної мережі має той самий формат, що й класифікатор рухів з <a href="/neural-networks#section-neural-networks">Розділу 10</a> і потрібне рішення можна прийняти, перевіривши перший елемент масиву <code>results</code>. Якщо вихідна мітка це <code>&quot;flap&quot;</code>, тоді викликаємо метод <code>flap()</code>.</p>
<p>Тепер, коли я закінчив метод <code>think()</code>, можна перейти до справжнього виклику: навчити птаха вигравати у грі, постійно змахуючи крилами в потрібний момент. Ось де у сюжет повертається ГА. Пригадаємо з <a href="/genetic-algorithms#section-genetic-algorithms">Розділу 9</a> три ключові принципи, які лежать в основі дарвінівської еволюції: мінливість або варіативність, відбір і спадковість. Я по черзі перегляну кожен із цих принципів, реалізуючи кроки ГА у цьому новому контексті нейронних мереж.</p>
<h3 id="variation-a-flock-of-flappy-birds"><a class="heading-link" href="#variation-a-flock-of-flappy-birds">Варіативність Flappy Birds: Зграя</a></h3>
<p>Один птах з ініціалізованою випадковою нейронною мережею навряд чи матиме успіх. Цей самотній птах, швидше за все, безперервно махатиме крильми й летітиме все вище за межі екрана, або сидітиме внизу полотна, очікуючи на зіткнення за зіткненням із трубами. Ця хаотична та безглузда поведінка є нагадуванням: випадково ініціалізована нейронна мережа не має жодних знань чи досвіду. Птах, по суті, робить щодо своїх дій випадкові припущення хаотичного типу, тому успіх буде рідкісним.</p>
<p>Ось тут і з’являється перший ключовий принцип ГА — <strong>варіативність</strong>. Розрахунок на те, що запровадивши якомога більше різних конфігурацій нейронної мережі, деякі з них можуть проявити себе трохи краще, ніж решта. Першим кроком до варіації є створення масиву з багатьма птахами (малюнок 11.4).</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1246&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/4d0509090f18e9f76e77113976e7f557/af721/11_nn_ga_6.webp 576w,./static/4d0509090f18e9f76e77113976e7f557/0a8bf/11_nn_ga_6.webp 1152w,./static/4d0509090f18e9f76e77113976e7f557/8950e/11_nn_ga_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/4d0509090f18e9f76e77113976e7f557/9ea8b/11_nn_ga_6.png" data-srcset="./static/4d0509090f18e9f76e77113976e7f557/993e5/11_nn_ga_6.png 576w,./static/4d0509090f18e9f76e77113976e7f557/62dd3/11_nn_ga_6.png 1152w,./static/4d0509090f18e9f76e77113976e7f557/9ea8b/11_nn_ga_6.png 2304w" alt="Малюнок 11.4: Популяція птахів, які у процесі нейроеволюції переміщуються по трубах. Кожна птаха має унікальну нейронну мережу"/></picture><noscript><picture><source type="image/webp" srcSet="./static/4d0509090f18e9f76e77113976e7f557/af721/11_nn_ga_6.webp 576w,./static/4d0509090f18e9f76e77113976e7f557/0a8bf/11_nn_ga_6.webp 1152w,./static/4d0509090f18e9f76e77113976e7f557/8950e/11_nn_ga_6.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/4d0509090f18e9f76e77113976e7f557/9ea8b/11_nn_ga_6.png" srcSet="./static/4d0509090f18e9f76e77113976e7f557/993e5/11_nn_ga_6.png 576w,./static/4d0509090f18e9f76e77113976e7f557/62dd3/11_nn_ga_6.png 1152w,./static/4d0509090f18e9f76e77113976e7f557/9ea8b/11_nn_ga_6.png 2304w" alt="Малюнок 11.4: Популяція птахів, які у процесі нейроеволюції переміщуються по трубах. Кожна птаха має унікальну нейронну мережу"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 11.4: Популяція птахів, які у процесі нейроеволюції переміщуються повз труби. Кожна птаха має унікальну нейронну мережу</figcaption>
</figure>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> populationSize = <span class="hljs-number">200</span>;
</code></pre><div class="comment"><p>Чисельність популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> birds = [];
</code></pre><div class="comment"><p>Масив птахів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; populationSize; i++) {
    birds[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();
  }
</code></pre><div class="comment"><p>Створення популяції птахів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  ml5.<span class="hljs-title function_">setBackend</span>(<span class="hljs-string">&quot;cpu&quot;</span>);
</code></pre><div class="comment"><p>Запуск обчислення на CPU для кращої продуктивності.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bird <span class="hljs-keyword">of</span> birds) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    bird.<span class="hljs-title function_">think</span>(pipes);
</code></pre><div class="comment"><p>Це новий спосіб за допомогою якого птах приймає рішення махати крилами чи ні.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bird.<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bird.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Ви можете помітити особливий рядок коду, який прокрався у функцію <code>setup()</code>: <code>ml5.setBackend(&quot;cpu&quot;)</code>. Під час роботи нейронних мереж багато важких обчислювальних операцій часто перекладають на GPU. Це поведінка за замовчуванням і це особливо важливо для більших попередньо натренованих моделей, які входять до ml5.js.</p>
<div data-type="note" class="callout">
  <h3 id="gpu-vs-cpu"><a class="heading-link" href="#gpu-vs-cpu">GPU проти CPU</a></h3>
  <ul>
    <li><strong>Графічний процесор (GPU — graphics processing unit):</strong> початково розроблений для візуалізації графіки, вправно обробляє величезну кількість операцій паралельним чином. Це робить його чудовим для математичних операцій і обчислень, які часто виконують моделі машинного навчання.</li>
    <li><strong>Центральний процесор (CPU — central processing unit):</strong> часто вважається мозком або серцем комп’ютера універсального значення, обробляє ширшу різноманітність завдань, ніж спеціалізований графічний процесор, але він не створений для одночасного виконання такої ж кількості завдань.</li>
  </ul>
</div>
<p>Але тут є заковика! Передача даних до графічного процесора і назад створює додаткові витрати. У більшості випадків переваги від паралельної обробки графічним процесором з лишком компенсують ці накладні витрати, але для крихітної моделі, як тут, копіювання даних у графічний процесор і назад фактично сповільнює роботу нейронної мережі. Виклик <code>ml5.setBackend(&quot;cpu&quot;)</code> повідомляє ml5.js виконувати обчислення нейронної мережі на CPU замість GPU. Принаймні в цьому простому випадку з невеликими пташиними мізками це ефективніший вибір.</p>
<h3 id="selection-flappy-bird-fitness"><a class="heading-link" href="#selection-flappy-bird-fitness">Відбір Flappy Bird: Функція оцінювання придатності</a></h3>
<p>Коли я маю різноманітну популяцію птахів, кожна з яких має власну нейронну мережу, наступним кроком у ГА стане <strong>відбір</strong>. Які птахи повинні передати свої гени (у нашому випадку, вагу нейронної мережі) наступному поколінню? У світі <em>Flappy Bird</em> мірилом успіху є здатність залишатися в живих якнайдовше, уникаючи труб. Це <em>пристосованість</em> птаха. Птах, який ухиляється від багатьох труб, вважається більш придатним, ніж той, який врізається у першу зустрічну перешкоду.</p>
<p>Щоб відстежувати оцінку пристосованості кожного птаха, я додам до класу <code>Bird</code> дві властивості — <code>fitness</code> і <code>alive</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Оцінка пристосованості птаха.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">alive</span> = <span class="hljs-literal">true</span>;
</code></pre><div class="comment"><p>Змінна, що повідомляє чи жива наразі птаха.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я призначаю змінній пристосованості числове значення, яке збільшується на одиницю кожного кадру анімації, доки птах залишається живим. Птахи, які виживають довше, повинні мати вищу пристосованість. Цей механізм відображає техніку навчання з підкріпленням винагородою за хороші рішення. Однак під час навчання з підкріпленням агент отримує негайний зворотний зв’язок за кожне прийняте ним рішення, що дозволяє йому коригувати відповідним чином свою політику. Тут пристосованість птаха є кумулятивним показником його загального успіху і застосовуватиметься лише на етапі відбору ГА:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span>++;
</code></pre><div class="comment"><p>Збільшення значення пристосованості у методі update().</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Властивість <code>alive</code> має булевий тип, значення якого напочатку встановлено у <code>true</code>. Коли пташка зіштовхується з трубою, для цієї властивості встановлюється значення <code>false</code>. Оновлюються і малюються на полотні лише ті птахи, що залишаються живими:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bird <span class="hljs-keyword">of</span> birds) {
</code></pre><div class="comment"><p>На початку є масив пташок.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (bird.<span class="hljs-property">alive</span>) {
</code></pre><div class="comment"><p>Малювати і оновлювати потрібно лише живих птахів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      bird.<span class="hljs-title function_">think</span>(pipes);
</code></pre><div class="comment"><p>Рішення приймаються на основі труб.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      bird.<span class="hljs-title function_">update</span>();
      bird.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Оновлення і зображення птаха.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pipe <span class="hljs-keyword">of</span> pipes) {
        <span class="hljs-keyword">if</span> (pipe.<span class="hljs-title function_">collides</span>(bird)) {
          bird.<span class="hljs-property">alive</span> = <span class="hljs-literal">false</span>;
        }
</code></pre><div class="comment"><p>Якщо птах зачепив трубу, він вважається неживим.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У <a href="/genetic-algorithms#section-genetic-algorithms">Розділі 9</a> я продемонстрував два способи проведення еволюційного моделювання. У прикладі розумних ракет популяція існувала фіксовану кількість часу для кожного покоління. Той самий підхід, ймовірно, може спрацювати й тут, але я хочу дозволити птахам накопичувати найбільше можливе значення пристосованості, а не довільно зупиняти їх через певний ліміт часу. Другий спосіб продемонстрований на прикладі блупів, повністю виключає оцінку придатності й встановлює випадкову ймовірність клонування будь-якої живої істоти. Для <em>Flappy Bird</em> такий підхід може стати безладним і загрожує перенаселенням або повним вимиранням усіх птахів.</p>
<p>Я пропоную поєднати особливості обох підходів. Я дозволю поколінню існувати доки живою буде хоча б одна пташка. Коли всі птахи загинуть я виберу батьків для етапу відтворення і почну заново. Я почну з написання функ ції, що перевірятиме, чи всі птахи загинули:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">allBirdsDead</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bird <span class="hljs-keyword">of</span> birds) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (bird.<span class="hljs-property">alive</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
</code></pre><div class="comment"><p>Якщо жива хоча б одна пташка, значить не всі вони мертві!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</code></pre><div class="comment"><p>Якщо цикл закінчується без виявлення жодної живої птахи, значить усі вони мертві.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Коли всі птахи загинули, настав час відбору! У попередніх прикладах ГА я показав техніку естафети для надання справедливого шансу усім членам популяції, водночас збільшуючи шанси відбору для тих, хто має вищий показник придатності. Я використаю тут ту саму функцію <code>weightedSelection()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">weightedSelection</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p>Для детального пояснення цього алгоритму перегляньте Розділ 9.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> start = <span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">while</span> (start &gt; <span class="hljs-number">0</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    start = start - birds[index].<span class="hljs-property">fitness</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    index++;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  index--;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">return</span> birds[index].<span class="hljs-property">brain</span>;
</code></pre><div class="comment"><p>Замість повернення всього об’єкта, Bird повертається лише його мозок.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Щоб цей алгоритм працював належним чином, мені потрібно спершу нормалізувати значення придатності птахів, щоб їх сума разом складала 1-цю:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeFitness</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bird <span class="hljs-keyword">of</span> birds) {
    sum += bird.<span class="hljs-property">fitness</span>;
  }
</code></pre><div class="comment"><p>Підрахунок суми загального значення придатності усіх птахів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bird <span class="hljs-keyword">of</span> birds) {
    bird.<span class="hljs-property">fitness</span> = bird.<span class="hljs-property">fitness</span> / sum;
  }
</code></pre><div class="comment"><p>Поділ значення придатності кожного птаха на загальну суму.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Після нормалізації придатність кожного птаха дорівнює його ймовірності для відбору.</p>
<h3 id="heredity-baby-birds"><a class="heading-link" href="#heredity-baby-birds">Спадковість: Пташенята</a></h3>
<p>У ГА залишився лише один крок — відтворення. У <a href="/genetic-algorithms#section-genetic-algorithms">Розділі 9</a> я дуже детально пояснював про двоетапний процес генерації дочірнього елемента: схрещування і мутацію. Схрещування — це той крок де відбувається третій ключовий принцип <strong>спадковості</strong>: ДНК двох відібраних батьківських об’єктів об’єднується для формування дочірньої ДНК.</p>
<p>На перший погляд, ідея винайдення алгоритму для схрещування двох нейронних мереж може налякати, але насправді вона досить проста. Міркуйте про окремі “гени” мозку птахів як про ваги у нейронній мережі. Змішування двох таких мізків зводиться до створення нової нейронної мережі де кожна вага обрана через віртуальне підкидання монети — вага береться від першого або другого батьківського об’єкта:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> parentA = <span class="hljs-title function_">weightedSelection</span>();
<span class="hljs-keyword">let</span> parentB = <span class="hljs-title function_">weightedSelection</span>();
<span class="hljs-keyword">let</span> child = parentA.<span class="hljs-title function_">crossover</span>(parentB);
</code></pre><div class="comment"><p>Вибір двох батьків і створення дочірнього об’єкту за допомогою схрещування.</p></div></div></div>
<p>О так, сьогодні мій щасливий день! Виявляється ml5.js вже має метод <code>crossover()</code>, який керує алгоритмом змішування двох нейронних мереж. Тож я з радістю можу перейти до кроку з мутацією:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript">child.<span class="hljs-title function_">mutate</span>(<span class="hljs-number">0.01</span>);
</code></pre><div class="comment"><p>Застосування мутації.</p></div></div></div>
<p>Моя удача продовжується! Бібліотека ml5.js також надає і метод <code>mutate()</code>, який приймає першим аргументом значення для швидкості мутації. Швидкість визначає, як часто буде змінюватися вага. Наприклад, коефіцієнт 0.01 вказує на 1 відсоток ймовірності того, що будь-яка задана вага зміниться. Під час мутації ml5.js трохи коригує вагу, додаючи до неї невелике випадкове число, а не вибираючи зовсім нове випадкове значення. Така поведінка імітує реальні генетичні мутації, які зазвичай вносять незначні зміни, а не абсолютно нові ознаки. Хоча цей підхід за замовчуванням пра цює у багатьох випадках, ml5.js пропонує більше контролю над процесом, дозволяючи використовувати спеціальну функцію мутації як необов’язковий другий аргумент у методі <code>mutate()</code>.</p>
<p>Етапи схрещування і мутації потрібно повторювати для отримання такого ж розміру нового покоління пташок, що й у поточній популяції. Це досягається шляхом заповнення новими птахами порожнього локального масиву <code>nextBirds</code> до потрібного розміру. Після заповнення популяції нового покоління глобальний масив <code>birds</code> оновлює своє посилання на цей новий масив:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reproduction</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> nextBirds = [];
</code></pre><div class="comment"><p>Початок з новим порожнім масивом.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; populationSize; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> parentA = <span class="hljs-title function_">weightedSelection</span>();
    <span class="hljs-keyword">let</span> parentB = <span class="hljs-title function_">weightedSelection</span>();
</code></pre><div class="comment"><p>Вибір двох батьків.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> child = parentA.<span class="hljs-title function_">crossover</span>(parentB);
</code></pre><div class="comment"><p>Створення дочірнього елементу за рахунок схрещування.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    child.<span class="hljs-title function_">mutate</span>(<span class="hljs-number">0.01</span>);
</code></pre><div class="comment"><p>Застосування мутації.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    nextBirds[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>(child);
</code></pre><div class="comment"><p>Створення нового птаха.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  birds = nextBirds;
</code></pre><div class="comment"><p>Наступне покоління стає поточним!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Якщо ви уважно придивитесь до функції <code>reproduction()</code>, то можете помітити, що у конструктор класу <code>Bird</code> я передаю аргумент. Коли я вперше представив ідею пташиного мозку, кожен новий об’єкт <code>Bird</code> створювався з абсолютно новим мозком — свіжоствореною нейронною мережею, наданою ml5.js. Однак тепер я хочу, щоб нові птахи <em>успадкували</em> дочірній мозок, який утворився в процесі схрещування і мутації. Щоб зробити це можливим, я трохи зміню конструктор класу <code>Bird</code>, щоб використовувати необов’язковий аргумент під назвою <code>brain</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">brain</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (brain) {
</code></pre><div class="comment"><p>Перевірка, чи мозок був переданий.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span> = brain;
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p>Якщо мозок не переданий буде створено новий.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span> = ml5.<span class="hljs-title function_">neuralNetwork</span>({
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">inputs</span>: <span class="hljs-number">4</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">outputs</span>: [<span class="hljs-string">&quot;flap&quot;</span>, <span class="hljs-string">&quot;no flap&quot;</span>],
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;classification&quot;</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">neuroEvolution</span>: <span class="hljs-literal">true</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      });
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
  <p>Якщо під час створення нового птаха <code>brain</code> не передано, тоді цей аргумент матиме значення <code>undefined</code>. У JavaScript значення <code>undefined</code> розглядається як <code>false</code>. Таким чином перевірка <span style="white-space:nowrap"><code>if (brain)</code></span> буде негативною, тому код перейде до оператора <code>else</code> і викличе <code>ml5.neuralNetwork()</code>. З іншого боку, якщо через аргумент передається нейронна мережа, що існує, тоді перевірка на <code>brain</code> пройде ствердно наче <code>true</code> і значення буде безпосередньо присвоєне до властивості <code>this.brain</code>. Цей елегантний підхід дозволяє одному конструктору обробляти кілька сценаріїв.</p>
<p>На цьому приклад завершено. Все, що залишилося зробити, це викликати <code>normalizeFitness()</code> і <code>reproduction()</code> усередині функції <code>draw()</code> у кінці кожного покоління, коли всі птахи загинули.</p>
<div data-type="example">
  <h3 id="example-112-flappy-bird-with-neuroevolution"><a class="heading-link" href="#example-112-flappy-bird-with-neuroevolution">Приклад 11.2: Flappy Bird із нейроеволюцією</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/11_nn_ga/11_2_flappy_bird_neuro_evolution"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/PEUKc5dpZ" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-comment">/* Уся інша частина функції */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">allBirdsDead</span>()) {
    <span class="hljs-title function_">normalizeFitness</span>();
    <span class="hljs-title function_">reproduction</span>();
    <span class="hljs-title function_">resetPipes</span>();
</code></pre><div class="comment"><p>Створення наступного покоління, коли всі птахи загинули.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resetPipes</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  pipes.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, pipes.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Видалення всіх труб, окрім останньої.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зверніть увагу на додану нову функцію <code>resetPipes()</code>. Якщо я не видалю труби перед тим, як почати нове покоління, птахи можуть моментально перезапуститися у позиціях, що одразу перетинаються з трубою, яка на той момент була на початку полотна, і в цьому випадку навіть найкращий птах не матиме шансу для польоту! Повний онлайн-код для прикладу 11.2 також обробляє поведінку птахів таким чином, що коли вони вилітають за верхню або нижню межі полотна, то гинуть.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-112"><a class="heading-link" href="#exercise-112">Вправа 11.2</a></h3>
  <p>Приклад 11.2 потребує багато часу, щоб отримати якісь результати. Чи могли б ви “прискорити час”, пропускаючи малювання кожного кадру гри, щоб досягти оптимальних характеристик птаха швидше? (Рішення буде представлено у частині цього розділу під однойменною назвою <a href="#speeding-up-time" class="page-reference">“Прискорення часу”</a>.) Крім того, чи можете ви відобразити додаткову інформацію про статус симуляції, наприклад, кількість активних птахів, які все ще беруть участь у грі, поточне покоління і тривалість життя найкращих пташок?</p>
</div>
<div data-type="exercise" class="callout">
  <h3 id="exercise-113"><a class="heading-link" href="#exercise-113">Вправа 11.3</a></h3>
  <p>Щоб не запускати процес нейроеволюції кожного разу з нуля, спробуйте використовувати методи нейронної мережі від ml5.js та її методи <code>save()</code> і <code>load()</code>. Як можна додати функціональність, яка зберігає найкращу модель птаха, а також опцію завантаження попередньо збереженої моделі?</p>
</div>
<h2 id="steering-the-neuroevolutionary-way"><a class="heading-link" href="#steering-the-neuroevolutionary-way">Керування нейроеволюцією</a></h2>
<p>Дослідивши нейроеволюцію за допомогою <em>Flappy Bird</em>, я хотів би перенести фокус назад на область моделювання, зокрема до керувальних агентів, представлених у <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a>. Що, якби замість того, щоб я диктував правила для алгоритму розрахунку керівної сили, імітоване створіння могло б розвинути власну стратегію? Черпаючи натхнення від Рейнольдса щодо реалістичної й імпровізаційної поведінки, моя мета полягає не в тому, щоб використовувати нейроеволюцію для створення ідеальної істоти, яка може бездоганно виконувати завдання. Натомість я сподіваюся створити захопливий світ симуляції життя, де на полотні розгортаються різні дивацтва, нюанси й щасливі випадковості еволюції.</p>
<p>Я почну з адаптації прикладу розумних ракет з <a href="/genetic-algorithms#section-genetic-algorithms">Розділу 9</a>. У цьому прикладі гени для кожної ракети являли собою масив векторів:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span> = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lifeSpan; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i] = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">random2D</span>();
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[i].<span class="hljs-title function_">mult</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxforce</span>));
</code></pre><div class="comment"><p>Кожен ген є вектором із випадковим напрямком і величиною.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Я пропоную адаптувати цей код, щоб натомість використовувати нейронну мережу для прогнозування вектора або сили керування, перетворивши <code>genes</code> на <code>brain</code>. Вектори можуть мати безперервний діапазон значень, тому це регресійна задача:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span> = ml5.<span class="hljs-title function_">neuralNetwork</span>({
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">inputs</span>: <span class="hljs-number">2</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">outputs</span>: <span class="hljs-number">2</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;regression&quot;</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-attr">neuroEvolution</span>: <span class="hljs-literal">true</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">});
</code></pre><div class="comment"><p></p></div></div></div>
<p>В оригінальному прикладі вектори з масиву <code>genes</code> застосовувалися послідовно, зчитуючи значення масиву за допомогою змінної <code>counter</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">applyForce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">genes</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>]);
</code></pre><div class="comment"><p></p></div></div></div>
<p>Тепер, замість пошуку потрібного значення у масиві, я хочу, щоб нейронна мережа повертала новий вектор для кожного кадру анімації. Для задач регресії з ml5.js вихід нейронної мережі отримується з методу <code>predict()</code>. І тут я використаю варіант синхронного методу <code>predictSync()</code> що збереже код простим і дозволить синхронне отримання вихідних даних із моделі у методі ракети <code>run()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> outputs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span>.<span class="hljs-title function_">predictSync</span>(inputs);
</code></pre><div class="comment"><p>Отримання вихідних даних нейронної мережі.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> angle = outputs[<span class="hljs-number">0</span>].<span class="hljs-property">value</span> * <span class="hljs-variable constant_">TWO_PI</span>;
</code></pre><div class="comment"><p>Використання одного вихідного значення для кута.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> magnitude = outputs[<span class="hljs-number">1</span>].<span class="hljs-property">value</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxforce</span>;
</code></pre><div class="comment"><p>Використання іншого вихідного значення для магнітуди.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">let</span> force = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">fromAngle</span>(angle)
  force.<span class="hljs-title function_">setMag</span>(magnitude);
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">applyForce</span>(force);
</code></pre><div class="comment"><p>Створення і застосовування сили.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Мозок нейронної мережі виводить два значення: одне для кута вектор а й одне для його магнітуди. Ви можете подумати, щоб натомість використовувати ці результати для <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-компонентів вектора. Проте стандартний вихідний діапазон у нейронної мережі ml5.js має значення від 0 до 1, а я хочу, щоб сили були здатні спрямовуватись у будь-якому напрямку, а не лише у додатному. Стандартний вихідний діапазон можна перевести в інший, наприклад можна помножити перший вихід, що використовується для кута на <code>TWO_PI</code>, що забезпечить повний діапазон кутів.</p>
<p>Визначення вхідних даних для нейронної мережі — це те місце, де ви, як розробник системи, можете бути найбільш креативними. Ви повинні врахувати природу навколишнього середовища і змодельовану біологію та можливості ваших створінь і потім вирішити, які характеристики є найважливішими.</p>
<p>Для першої спроби я призначу для входів щось просте і перевірю, чи це спрацює. Оскільки середовище розумних ракет є статичним, з фіксованими перешкодами й цілями, можливо мозок міг би вивчити та вирахувати поле потоків для навігації до своєї мети? Як я показав у <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a>, поле потоків отримує позицію і повертає вектор, тому нейромережа може віддзеркалювати цю функціональність та використовувати як вхідні дані поточні <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-координати ракети. Мені просто потрібно нормалізувати значення відповідно до розмірів полотна:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> inputs = [<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> / width, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> / height];
</code></pre><div class="comment"><p></p></div></div></div>
<p>Це воно! Практично все інше з оригін ального прикладу може залишитися незмінним: популяція, функція оцінювання придатності й процес відбору.</p>
<div data-type="example">
  <h3 id="example-113-smart-rockets-with-neuroevolution"><a class="heading-link" href="#example-113-smart-rockets-with-neuroevolution">Приклад 11.3: Розумні ракети з нейроеволюцією</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/11_nn_ga/11_3_smart_rockets_neuro_evolution"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/KkV4lTS4H" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">reproduction</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> nextPopulation = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span>.<span class="hljs-property">length</span>; i++) {
</code></pre><div class="comment"><p>Створення наступної популяції.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> parentA = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">weightedSelection</span>();
      <span class="hljs-keyword">let</span> parentB = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">weightedSelection</span>();
      <span class="hljs-keyword">let</span> child = parentA.<span class="hljs-title function_">crossover</span>(parentB);
</code></pre><div class="comment"><p>Підхід з колесом фортуни, щоб вибрати двох батьків.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      child.<span class="hljs-title function_">mutate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">mutationRate</span>);
</code></pre><div class="comment"><p>Застосування мутації.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      nextPopulation[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rocket</span>(<span class="hljs-number">320</span>, <span class="hljs-number">220</span>, child);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">population</span> = nextPopulation;
</code></pre><div class="comment"><p>Заміна старої популяції.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">generations</span>++;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зауважте, що тепер, коли я використовую ml5.js, мені більше не потрібен окремий клас <code>DNA</code> із реалізаціями методів <code>crossover()</code> і <code>mutate()</code>. Натомість можна безпосередньо викликати відповідні методи, що вбудовані у <code>ml5.neuralNetwork</code>.</p>
<div data-type="exercise" class="callout">
  <h3 id="exercise-114"><a class="heading-link" href="#exercise-114">Вправа 11.4</a></h3>
  <p>Керувальна сила, як визначено Рейнольдсом — це різниця між бажаною швидкістю агента і його поточною швидкістю. Як ця еволюційна система може відображати цю методологію? Що, якщо замість того, щоб використовувати лише положення як вхідні дані для нейронної мережі, ви введете поточну швидкість ракети? Ви можете спробувати використати <span data-type="equation" class="math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">xy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>-компоненти або напрямок і магнітуду вектора. Не забудьте нормалізувати ці значення!</p>
</div>
<h3 id="responding-to-change"><a class="heading-link" href="#responding-to-change">Реагування на зміни</a></h3>
<p>У попередньому прикладі середовище було статичним із нерухомою ціллю і перешкодою. Це зробило задачу ракети по знаходженню цілі легкою, достатньо було використати лише положення як вихідні дані. Але що, якби ціль і перешкоди на шляху ракети рухалися? Щоб працювати зі складнішим і мінливішим середовищем, мені потрібно розширити вхідні дані нейронної мережі та розглянути додаткові особливості середовища. Це схоже на те, що я зробив із <em>Flappy Bird</em>, коли визначив ключові дані середовища для керування процесом прийняття рішень птахом.</p>
<p>Я почну з найпростішої версії цього сценарію, майже ідентичної оригінальному прикладу розумних ракет, але без перешкод, і заміною статичну ціль на рухому, що випадково блукає за допомогою шуму Перліна. У цьому прикладі я перейменую клас <code>Rocket</code> на <code>Creature</code> і створю клас <code>Glow</code> подібно до блукача, який представлятиме кулю, що дрейфуватиме на полотні. Уявіть, що ціль створіння — дістатися до джерела світла і танцювати в його сяйливих обіймах так довго, наскільки це буде можливо:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Glow</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xoff</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yoff</span> = <span class="hljs-number">1000</span>;
</code></pre><div class="comment"><p>Початкові зміщення для шуму Перліна.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">24</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = <span class="hljs-title function_">noise</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xoff</span>) * width;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-title function_">noise</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yoff</span>) * height;
</code></pre><div class="comment"><p>Призначення позиції відповідно до шуму Перліна.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xoff</span> += <span class="hljs-number">0.01</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yoff</span> += <span class="hljs-number">0.01</span>;
</code></pre><div class="comment"><p>Рух відбувається залежно від простору шуму Перліна.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">strokeWeight</span>(<span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">200</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У процесі прийняття своїх рішень створіння повинно враховувати положення рухомого сяйва як вхідні дані для свого мозку. Однак недостатньо знати лише положення сяйва, ключовою є відносна позиція до самої істоти. Хороший спосіб синтезувати цю інформацію як вхідну характеристику — це обчислити вектор, який вказує від істоти до сяйва. По суті, я переосмислюю метод <code>seek()</code> з <a href="/autonomous-agents#section-autonomous-agents">Розділу 5</a>, використовуючи нейронну мережу для оцінки керувальної сили:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">seek</span>(<span class="hljs-params">target</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> v = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">sub</span>(target.<span class="hljs-property">position</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>);
</code></pre><div class="comment"><p>Обчислення вектора від позиції до цілі.</p></div></div></div>
</div>
<p>Це хороший початок, але значення компонентів вектора не підходять до нормалізованого вхідного діапазону. Я міг би поділити <code>v.x</code> на <code>width</code> і <code>v.y</code> на <code>height</code>, але оскільки моє полотно не ідеально квадратне, це може спотворити дані. Іншим рішенням є нормалізація вектора, але хоча це збереже інформацію про напрямок від створіння до сяйва, це позбавить будь-якої можливості вимірювати відстані. Це також не підійде — якщо створіння знаходиться у центрі сяйва, то має керуватися іншим чином, ніж якби воно було дуже далеко. Як рішення, перед нормалізацією вектора я збережу значення відстані в окремій змінній. Але щоб використати відстань для входу мені все одно потрібно нормалізувати її діапазон. Хоча це не ідеальна нормалізація від 0 до 1, я розділю її на ширину полотна, що забезпечить практичну нормалізацію, яка зберігає відносну магнітуду:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">seek</span>(<span class="hljs-params">target</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> v = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">sub</span>(target.<span class="hljs-property">position</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = v.<span class="hljs-title function_">mag</span>() / width;
</code></pre><div class="comment"><p>Збереження відстані у змінній і нормалізація значення відповідно до ширини (один вхід).</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    v.<span class="hljs-title function_">normalize</span>();
</code></pre><div class="comment"><p>Нормалізація вектора, що вказує від позиції до цілі (два входи).</p></div></div></div>
</div>
<p>Як ви можете пам’ятати, ключовим елементом керувальної формули Рейнольдса було порівняння бажаної швидкості з поточною. Те, як рухається об’єкт, відіграє важливу роль у тому, як він має керуватись! Щоб створіння розглядало власну швидкість як частину свого рішення, у вхідні дані для нейронної мережі я також можу включити вектор швидкості. Для нормалізації цих значень чудово спрацює розділення значень компонентів вектора на властивість <code>maxspeed</code>. Це збереже як напрямок, так і відносну величину вектора. Решта методу <code>seek()</code> дотримується тієї ж логіки, що й у попередньому прикладі, з виходами нейронної мережі, синтезованими в силу, яку потрібно застосувати до створіння:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">seek</span>(<span class="hljs-params">target</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> v = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">sub</span>(target.<span class="hljs-property">position</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> distance = v.<span class="hljs-title function_">mag</span>() / width;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    v.<span class="hljs-title function_">normalize</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> inputs = [
      v.<span class="hljs-property">x</span>,
      v.<span class="hljs-property">y</span>,
      distance,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>.<span class="hljs-property">x</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span>,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span>.<span class="hljs-property">y</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span>,
    ];
</code></pre><div class="comment"><p>Збір важливих характеристик у масив вхідних даних.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> outputs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span>.<span class="hljs-title function_">predictSync</span>(inputs);
    <span class="hljs-keyword">let</span> angle = outputs[<span class="hljs-number">0</span>].<span class="hljs-property">value</span> * <span class="hljs-variable constant_">TWO_PI</span>;
    <span class="hljs-keyword">let</span> force = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">fromAngle</span>(angle);
    <span class="hljs-keyword">let</span> magnitude = outputs[<span class="hljs-number">1</span>].<span class="hljs-property">value</span>;
    force.<span class="hljs-title function_">setMag</span>(magnitude);
</code></pre><div class="comment"><p>Прогнозування сили, яку необхідно застосувати.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">applyForce</span>(force);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Під час переходу від ракет до створінь відбулося багато змін, тому варто також пе реглянути функцію оцінки придатності. Раніше придатність обчислювалася в кінці кожного покоління на основі найкоротшої відстані від ракети до цілі. Оскільки зараз ціль рухається, я вважаю, що кращою оцінкою буде підрахунок кількості часу, протягом якого створіння здатне вловлювати об’єкт сяйва. Це можна зробити, перевіряючи відстань між створінням і сяйвом у методі <code>update()</code> та збільшуючи значення <code>fitness</code>, коли вони перетинаються:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params">target</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* Звичайне оновлення положення, швидкості, прискорення */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> d = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, target.<span class="hljs-property">position</span>);
    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> + target.<span class="hljs-property">r</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span>++;
    }
</code></pre><div class="comment"><p>Збільшення значення придатності кожного разу, коли створіння достатньо близько біля сяйва.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Обидва класи <code>Glow</code> і <code>Creature</code> мають властивість для радіуса — <code>r</code>, яку я використовую для визначення перетину.</p>
<h3 id="speeding-up-time"><a class="heading-link" href="#speeding-up-time">Прискорення часу</a></h3>
<p>Одна річ, яку ви могли помітити стосовно еволюційних обчислень, полягає в тому, що тестування коду є чудовою вправою на терпіння. Ви повинні спостерігати, як симуляція повільно розвивається покоління за поколінням. Це частина суті — я <em>хочу</em> спостерігати за процесом! Це також гарний привід для перерви, яку іноді слід робити. Вийдіть на вулицю і насолодіться деякий час неімітованою природою або, можливо, випийте заспокійливу чашку чаю. Потім перевірте свої створіння і подивіться на їх прогрес. Заспокойте себе тим, що вам доведеться чекати лише мільйони мілісекунд, а не мільйони років, необхідних для справжньої біологічної еволюції.</p>
<p>Проте для еволюціонування симуляції немає обов’язкової вимоги, щоб ви малювали й анімували розвиток кожного покоління. Сотні поколінь можна було б завершити миттєво, якби ви могли пропустити весь час, витрачений на рендеринг сцени. Або натомість ви можете відтворювати його <em>набагато рідше</em>. Це позбавить вас від зайвої дратівливості щоразу, коли ви змінюєте невеликий параметр, і чекаєте, здається, години, щоб побачити, чи вплинула ця зміна на еволюцію системи.</p>
<p>Тут я можу використати одну з моїх улюблених функцій p5.js: можливість швидко створювати стандартні елементи інтерфейсу. Ви бачили це раніше у прикладі 9.4 з функцією <code>createButton()</code>. Цього разу я створю повзунок для контролю кількості ітерацій циклу<code>for</code>, який виконується всередині функції <code>draw()</code>. Цикл <code>for</code> міститиме код для оновлення симуляції (але не малювання). Чим більше разів повторюється цикл, тим швидшою буде анімація.</p>
<p>Ось код для доданого повзунка часу, виключаючи всі інші глобальні змінні та їх ініціалізацію у функції <code>setup()</code>. Зверніть увагу, що код для візуальних елементів відокремлений від коду симуляції фізики, щоб гарантувати, що сама візуалізація в ідбувається лише один раз на кадр <code>draw()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair split"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> timeSlider;
</code></pre><div class="comment"><p>Змінна для повзунка.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  timeSlider = <span class="hljs-title function_">createSlider</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p>Створення повзунка із мінімальним і максимальним діапазоном та початковим значенням.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
  glow.<span class="hljs-title function_">show</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> creature <span class="hljs-keyword">of</span> creatures) {
    creature.<span class="hljs-title function_">show</span>();
  }
</code></pre><div class="comment"><p>Код для малювання відбувається лише один раз на кадр!</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; timeSlider.<span class="hljs-title function_">value</span>(); i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> creature <span class="hljs-keyword">of</span> creatures) {
      creature.<span class="hljs-title function_">seek</span>(glow);
      creature.<span class="hljs-title function_">update</span>(glow);
    }
    glow.<span class="hljs-title function_">update</span>();
    lifeCounter++;
  }
</code></pre><div class="comment"><p>Код симуляції виконується кілька разів на кадр відповідно до значення повзунка.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У p5.js повзунок визначається трьома аргументами: мінімальне значення (коли повзунок знаходиться повністю зліва), максимальне значення (коли повзунок знаходиться справа) і початкове значення (де буде повзунок на початок запуску програми). У цьому випадку повзунок дозволяє запустити симуляцію з 20-кратною швидкістю, щоб швидше досягти результатів еволюції, а потім уповільнити її до 1-кратної швидкості, щоб насолодитися славою розвиненої поведінки на екрані.</p>
<p>О сь остаточна версія прикладу з новим конструктором класу <code>Creature</code> для створення нейронної мережі. Усе інше, пов’язане із застосуванням кроків ГА, залишилося таким самим як у прикладі коду <em>Flappy Bird</em>.</p>
<div data-type="example">
  <h3 id="example-114-dynamic-neuroevolutionary-steering"><a class="heading-link" href="#example-114-dynamic-neuroevolutionary-steering">Приклад 11.4: Динамічна нейроеволюція керувальної поведінки</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/11_nn_ga/11_4_neuro_evolution_steering_seek"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/fZDfxxVrf" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, brain</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velocity</span> = <span class="hljs-title function_">createVector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceleration</span> = <span class="hljs-title function_">createVector</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">4</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxspeed</span> = <span class="hljs-number">4</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fitness</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (brain) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span> = brain;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span> = ml5.<span class="hljs-title function_">neuralNetwork</span>({
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">inputs</span>: <span class="hljs-number">5</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">outputs</span>: <span class="hljs-number">2</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">task</span>: <span class="hljs-string">&quot;regression&quot;</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-attr">neuroEvolution</span>: <span class="hljs-literal">true</span>,
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      });
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-comment">/* Метод seek() прогнозує керувальну силу так само як і раніше. *
</span></code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-comment">/* Метод update() збільшує оцінку придатності так само як і раніше. */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Важко повірити, але ця книга була подорожжю, яка тривала понад 10 років. Дякую тобі, любий читачу, що долучився до неї. Я обіцяю, що це не безкінечний цикл. Яким би звивистим не здавався цей шлях, наче прогулянка з випадковим блуканням, я нарешті використаю керувальну поведінку наближення, щоб дістатися до останнього фрагмента головоломки — спроби об’єднати всі мої попередні дослідження у власній версії “Проєкту екосистеми”.</p>
<h2 id="a-neuroevolutionary-ecosystem"><a class="heading-link" href="#a-neuroevolutionary-ecosystem">Нейроеволюційна екосистема</a></h2>
<p>Кілька моментів із прикладів цього розділу не зовсім узгоджуються з моєю фантазією про моделювання природної екосистеми. Перший з них стосується проблеми, яку я підняв у <a href="/genetic-algorithms#section-genetic-algorithms">Розділі 9</a>, коли розбирався з блупами. Ми розглядали систему створінь, які одночасно живуть і так само одночасно вмирають, повністю відроджуючись у кожному наступному поколінні, але реальний біологічний світ влаштований не так! Я хотів би повернутися до цієї дилеми в контексті нейроеволюції цього розділу.</p>
<p>Другий, і мабуть, важливіший серйозний недолік у тому, як я вибираю необхідні характеристики для навчання моделі. Створіння у прикладі 11.4 є всезнайками. Звісно, розумно зробити припущення, що істота знає свою власну поточну швидкість, але я також дозволив кожному створінню знати й точне місце розташування сяйва, незалежно від того, наскільки далеко воно знаходиться чи у який бік спрямовано саме створіння та незалежно від того, що його зір або інші сенсори можуть бути частково заблоковані. Це суперечить одному з основних принципів автономних агентів, які я представив у <a href="/autonomous-agents#section-autonomous-agents">Розділі 5</a>, що агент повинен мати <em>обмежену</em> здатність сприйняття свого оточення.</p>
<h3 id="sensing-the-environment"><a class="heading-link" href="#sensing-the-environment">Сприйняття навколишнього середовища</a></h3>
<p>Загальний підхід до моделювання реальної істоти (або робота), що матиме обмежену обізнаність свого оточення, полягає в тому, щоб прикріпити до такого агента <strong>датчики</strong>. Згадайте мишу у лабіринті з початку розділу, а тепер уявіть, що їй доводиться орієнтуватися у подібному лабіринті в темряві. Її вуса можуть працювати як датчики наближення, щоб виявляти стіни й повороти. Мишачі вуса не бачать весь л абіринт, а відчувають лише найближче оточення. Ще одним прикладом з сенсорами є кажан, який використовує ехолокацію для навігації, або автомобіль на звивистій дорозі, де водій бачить лише те, що освітлюється перед фарами машини.</p>
<p>Я хотів би зупинитися на ідеї про вуса (або більш формально <em>вібриси</em>), які є у мишей, котів та інших ссавців. У реальному світі тварини використовують свої вібриси, щоб орієнтуватися і виявляти об’єкти поблизу, особливо в темряві або затемненому середовищі (див. малюнок 11.5). Як я можу прикріпити датчики, схожі на вуса, до моїх нейроеволюційних створінь, що займаються пошуками?</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1246&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/f11723a16751f5ca1d23284357e7451b/af721/11_nn_ga_7.webp 576w,./static/f11723a16751f5ca1d23284357e7451b/0a8bf/11_nn_ga_7.webp 1152w,./static/f11723a16751f5ca1d23284357e7451b/8950e/11_nn_ga_7.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/f11723a16751f5ca1d23284357e7451b/9ea8b/11_nn_ga_7.png" data-srcset="./static/f11723a16751f5ca1d23284357e7451b/993e5/11_nn_ga_7.png 576w,./static/f11723a16751f5ca1d23284357e7451b/62dd3/11_nn_ga_7.png 1152w,./static/f11723a16751f5ca1d23284357e7451b/9ea8b/11_nn_ga_7.png 2304w" alt="Малюнок 11.5: Кіт Клавдіус відчуває навколишнє середовище своїми вібрисами"/></picture><noscript><picture><source type="image/webp" srcSet="./static/f11723a16751f5ca1d23284357e7451b/af721/11_nn_ga_7.webp 576w,./static/f11723a16751f5ca1d23284357e7451b/0a8bf/11_nn_ga_7.webp 1152w,./static/f11723a16751f5ca1d23284357e7451b/8950e/11_nn_ga_7.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/f11723a16751f5ca1d23284357e7451b/9ea8b/11_nn_ga_7.png" srcSet="./static/f11723a16751f5ca1d23284357e7451b/993e5/11_nn_ga_7.png 576w,./static/f11723a16751f5ca1d23284357e7451b/62dd3/11_nn_ga_7.png 1152w,./static/f11723a16751f5ca1d23284357e7451b/9ea8b/11_nn_ga_7.png 2304w" alt="Малюнок 11.5: Кіт Клавдіус відчуває навколишнє середовище своїми вібрисами"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 11.5: Кіт Клавдіус відчуває навколишнє середовище своїми вібрисами</figcaption>
</figure>
<p>Я збережу загальну назву класу <code>Creature</code>, але буду думати про нього, як про амебоподібного блупа з <a href="/genetic-algorithms#section-genetic-algorithms">Розділу 9</a>, доповненого датчиками схожими на вуса, які виходять із центру тіла в усіх напрямках:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">16</span>;
</code></pre><div class="comment"><p>Створіння має позицію і радіус.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span> = [];
</code></pre><div class="comment"><p>Створіння матиме набір датчиків.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> totalSensors = <span class="hljs-number">8</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalSensors; i++) {
</code></pre><div class="comment"><p>Кількість датчиків.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> angle = <span class="hljs-title function_">map</span>(i, <span class="hljs-number">0</span>, totalSensors, <span class="hljs-number">0</span>, <span class="hljs-variable constant_">TWO_PI</span>);
</code></pre><div class="comment"><p>Спочатку розраховується напрямок для датчика.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>[i] = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">fromAngle</span>(angle);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>[i].<span class="hljs-title function_">setMag</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">1.5</span>);
</code></pre><div class="comment"><p>Створення вектора для датчика. трохи довшого за радіус створіння.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Код створює серію векторів, кожен з яких описує напрямок й довжину для окремих датчиків вусів, прикріплених д о істоти. Однак просто вектора недостатньо. Я хочу, щоб датчик містив значення <code>value</code> — числове представлення того, що він відчуває. Це <code>value</code> можна розглядати як аналог сили дотику. Подібно до того, як вуса кота Клавдіуса можуть відчути слабкий дотик від віддаленого об’єкта або сильніший тиск від ближчого, значення віртуального датчика може змінюватися для оцінки дальності об’єкта.</p>
<p> Перш ніж піти далі, мені потрібно дати створінням щось відчути. Як щодо класу <code>Food</code>, що описуватиме смаколик у вигляді круга, яке створіння бажає знайти? Кожен об’єкт <code>Food</code> матиме позицію і радіус:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(<span class="hljs-title function_">random</span>(width), <span class="hljs-title function_">random</span>(height));
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">50</span>;
  }
</code></pre><div class="comment"><p>Шматок їжі має випадкове пол оження і фіксований радіус.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">noStroke</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-title function_">circle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Як я можу визначити, що сенсор істоти торкається їжі? Одним із підходів може бути використання підходу <strong>рейкастингу (кидання променів)</strong>. Цей підхід зазвичай використовується у комп’ютерній графіці для проєктування п рямих ліній (часто представляють промені світла) від певної точки сцени, щоб визначити з якими об’єктами ці промені перетинаються. Рейкастинг корисний для перевірки області видимості та зіткнень, саме те, що мені потрібно!</p>
<p>Хоча рейкастинг забезпечить надійне рішення, він потребує більше математики, ніж я хотів би зараз використати. Для тих, хто зацікавлений, відповідні пояснення і реалізацію можна переглянути у <a href="https://thecodingtrain.com/raycasting" target="_blank" rel="noopener">відео Coding Challenge #145 на вебсайті Coding Train</a>. Для цього прикладу я виберу простіший підхід і перевірю, чи кінцева точка датчика лежить усередині об’єкта їжі (див. малюнок 11.6)</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1002.9999999999999&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/3309df31e6c457ab13cd3c781ba8f02f/33e19/11_nn_ga_8.webp 576w,./static/3309df31e6c457ab13cd3c781ba8f02f/a361c/11_nn_ga_8.webp 1152w,./static/3309df31e6c457ab13cd3c781ba8f02f/903c1/11_nn_ga_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/3309df31e6c457ab13cd3c781ba8f02f/681b7/11_nn_ga_8.png" data-srcset="./static/3309df31e6c457ab13cd3c781ba8f02f/fed9e/11_nn_ga_8.png 576w,./static/3309df31e6c457ab13cd3c781ba8f02f/e9e07/11_nn_ga_8.png 1152w,./static/3309df31e6c457ab13cd3c781ba8f02f/681b7/11_nn_ga_8.png 2304w" alt="Малюнок 11.6: Кінцева точка датчика знаходиться всередині або поза їжею залежно від його відстані до центру їжі"/></picture><noscript><picture><source type="image/webp" srcSet="./static/3309df31e6c457ab13cd3c781ba8f02f/33e19/11_nn_ga_8.webp 576w,./static/3309df31e6c457ab13cd3c781ba8f02f/a361c/11_nn_ga_8.webp 1152w,./static/3309df31e6c457ab13cd3c781ba8f02f/903c1/11_nn_ga_8.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/3309df31e6c457ab13cd3c781ba8f02f/681b7/11_nn_ga_8.png" srcSet="./static/3309df31e6c457ab13cd3c781ba8f02f/fed9e/11_nn_ga_8.png 576w,./static/3309df31e6c457ab13cd3c781ba8f02f/e9e07/11_nn_ga_8.png 1152w,./static/3309df31e6c457ab13cd3c781ba8f02f/681b7/11_nn_ga_8.png 2304w" alt="Малюнок 11.6: Кінцева точка датчика знаходиться всередині або поза їжею залежно від його відстані до центру їжі"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption>Малюнок 11.6: Кінцева точка датчика знаходиться всередині або поза їжею залежно від його відстані до її центру</figcaption>
</figure>
<p>Оскільки я хочу, щоб датчик зберігав значення для свого вимірювання разом з алгоритмом вимірювання, є сенс інкапсулювати ці елементи у класі <code>Sensor</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sensor</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">v</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> = v.<span class="hljs-title function_">copy</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p>Датчик зберігає значення близькості до того об’єкта, який він відчуває.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">sense</span>(<span class="hljs-params">position, food</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> end = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">add</span>(position, <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span>);
</code></pre><div class="comment"><p>Знаходження зовнішнього кінчика датчика.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> d = end.<span class="hljs-title function_">dist</span>(food.<span class="hljs-property">position</span>);
</code></pre><div class="comment"><p>Яка відстань до центру їжі?</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (d &lt; food.<span class="hljs-property">r</span>) {
</code></pre><div class="comment"><p>Якщо датчик знаходиться у радіусі їжі, він вмикається.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-title function_">map</span>(d, <span class="hljs-number">0</span>, food.<span class="hljs-property">r</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
</code></pre><div class="comment"><p>Чим ближче до центру їжі, тим сильніше активується датчик.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-number">0</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Зауважте, що сенсорний механізм вимірює глибину свого кінчика всередині їжі за допомогою функції <code>map()</code>. Якщо датчик знаходиться поза межами їжі або торкається тільки її зовнішнього краю, то значення <code>value</code> дорівнює 0. Коли кінчик датчика знаходиться в межах їжі й наближається до її центру, то <code>value</code> поступово збільшується від 0 на краях до максимального значення 1 у центрі. Цей градієнт значень відображатиме інтенсивність дотику чи тиску з реального світу.</p>
<p>Перевірмо цей сенсорний механізм на простому прикладі з одним блупом (керованим курсором) і одним шматком їжі (розміщеним у центрі полотна). Коли датчики торкаються їжі, вони світяться і стають яскравішими, коли наближаються до її центру.</p>
<div data-type="example">
  <h3 id="example-115-a-bloop-with-sensors"><a class="heading-link" href="#example-115-a-bloop-with-sensors">Приклад 11.5: Блуп із датчиками</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/11_nn_ga/11_5_creature_sensors"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/vCTMtXXSS" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> bloop, food;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  bloop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creature</span>();
  food = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Food</span>();
</code></pre><div class="comment"><p>Один блуп і один шматок їжі.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  bloop.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = mouseX;
  bloop.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = mouseY;
</code></pre><div class="comment"><p>Положення блупа керується за допомогою курсора.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  food.<span class="hljs-title function_">show</span>();
  bloop.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p>Малювання їжі та блупа.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  bloop.<span class="hljs-title function_">sense</span>(food);
</code></pre><div class="comment"><p>Блуп намагається відчути їжу.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span> = <span class="hljs-title function_">createVector</span>(x, y);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> = <span class="hljs-number">16</span>;
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span> = [];
</code></pre><div class="comment"><p>Створення масиву для сенсорів створіння.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> totalSensors = <span class="hljs-number">15</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; totalSensors; i++) {
      <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">map</span>(i, <span class="hljs-number">0</span>, totalSensors, <span class="hljs-number">0</span>, <span class="hljs-variable constant_">TWO_PI</span>);
      <span class="hljs-keyword">let</span> v = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">fromAngle</span>(a);
      v.<span class="hljs-title function_">mult</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sensor</span>(v);
    }
</code></pre><div class="comment"><p>Кількість датчиків. Як щодо 15?</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">sense</span>(<span class="hljs-params">food</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> sensor <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>) {
      sensor.<span class="hljs-title function_">sense</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, food);
    }
</code></pre><div class="comment"><p>Виклик методу sense() для кожного датчика.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">push</span>();
    <span class="hljs-title function_">translate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> sensor <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>) {
      <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>);
      <span class="hljs-title function_">line</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, sensor.<span class="hljs-property">v</span>.<span class="hljs-property">x</span>, sensor.<span class="hljs-property">v</span>.<span class="hljs-property">y</span>);
      <span class="hljs-keyword">if</span> (sensor.<span class="hljs-property">value</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>, sensor.<span class="hljs-property">value</span> * <span class="hljs-number">255</span>);
        <span class="hljs-title function_">stroke</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)
        <span class="hljs-title function_">circle</span>(sensor.<span class="hljs-property">v</span>.<span class="hljs-property">x</span>, sensor.<span class="hljs-property">v</span>.<span class="hljs-property">y</span>, <span class="hljs-number">8</span>);
      }
    }
    <span class="hljs-title function_">noStroke</span>();
    <span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title function_">circle</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> * <span class="hljs-number">2</span>);
    <span class="hljs-title function_">pop</span>();
  }
</code></pre><div class="comment"><p>Малювання створіння і всіх його датчиків.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>У прикладі датчики істоти намальовані лініями від центру блупа. Коли датчик щось виявляє (коли <code>value</code> більше 0), у нього на кінці з’являється кружечок. Щоб візуалізувати силу показань датчика, я використовую значення <code>value</code> для задання прозорості цього кружечка.</p>
<h3 id="learning-from-the-sensors"><a class="heading-link" href="#learning-from-the-sensors">Навчання від сенсорів</a></h3>
<p>Ви думаєте про те ж саме, що і я? Що, якщо значення сенсорів істоти будуть вхідними даними для нейронної мережі? Якщо припустити, що я знову надаю створінням контроль над їхніми власними рухами, то я міг би написати новий метод <code>think()</code>, який обробляє значення датчиків у мозку нейронної мережі та видає керувальну силу, як у двох останніх прикладах з керуванням:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">think</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> inputs = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>.<span class="hljs-property">length</span>; i++) {
      inputs[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sensors</span>[i].<span class="hljs-property">value</span>;
    }
</code></pre><div class="comment"><p>Підготовка вхідного масиву зі значеннями сенсорів.</p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> outputs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span>.<span class="hljs-title function_">predictSync</span>(inputs);
    <span class="hljs-keyword">let</span> angle = outputs[<span class="hljs-number">0</span>].<span class="hljs-property">value</span> * <span class="hljs-variable constant_">TWO_PI</span>;
    <span class="hljs-keyword">let</span> magnitude = outputs[<span class="hljs-number">1</span>].<span class="hljs-property">value</span>;
    <span class="hljs-keyword">let</span> force = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">fromAngle</span>(angle)
    force.<span class="hljs-title function_">setMag</span>(magnitude);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">applyForce</span>(force);
</code></pre><div class="comment"><p>Прогнозування керувальної сили на основі показників сенсорів.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Наступним логічним кроком могло бути об’єднання всіх звичайних частин ГА, написання оцінювальної функції придатності (скільки їжі з’їдала кожна істота?) і виконання відбору після фіксованого періоду часу для покоління. Але це чудова можливість переглянути принципи безперервної екосистеми й націлитись до формування складнішого середовища та набору потенційних способів поведінки для самих істот. Замість фіксованої тривалості життя для кожного покоління, я використаю для кожного створіння властивість <code>health</code> з <a href="/genetic-algorithms#section-genetic-algorithms">Розділу 9</a>. З кожним кадром анімації, при виконанні функції <code>draw()</code>, рівень здоров’я істоти дещо зменшуватиметься:</p>
<div class="snip-below">
  <div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span> {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* Усі інші властивості створіння */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> = <span class="hljs-number">100</span>;
</code></pre><div class="comment"><p>Рівень здоров’я починається зі значення 100.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-comment">/* Звичайне оновлення положення, швидкості, прискорення */</span>
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> -= <span class="hljs-number">0.25</span>;
</code></pre><div class="comment"><p>Часткове зменшення здоров’я!</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
</div>
<p>Якщо під час виконання функції <code>draw()</code> здоров’я будь-якого блупу падає нижче 0, то він помирає і видаляється з масиву <code>bloops</code>. А для розмноження, замість того, щоб виконувати звичайне схрещування і мутацію відразу, кожен блуп (зі здоров’ям більшим за 0) матиме шанс на відтворення рівний 0.1 відсотка:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bloops.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">if</span> (bloops[i].<span class="hljs-property">health</span> &lt; <span class="hljs-number">0</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        bloops.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; <span class="hljs-number">0.001</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        <span class="hljs-keyword">let</span> child = bloops[i].<span class="hljs-title function_">reproduce</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">        bloops.<span class="hljs-title function_">push</span>(child);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>У методі <code>reproduce()</code> я буду використовувати метод <code>copy()</code> (клонування) замість методу <code>crossover()</code> (спарювання), з вищою, ніж зазвичай, частотою мутацій, щоб покращити рівень варіативності. Я раджу вам також розглянути варіант підходу зі схрещуванням. Ось код:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">reproduce</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> brain = <span class="hljs-variable language_">this</span>.<span class="hljs-property">brain</span>.<span class="hljs-title function_">copy</span>();
    brain.<span class="hljs-title function_">mutate</span>(<span class="hljs-number">0.1</span>);
</code></pre><div class="comment"><p>Копіювання і мутація, замість схрещування і мутації.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creature</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>, brain);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Щоб це спрацювало, деякі блупи повинні жити довше, ніж інші. Споживаючи їжу, їхнє здоров’я покращується, даючи їм додатковий час для розмноження. Я керуватиму цим процесом у класі <code>Creature</code> за допомогою методу <code>eat()</code>:</p>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">eat</span>(<span class="hljs-params">food</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair split"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">let</span> d = p5.<span class="hljs-property">Vector</span>.<span class="hljs-title function_">dist</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">position</span>, food.<span class="hljs-property">position</span>);
    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">r</span> + food.<span class="hljs-property">r</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">health</span> += <span class="hljs-number">0.5</span>;
    }
</code></pre><div class="comment"><p>Якщо блуп знаходиться поруч з їжею, його здоров’я збільшується.</p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div></div>
<p>Чи достатньо цього, щоб система розвивалася і знаходилась у рівновазі? Я міг би зануритися у цю тему ще глибше, налаштовуючи параметри й поведінку в пошуках остаточної еволюційної системи. Я досі не можу так просто позбутися чарівності цієї нескінченної кролячої нори, але досліджу її вже у свій вільний час. Для цілей цієї книги я пропоную вам запустити отриманий приклад, поекспериментувати та зробити власні висновки.</p>
<div data-type="example">
  <h3 id="example-116-a-neuroevolutionary-ecosystem"><a class="heading-link" href="#example-116-a-neuroevolutionary-ecosystem">Приклад 11.6: Нейроеволюційна екосистема</a></h3>
  <figure>
    <div class="not-prose clear-both my-4 overflow-hidden rounded border bg-gray-100" style="max-width:1152px"><div class="relative overflow-hidden rounded-t bg-white"><!-- <div class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%] ">Loading sketch ...</div> --><iframe class="w-full border-none transition-opacity opacity-1000" style="aspect-ratio:2.667" loading="lazy" src="./examples/11_nn_ga/11_6_neuroevolution_ecosystem"></iframe></div><div class="flex items-center justify-between border-t"><div class="flex"><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-[15px] w-[15px]" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg><span class="ml-1.5">Reset</span></button><button class="flex items-center border-r px-2.5 py-1.5 text-sm hover:bg-gray-200"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" aria-hidden="true" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span class="ml-1">Pause</span></button></div><a href="https://editor.p5js.org/natureofcode/sketches/IQbcREjUK" target="_blank" rel="noreferrer" class="flex items-center px-2.5 text-[0.8rem] hover:underline">Open in Web Editor<svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="ml-1 text-gray-500" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></div></div>
    <figcaption></figcaption>
  </figure>
</div>
<div class="codesplit callout not-prose" data-code-language="javascript"><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> bloops = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">let</span> food = [];
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">640</span>, <span class="hljs-number">240</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bloops[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creature</span>(<span class="hljs-title function_">random</span>(width), <span class="hljs-title function_">random</span>(height));
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    food[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Food</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-title function_">background</span>(<span class="hljs-number">255</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = bloops.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bloops[i].<span class="hljs-title function_">think</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bloops[i].<span class="hljs-title function_">eat</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bloops[i].<span class="hljs-title function_">update</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bloops[i].<span class="hljs-title function_">borders</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    <span class="hljs-keyword">if</span> (bloops[i].<span class="hljs-property">health</span> &lt; <span class="hljs-number">0</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      bloops.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">random</span>(<span class="hljs-number">1</span>) &lt; <span class="hljs-number">0.001</span>) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      <span class="hljs-keyword">let</span> child = bloops[i].<span class="hljs-title function_">reproduce</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">      bloops.<span class="hljs-title function_">push</span>(child);
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> treat <span class="hljs-keyword">of</span> food) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    treat.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bloop <span class="hljs-keyword">of</span> bloops) {
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">    bloop.<span class="hljs-title function_">show</span>();
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">  }
</code></pre><div class="comment"><p></p></div></div><div class="pair"><pre><code class="hljs code language-javascript">}
</code></pre><div class="comment"><p></p></div></div></div>
<p>Останній приклад також містить кілька додаткових особливостей, які ви знайдете у супровідному онлайн-коді, як-от масив їжі, яка зменшує свій розмір, коли її поступово з’їдають (відновлюється після вичерпання). Крім того, коли у блупів погіршується здоров’я вони стають прозорішими, аж поки не зникнуть, якщо не встигнуть вчасно підкріпитись.</p>
<div data-type="project" class="callout">
  <h3 id="the-ecosystem-project-12"><a class="heading-link" href="#the-ecosystem-project-12">Проєкт “Екосистема”</a></h3>
  <p>Спробуйте включити у створіння вашого світу концепцію мозку!</p>
  <ul>
    <li>Чи можуть різні створіння мати різні цілі й стимули? Щоб одні шукали їжу, а другі якісь інші ресурси? А як щодо істот, які уникають небезпек, таких як хижаки чи отруйні об’єкти?</li>
    <li>Які входи та виходи мають бути для кожного створіння?</li>
    <li>Яка у створінь сенсорика? Чи вони можуть бачити усе, чи мають обмеження на основі своїх сенсорів?</li>
    <li>Які стратегії ви можете використовувати для встановлення і підтримки балансу у вашій екосистемі?</li>
  </ul>
  <figure>
    <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1420&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#b8b8b8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/f3549768c24af1f28e6380ee5cfdd55c/be6fc/11_nn_ga_9.webp 576w,./static/f3549768c24af1f28e6380ee5cfdd55c/7c4ba/11_nn_ga_9.webp 1152w,./static/f3549768c24af1f28e6380ee5cfdd55c/2e9c6/11_nn_ga_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/f3549768c24af1f28e6380ee5cfdd55c/43bff/11_nn_ga_9.png" data-srcset="./static/f3549768c24af1f28e6380ee5cfdd55c/09264/11_nn_ga_9.png 576w,./static/f3549768c24af1f28e6380ee5cfdd55c/8a8ae/11_nn_ga_9.png 1152w,./static/f3549768c24af1f28e6380ee5cfdd55c/43bff/11_nn_ga_9.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/f3549768c24af1f28e6380ee5cfdd55c/be6fc/11_nn_ga_9.webp 576w,./static/f3549768c24af1f28e6380ee5cfdd55c/7c4ba/11_nn_ga_9.webp 1152w,./static/f3549768c24af1f28e6380ee5cfdd55c/2e9c6/11_nn_ga_9.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/f3549768c24af1f28e6380ee5cfdd55c/43bff/11_nn_ga_9.png" srcSet="./static/f3549768c24af1f28e6380ee5cfdd55c/09264/11_nn_ga_9.png 576w,./static/f3549768c24af1f28e6380ee5cfdd55c/8a8ae/11_nn_ga_9.png 1152w,./static/f3549768c24af1f28e6380ee5cfdd55c/43bff/11_nn_ga_9.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
    <figcaption></figcaption>
  </figure>
</div>
<h2 id="the-end"><a class="heading-link" href="#the-end">Кінець</a></h2>
<p>Якщо ви ще читаєте, мої вітання! Ви дійшли до кінця книги. Але попри кількість матеріалу, яку містить ця книжка, я лише заледве торкнувся поверхні фізичного світу, в якому ми живемо, і методів його моделювання. Я маю намір, щоб ця книга існувала як постійний проєкт і я сподіваюся продовжувати додавати нові уроки й приклади на вебсайті книги, а також розширювати та оновлювати супровідні відеоуроки на вебсайті Coding Train.</p>
<p>Ваші відгуки є дуже цінними, тому можете надіслати їх за електронною поштою <em>daniel@shiffman.net</em> або <a href="https://github.com/nature-of-code" target="_blank" rel="noopener">зробити свій внесок у GitHub-репозиторій проєкту</a>, відповідно до духу проєктів з відкритим кодом. Діліться своїми роботами. Будьмо на зв&#x27;язку і будьмо з природою.</p>
<figure>
  <div data-gatsby-image-wrapper="" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:2304px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg height=&#x27;1551&#x27; width=&#x27;2304&#x27; xmlns=&#x27;http://www.w3.org/2000/svg&#x27; version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="./static/918499c7e449fd4851571854e2c553c2/31c0f/11_nn_ga_10.webp 576w,./static/918499c7e449fd4851571854e2c553c2/017b2/11_nn_ga_10.webp 1152w,./static/918499c7e449fd4851571854e2c553c2/1f602/11_nn_ga_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" data-src="./static/918499c7e449fd4851571854e2c553c2/1d8b2/11_nn_ga_10.png" data-srcset="./static/918499c7e449fd4851571854e2c553c2/c2ab0/11_nn_ga_10.png 576w,./static/918499c7e449fd4851571854e2c553c2/1c9d6/11_nn_ga_10.png 1152w,./static/918499c7e449fd4851571854e2c553c2/1d8b2/11_nn_ga_10.png 2304w" alt=""/></picture><noscript><picture><source type="image/webp" srcSet="./static/918499c7e449fd4851571854e2c553c2/31c0f/11_nn_ga_10.webp 576w,./static/918499c7e449fd4851571854e2c553c2/017b2/11_nn_ga_10.webp 1152w,./static/918499c7e449fd4851571854e2c553c2/1f602/11_nn_ga_10.webp 2304w" sizes="(min-width: 2304px) 2304px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 2304px) 2304px, 100vw" decoding="async" loading="lazy" src="./static/918499c7e449fd4851571854e2c553c2/1d8b2/11_nn_ga_10.png" srcSet="./static/918499c7e449fd4851571854e2c553c2/c2ab0/11_nn_ga_10.png 576w,./static/918499c7e449fd4851571854e2c553c2/1c9d6/11_nn_ga_10.png 1152w,./static/918499c7e449fd4851571854e2c553c2/1d8b2/11_nn_ga_10.png 2304w" alt=""/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div>
  <figcaption></figcaption>
</figure>
</section>
<hr/><section class="not-prose flex w-full justify-between"><div><a class="group block" href="./neural-networks.html"><p class="text-gray-500">Попередній розділ</p><span class="text-lg font-semibold group-hover:underline">← <!-- -->10. Нейронні мережі</span></a></div><div><a class="group block text-right" href="./appendix-creature.html"><p class="text-gray-500">Наступний розділм</p><span class="text-lg font-semibold group-hover:underline">Додаток: Дизайн створінь <!-- --> →</span></a></div></section></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script src="./assets/js/main.js"></script></body></html>